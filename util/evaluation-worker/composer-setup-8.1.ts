import type { WebPHP } from '@php-wasm/web'

export function setupComposer(php: WebPHP) {
  php.mkdirTree('/arena/vendor/bin')
  php.mkdirTree('/arena/vendor/composer')
  php.mkdirTree('/arena/vendor/symfony')
  php.mkdirTree('/arena/vendor/symfony/polyfill-mbstring')
  php.mkdirTree('/arena/vendor/symfony/polyfill-mbstring/Resources')
  php.mkdirTree('/arena/vendor/symfony/polyfill-mbstring/Resources/unidata')
  php.mkdirTree('/arena/vendor/symfony/var-dumper')
  php.mkdirTree('/arena/vendor/symfony/var-dumper/Caster')
  php.mkdirTree('/arena/vendor/symfony/var-dumper/Cloner')
  php.mkdirTree('/arena/vendor/symfony/var-dumper/Command')
  php.mkdirTree('/arena/vendor/symfony/var-dumper/Command/Descriptor')
  php.mkdirTree('/arena/vendor/symfony/var-dumper/Dumper')
  php.mkdirTree('/arena/vendor/symfony/var-dumper/Dumper/ContextProvider')
  php.mkdirTree('/arena/vendor/symfony/var-dumper/Exception')
  php.mkdirTree('/arena/vendor/symfony/var-dumper/Resources')
  php.mkdirTree('/arena/vendor/symfony/var-dumper/Resources/bin')
  php.mkdirTree('/arena/vendor/symfony/var-dumper/Resources/css')
  php.mkdirTree('/arena/vendor/symfony/var-dumper/Resources/functions')
  php.mkdirTree('/arena/vendor/symfony/var-dumper/Resources/js')
  php.mkdirTree('/arena/vendor/symfony/var-dumper/Server')
  php.mkdirTree('/arena/vendor/symfony/var-dumper/Test')

  php.writeFile(
    '/arena/vendor/autoload.php',
    "<?php\n\n// autoload.php @generated by Composer\n\nif (PHP_VERSION_ID < 50600) {\n    if (!headers_sent()) {\n        header('HTTP/1.1 500 Internal Server Error');\n    }\n    $err = 'Composer 2.3.0 dropped support for autoloading on PHP <5.6 and you are running '.PHP_VERSION.', please upgrade PHP or use Composer 2.2 LTS via \"composer self-update --2.2\". Aborting.'.PHP_EOL;\n    if (!ini_get('display_errors')) {\n        if (PHP_SAPI === 'cli' || PHP_SAPI === 'phpdbg') {\n            fwrite(STDERR, $err);\n        } elseif (!headers_sent()) {\n            echo $err;\n        }\n    }\n    trigger_error(\n        $err,\n        E_USER_ERROR\n    );\n}\n\nrequire_once __DIR__ . '/composer/autoload_real.php';\n\nreturn ComposerAutoloaderInit127f768df9d1158ba5bb5d8bef9b56b7::getLoader();\n",
  )
  php.writeFile(
    '/arena/vendor/bin/var-dump-server',
    "#!/usr/bin/env php\n<?php\n\n/**\n * Proxy PHP file generated by Composer\n *\n * This file includes the referenced bin path (../symfony/var-dumper/Resources/bin/var-dump-server)\n * using a stream wrapper to prevent the shebang from being output on PHP<8\n *\n * @generated\n */\n\nnamespace Composer;\n\n$GLOBALS['_composer_bin_dir'] = __DIR__;\n$GLOBALS['_composer_autoload_path'] = __DIR__ . '/..'.'/autoload.php';\n\nif (PHP_VERSION_ID < 80000) {\n    if (!class_exists('Composer\\BinProxyWrapper')) {\n        /**\n         * @internal\n         */\n        final class BinProxyWrapper\n        {\n            private $handle;\n            private $position;\n            private $realpath;\n\n            public function stream_open($path, $mode, $options, &$opened_path)\n            {\n                // get rid of phpvfscomposer:// prefix for __FILE__ & __DIR__ resolution\n                $opened_path = substr($path, 17);\n                $this->realpath = realpath($opened_path) ?: $opened_path;\n                $opened_path = $this->realpath;\n                $this->handle = fopen($this->realpath, $mode);\n                $this->position = 0;\n\n                return (bool) $this->handle;\n            }\n\n            public function stream_read($count)\n            {\n                $data = fread($this->handle, $count);\n\n                if ($this->position === 0) {\n                    $data = preg_replace('{^#!.*\\r?\\n}', '', $data);\n                }\n\n                $this->position += strlen($data);\n\n                return $data;\n            }\n\n            public function stream_cast($castAs)\n            {\n                return $this->handle;\n            }\n\n            public function stream_close()\n            {\n                fclose($this->handle);\n            }\n\n            public function stream_lock($operation)\n            {\n                return $operation ? flock($this->handle, $operation) : true;\n            }\n\n            public function stream_seek($offset, $whence)\n            {\n                if (0 === fseek($this->handle, $offset, $whence)) {\n                    $this->position = ftell($this->handle);\n                    return true;\n                }\n\n                return false;\n            }\n\n            public function stream_tell()\n            {\n                return $this->position;\n            }\n\n            public function stream_eof()\n            {\n                return feof($this->handle);\n            }\n\n            public function stream_stat()\n            {\n                return array();\n            }\n\n            public function stream_set_option($option, $arg1, $arg2)\n            {\n                return true;\n            }\n\n            public function url_stat($path, $flags)\n            {\n                $path = substr($path, 17);\n                if (file_exists($path)) {\n                    return stat($path);\n                }\n\n                return false;\n            }\n        }\n    }\n\n    if (\n        (function_exists('stream_get_wrappers') && in_array('phpvfscomposer', stream_get_wrappers(), true))\n        || (function_exists('stream_wrapper_register') && stream_wrapper_register('phpvfscomposer', 'Composer\\BinProxyWrapper'))\n    ) {\n        include(\"phpvfscomposer://\" . __DIR__ . '/..'.'/symfony/var-dumper/Resources/bin/var-dump-server');\n        exit(0);\n    }\n}\n\ninclude __DIR__ . '/..'.'/symfony/var-dumper/Resources/bin/var-dump-server';\n",
  )
  php.writeFile(
    '/arena/vendor/composer/autoload_classmap.php',
    "<?php\n\n// autoload_classmap.php @generated by Composer\n\n$vendorDir = dirname(__DIR__);\n$baseDir = dirname($vendorDir);\n\nreturn array(\n    'Composer\\\\InstalledVersions' => $vendorDir . '/composer/InstalledVersions.php',\n);\n",
  )
  php.writeFile(
    '/arena/vendor/composer/autoload_files.php',
    "<?php\n\n// autoload_files.php @generated by Composer\n\n$vendorDir = dirname(__DIR__);\n$baseDir = dirname($vendorDir);\n\nreturn array(\n    '0e6d7bf4a5811bfa5cf40c5ccd6fae6a' => $vendorDir . '/symfony/polyfill-mbstring/bootstrap.php',\n    '667aeda72477189d0494fecd327c3641' => $vendorDir . '/symfony/var-dumper/Resources/functions/dump.php',\n);\n",
  )
  php.writeFile(
    '/arena/vendor/composer/autoload_namespaces.php',
    '<?php\n\n// autoload_namespaces.php @generated by Composer\n\n$vendorDir = dirname(__DIR__);\n$baseDir = dirname($vendorDir);\n\nreturn array(\n);\n',
  )
  php.writeFile(
    '/arena/vendor/composer/autoload_psr4.php',
    "<?php\n\n// autoload_psr4.php @generated by Composer\n\n$vendorDir = dirname(__DIR__);\n$baseDir = dirname($vendorDir);\n\nreturn array(\n    'Symfony\\\\Polyfill\\\\Mbstring\\\\' => array($vendorDir . '/symfony/polyfill-mbstring'),\n    'Symfony\\\\Component\\\\VarDumper\\\\' => array($vendorDir . '/symfony/var-dumper'),\n);\n",
  )
  php.writeFile(
    '/arena/vendor/composer/autoload_real.php',
    "<?php\n\n// autoload_real.php @generated by Composer\n\nclass ComposerAutoloaderInit127f768df9d1158ba5bb5d8bef9b56b7\n{\n    private static $loader;\n\n    public static function loadClassLoader($class)\n    {\n        if ('Composer\\Autoload\\ClassLoader' === $class) {\n            require __DIR__ . '/ClassLoader.php';\n        }\n    }\n\n    /**\n     * @return \\Composer\\Autoload\\ClassLoader\n     */\n    public static function getLoader()\n    {\n        if (null !== self::$loader) {\n            return self::$loader;\n        }\n\n        require __DIR__ . '/platform_check.php';\n\n        spl_autoload_register(array('ComposerAutoloaderInit127f768df9d1158ba5bb5d8bef9b56b7', 'loadClassLoader'), true, true);\n        self::$loader = $loader = new \\Composer\\Autoload\\ClassLoader(\\dirname(__DIR__));\n        spl_autoload_unregister(array('ComposerAutoloaderInit127f768df9d1158ba5bb5d8bef9b56b7', 'loadClassLoader'));\n\n        require __DIR__ . '/autoload_static.php';\n        call_user_func(\\Composer\\Autoload\\ComposerStaticInit127f768df9d1158ba5bb5d8bef9b56b7::getInitializer($loader));\n\n        $loader->register(true);\n\n        $filesToLoad = \\Composer\\Autoload\\ComposerStaticInit127f768df9d1158ba5bb5d8bef9b56b7::$files;\n        $requireFile = static function ($fileIdentifier, $file) {\n            if (empty($GLOBALS['__composer_autoload_files'][$fileIdentifier])) {\n                $GLOBALS['__composer_autoload_files'][$fileIdentifier] = true;\n\n                require $file;\n            }\n        };\n        foreach ($filesToLoad as $fileIdentifier => $file) {\n            ($requireFile)($fileIdentifier, $file);\n        }\n\n        return $loader;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/composer/autoload_static.php',
    "<?php\n\n// autoload_static.php @generated by Composer\n\nnamespace Composer\\Autoload;\n\nclass ComposerStaticInit127f768df9d1158ba5bb5d8bef9b56b7\n{\n    public static $files = array (\n        '0e6d7bf4a5811bfa5cf40c5ccd6fae6a' => __DIR__ . '/..' . '/symfony/polyfill-mbstring/bootstrap.php',\n        '667aeda72477189d0494fecd327c3641' => __DIR__ . '/..' . '/symfony/var-dumper/Resources/functions/dump.php',\n    );\n\n    public static $prefixLengthsPsr4 = array (\n        'S' => \n        array (\n            'Symfony\\\\Polyfill\\\\Mbstring\\\\' => 26,\n            'Symfony\\\\Component\\\\VarDumper\\\\' => 28,\n        ),\n    );\n\n    public static $prefixDirsPsr4 = array (\n        'Symfony\\\\Polyfill\\\\Mbstring\\\\' => \n        array (\n            0 => __DIR__ . '/..' . '/symfony/polyfill-mbstring',\n        ),\n        'Symfony\\\\Component\\\\VarDumper\\\\' => \n        array (\n            0 => __DIR__ . '/..' . '/symfony/var-dumper',\n        ),\n    );\n\n    public static $classMap = array (\n        'Composer\\\\InstalledVersions' => __DIR__ . '/..' . '/composer/InstalledVersions.php',\n    );\n\n    public static function getInitializer(ClassLoader $loader)\n    {\n        return \\Closure::bind(function () use ($loader) {\n            $loader->prefixLengthsPsr4 = ComposerStaticInit127f768df9d1158ba5bb5d8bef9b56b7::$prefixLengthsPsr4;\n            $loader->prefixDirsPsr4 = ComposerStaticInit127f768df9d1158ba5bb5d8bef9b56b7::$prefixDirsPsr4;\n            $loader->classMap = ComposerStaticInit127f768df9d1158ba5bb5d8bef9b56b7::$classMap;\n\n        }, null, ClassLoader::class);\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/composer/ClassLoader.php',
    "<?php\n\n/*\n * This file is part of Composer.\n *\n * (c) Nils Adermann <naderman@naderman.de>\n *     Jordi Boggiano <j.boggiano@seld.be>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Composer\\Autoload;\n\n/**\n * ClassLoader implements a PSR-0, PSR-4 and classmap class loader.\n *\n *     $loader = new \\Composer\\Autoload\\ClassLoader();\n *\n *     // register classes with namespaces\n *     $loader->add('Symfony\\Component', __DIR__.'/component');\n *     $loader->add('Symfony',           __DIR__.'/framework');\n *\n *     // activate the autoloader\n *     $loader->register();\n *\n *     // to enable searching the include path (eg. for PEAR packages)\n *     $loader->setUseIncludePath(true);\n *\n * In this example, if you try to use a class in the Symfony\\Component\n * namespace or one of its children (Symfony\\Component\\Console for instance),\n * the autoloader will first look for the class under the component/\n * directory, and it will then fallback to the framework/ directory if not\n * found before giving up.\n *\n * This class is loosely based on the Symfony UniversalClassLoader.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n * @author Jordi Boggiano <j.boggiano@seld.be>\n * @see    https://www.php-fig.org/psr/psr-0/\n * @see    https://www.php-fig.org/psr/psr-4/\n */\nclass ClassLoader\n{\n    /** @var \\Closure(string):void */\n    private static $includeFile;\n\n    /** @var ?string */\n    private $vendorDir;\n\n    // PSR-4\n    /**\n     * @var array[]\n     * @psalm-var array<string, array<string, int>>\n     */\n    private $prefixLengthsPsr4 = array();\n    /**\n     * @var array[]\n     * @psalm-var array<string, array<int, string>>\n     */\n    private $prefixDirsPsr4 = array();\n    /**\n     * @var array[]\n     * @psalm-var array<string, string>\n     */\n    private $fallbackDirsPsr4 = array();\n\n    // PSR-0\n    /**\n     * @var array[]\n     * @psalm-var array<string, array<string, string[]>>\n     */\n    private $prefixesPsr0 = array();\n    /**\n     * @var array[]\n     * @psalm-var array<string, string>\n     */\n    private $fallbackDirsPsr0 = array();\n\n    /** @var bool */\n    private $useIncludePath = false;\n\n    /**\n     * @var string[]\n     * @psalm-var array<string, string>\n     */\n    private $classMap = array();\n\n    /** @var bool */\n    private $classMapAuthoritative = false;\n\n    /**\n     * @var bool[]\n     * @psalm-var array<string, bool>\n     */\n    private $missingClasses = array();\n\n    /** @var ?string */\n    private $apcuPrefix;\n\n    /**\n     * @var self[]\n     */\n    private static $registeredLoaders = array();\n\n    /**\n     * @param ?string $vendorDir\n     */\n    public function __construct($vendorDir = null)\n    {\n        $this->vendorDir = $vendorDir;\n        self::initializeIncludeClosure();\n    }\n\n    /**\n     * @return string[]\n     */\n    public function getPrefixes()\n    {\n        if (!empty($this->prefixesPsr0)) {\n            return call_user_func_array('array_merge', array_values($this->prefixesPsr0));\n        }\n\n        return array();\n    }\n\n    /**\n     * @return array[]\n     * @psalm-return array<string, array<int, string>>\n     */\n    public function getPrefixesPsr4()\n    {\n        return $this->prefixDirsPsr4;\n    }\n\n    /**\n     * @return array[]\n     * @psalm-return array<string, string>\n     */\n    public function getFallbackDirs()\n    {\n        return $this->fallbackDirsPsr0;\n    }\n\n    /**\n     * @return array[]\n     * @psalm-return array<string, string>\n     */\n    public function getFallbackDirsPsr4()\n    {\n        return $this->fallbackDirsPsr4;\n    }\n\n    /**\n     * @return string[] Array of classname => path\n     * @psalm-return array<string, string>\n     */\n    public function getClassMap()\n    {\n        return $this->classMap;\n    }\n\n    /**\n     * @param string[] $classMap Class to filename map\n     * @psalm-param array<string, string> $classMap\n     *\n     * @return void\n     */\n    public function addClassMap(array $classMap)\n    {\n        if ($this->classMap) {\n            $this->classMap = array_merge($this->classMap, $classMap);\n        } else {\n            $this->classMap = $classMap;\n        }\n    }\n\n    /**\n     * Registers a set of PSR-0 directories for a given prefix, either\n     * appending or prepending to the ones previously set for this prefix.\n     *\n     * @param string          $prefix  The prefix\n     * @param string[]|string $paths   The PSR-0 root directories\n     * @param bool            $prepend Whether to prepend the directories\n     *\n     * @return void\n     */\n    public function add($prefix, $paths, $prepend = false)\n    {\n        if (!$prefix) {\n            if ($prepend) {\n                $this->fallbackDirsPsr0 = array_merge(\n                    (array) $paths,\n                    $this->fallbackDirsPsr0\n                );\n            } else {\n                $this->fallbackDirsPsr0 = array_merge(\n                    $this->fallbackDirsPsr0,\n                    (array) $paths\n                );\n            }\n\n            return;\n        }\n\n        $first = $prefix[0];\n        if (!isset($this->prefixesPsr0[$first][$prefix])) {\n            $this->prefixesPsr0[$first][$prefix] = (array) $paths;\n\n            return;\n        }\n        if ($prepend) {\n            $this->prefixesPsr0[$first][$prefix] = array_merge(\n                (array) $paths,\n                $this->prefixesPsr0[$first][$prefix]\n            );\n        } else {\n            $this->prefixesPsr0[$first][$prefix] = array_merge(\n                $this->prefixesPsr0[$first][$prefix],\n                (array) $paths\n            );\n        }\n    }\n\n    /**\n     * Registers a set of PSR-4 directories for a given namespace, either\n     * appending or prepending to the ones previously set for this namespace.\n     *\n     * @param string          $prefix  The prefix/namespace, with trailing '\\\\'\n     * @param string[]|string $paths   The PSR-4 base directories\n     * @param bool            $prepend Whether to prepend the directories\n     *\n     * @throws \\InvalidArgumentException\n     *\n     * @return void\n     */\n    public function addPsr4($prefix, $paths, $prepend = false)\n    {\n        if (!$prefix) {\n            // Register directories for the root namespace.\n            if ($prepend) {\n                $this->fallbackDirsPsr4 = array_merge(\n                    (array) $paths,\n                    $this->fallbackDirsPsr4\n                );\n            } else {\n                $this->fallbackDirsPsr4 = array_merge(\n                    $this->fallbackDirsPsr4,\n                    (array) $paths\n                );\n            }\n        } elseif (!isset($this->prefixDirsPsr4[$prefix])) {\n            // Register directories for a new namespace.\n            $length = strlen($prefix);\n            if ('\\\\' !== $prefix[$length - 1]) {\n                throw new \\InvalidArgumentException(\"A non-empty PSR-4 prefix must end with a namespace separator.\");\n            }\n            $this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;\n            $this->prefixDirsPsr4[$prefix] = (array) $paths;\n        } elseif ($prepend) {\n            // Prepend directories for an already registered namespace.\n            $this->prefixDirsPsr4[$prefix] = array_merge(\n                (array) $paths,\n                $this->prefixDirsPsr4[$prefix]\n            );\n        } else {\n            // Append directories for an already registered namespace.\n            $this->prefixDirsPsr4[$prefix] = array_merge(\n                $this->prefixDirsPsr4[$prefix],\n                (array) $paths\n            );\n        }\n    }\n\n    /**\n     * Registers a set of PSR-0 directories for a given prefix,\n     * replacing any others previously set for this prefix.\n     *\n     * @param string          $prefix The prefix\n     * @param string[]|string $paths  The PSR-0 base directories\n     *\n     * @return void\n     */\n    public function set($prefix, $paths)\n    {\n        if (!$prefix) {\n            $this->fallbackDirsPsr0 = (array) $paths;\n        } else {\n            $this->prefixesPsr0[$prefix[0]][$prefix] = (array) $paths;\n        }\n    }\n\n    /**\n     * Registers a set of PSR-4 directories for a given namespace,\n     * replacing any others previously set for this namespace.\n     *\n     * @param string          $prefix The prefix/namespace, with trailing '\\\\'\n     * @param string[]|string $paths  The PSR-4 base directories\n     *\n     * @throws \\InvalidArgumentException\n     *\n     * @return void\n     */\n    public function setPsr4($prefix, $paths)\n    {\n        if (!$prefix) {\n            $this->fallbackDirsPsr4 = (array) $paths;\n        } else {\n            $length = strlen($prefix);\n            if ('\\\\' !== $prefix[$length - 1]) {\n                throw new \\InvalidArgumentException(\"A non-empty PSR-4 prefix must end with a namespace separator.\");\n            }\n            $this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;\n            $this->prefixDirsPsr4[$prefix] = (array) $paths;\n        }\n    }\n\n    /**\n     * Turns on searching the include path for class files.\n     *\n     * @param bool $useIncludePath\n     *\n     * @return void\n     */\n    public function setUseIncludePath($useIncludePath)\n    {\n        $this->useIncludePath = $useIncludePath;\n    }\n\n    /**\n     * Can be used to check if the autoloader uses the include path to check\n     * for classes.\n     *\n     * @return bool\n     */\n    public function getUseIncludePath()\n    {\n        return $this->useIncludePath;\n    }\n\n    /**\n     * Turns off searching the prefix and fallback directories for classes\n     * that have not been registered with the class map.\n     *\n     * @param bool $classMapAuthoritative\n     *\n     * @return void\n     */\n    public function setClassMapAuthoritative($classMapAuthoritative)\n    {\n        $this->classMapAuthoritative = $classMapAuthoritative;\n    }\n\n    /**\n     * Should class lookup fail if not found in the current class map?\n     *\n     * @return bool\n     */\n    public function isClassMapAuthoritative()\n    {\n        return $this->classMapAuthoritative;\n    }\n\n    /**\n     * APCu prefix to use to cache found/not-found classes, if the extension is enabled.\n     *\n     * @param string|null $apcuPrefix\n     *\n     * @return void\n     */\n    public function setApcuPrefix($apcuPrefix)\n    {\n        $this->apcuPrefix = function_exists('apcu_fetch') && filter_var(ini_get('apc.enabled'), FILTER_VALIDATE_BOOLEAN) ? $apcuPrefix : null;\n    }\n\n    /**\n     * The APCu prefix in use, or null if APCu caching is not enabled.\n     *\n     * @return string|null\n     */\n    public function getApcuPrefix()\n    {\n        return $this->apcuPrefix;\n    }\n\n    /**\n     * Registers this instance as an autoloader.\n     *\n     * @param bool $prepend Whether to prepend the autoloader or not\n     *\n     * @return void\n     */\n    public function register($prepend = false)\n    {\n        spl_autoload_register(array($this, 'loadClass'), true, $prepend);\n\n        if (null === $this->vendorDir) {\n            return;\n        }\n\n        if ($prepend) {\n            self::$registeredLoaders = array($this->vendorDir => $this) + self::$registeredLoaders;\n        } else {\n            unset(self::$registeredLoaders[$this->vendorDir]);\n            self::$registeredLoaders[$this->vendorDir] = $this;\n        }\n    }\n\n    /**\n     * Unregisters this instance as an autoloader.\n     *\n     * @return void\n     */\n    public function unregister()\n    {\n        spl_autoload_unregister(array($this, 'loadClass'));\n\n        if (null !== $this->vendorDir) {\n            unset(self::$registeredLoaders[$this->vendorDir]);\n        }\n    }\n\n    /**\n     * Loads the given class or interface.\n     *\n     * @param  string    $class The name of the class\n     * @return true|null True if loaded, null otherwise\n     */\n    public function loadClass($class)\n    {\n        if ($file = $this->findFile($class)) {\n            (self::$includeFile)($file);\n\n            return true;\n        }\n\n        return null;\n    }\n\n    /**\n     * Finds the path to the file where the class is defined.\n     *\n     * @param string $class The name of the class\n     *\n     * @return string|false The path if found, false otherwise\n     */\n    public function findFile($class)\n    {\n        // class map lookup\n        if (isset($this->classMap[$class])) {\n            return $this->classMap[$class];\n        }\n        if ($this->classMapAuthoritative || isset($this->missingClasses[$class])) {\n            return false;\n        }\n        if (null !== $this->apcuPrefix) {\n            $file = apcu_fetch($this->apcuPrefix.$class, $hit);\n            if ($hit) {\n                return $file;\n            }\n        }\n\n        $file = $this->findFileWithExtension($class, '.php');\n\n        // Search for Hack files if we are running on HHVM\n        if (false === $file && defined('HHVM_VERSION')) {\n            $file = $this->findFileWithExtension($class, '.hh');\n        }\n\n        if (null !== $this->apcuPrefix) {\n            apcu_add($this->apcuPrefix.$class, $file);\n        }\n\n        if (false === $file) {\n            // Remember that this class does not exist.\n            $this->missingClasses[$class] = true;\n        }\n\n        return $file;\n    }\n\n    /**\n     * Returns the currently registered loaders indexed by their corresponding vendor directories.\n     *\n     * @return self[]\n     */\n    public static function getRegisteredLoaders()\n    {\n        return self::$registeredLoaders;\n    }\n\n    /**\n     * @param  string       $class\n     * @param  string       $ext\n     * @return string|false\n     */\n    private function findFileWithExtension($class, $ext)\n    {\n        // PSR-4 lookup\n        $logicalPathPsr4 = strtr($class, '\\\\', DIRECTORY_SEPARATOR) . $ext;\n\n        $first = $class[0];\n        if (isset($this->prefixLengthsPsr4[$first])) {\n            $subPath = $class;\n            while (false !== $lastPos = strrpos($subPath, '\\\\')) {\n                $subPath = substr($subPath, 0, $lastPos);\n                $search = $subPath . '\\\\';\n                if (isset($this->prefixDirsPsr4[$search])) {\n                    $pathEnd = DIRECTORY_SEPARATOR . substr($logicalPathPsr4, $lastPos + 1);\n                    foreach ($this->prefixDirsPsr4[$search] as $dir) {\n                        if (file_exists($file = $dir . $pathEnd)) {\n                            return $file;\n                        }\n                    }\n                }\n            }\n        }\n\n        // PSR-4 fallback dirs\n        foreach ($this->fallbackDirsPsr4 as $dir) {\n            if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr4)) {\n                return $file;\n            }\n        }\n\n        // PSR-0 lookup\n        if (false !== $pos = strrpos($class, '\\\\')) {\n            // namespaced class name\n            $logicalPathPsr0 = substr($logicalPathPsr4, 0, $pos + 1)\n                . strtr(substr($logicalPathPsr4, $pos + 1), '_', DIRECTORY_SEPARATOR);\n        } else {\n            // PEAR-like class name\n            $logicalPathPsr0 = strtr($class, '_', DIRECTORY_SEPARATOR) . $ext;\n        }\n\n        if (isset($this->prefixesPsr0[$first])) {\n            foreach ($this->prefixesPsr0[$first] as $prefix => $dirs) {\n                if (0 === strpos($class, $prefix)) {\n                    foreach ($dirs as $dir) {\n                        if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {\n                            return $file;\n                        }\n                    }\n                }\n            }\n        }\n\n        // PSR-0 fallback dirs\n        foreach ($this->fallbackDirsPsr0 as $dir) {\n            if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {\n                return $file;\n            }\n        }\n\n        // PSR-0 include paths.\n        if ($this->useIncludePath && $file = stream_resolve_include_path($logicalPathPsr0)) {\n            return $file;\n        }\n\n        return false;\n    }\n\n    private static function initializeIncludeClosure(): void\n    {\n        if (self::$includeFile !== null) {\n            return;\n        }\n\n        /**\n         * Scope isolated include.\n         *\n         * Prevents access to $this/self from included files.\n         *\n         * @param  string $file\n         * @return void\n         */\n        self::$includeFile = static function($file) {\n            include $file;\n        };\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/composer/installed.json',
    '{\n    "packages": [\n        {\n            "name": "symfony/polyfill-mbstring",\n            "version": "v1.27.0",\n            "version_normalized": "1.27.0.0",\n            "source": {\n                "type": "git",\n                "url": "https://github.com/symfony/polyfill-mbstring.git",\n                "reference": "8ad114f6b39e2c98a8b0e3bd907732c207c2b534"\n            },\n            "dist": {\n                "type": "zip",\n                "url": "https://api.github.com/repos/symfony/polyfill-mbstring/zipball/8ad114f6b39e2c98a8b0e3bd907732c207c2b534",\n                "reference": "8ad114f6b39e2c98a8b0e3bd907732c207c2b534",\n                "shasum": ""\n            },\n            "require": {\n                "php": ">=7.1"\n            },\n            "provide": {\n                "ext-mbstring": "*"\n            },\n            "suggest": {\n                "ext-mbstring": "For best performance"\n            },\n            "time": "2022-11-03T14:55:06+00:00",\n            "type": "library",\n            "extra": {\n                "branch-alias": {\n                    "dev-main": "1.27-dev"\n                },\n                "thanks": {\n                    "name": "symfony/polyfill",\n                    "url": "https://github.com/symfony/polyfill"\n                }\n            },\n            "installation-source": "dist",\n            "autoload": {\n                "files": [\n                    "bootstrap.php"\n                ],\n                "psr-4": {\n                    "Symfony\\\\Polyfill\\\\Mbstring\\\\": ""\n                }\n            },\n            "notification-url": "https://packagist.org/downloads/",\n            "license": [\n                "MIT"\n            ],\n            "authors": [\n                {\n                    "name": "Nicolas Grekas",\n                    "email": "p@tchwork.com"\n                },\n                {\n                    "name": "Symfony Community",\n                    "homepage": "https://symfony.com/contributors"\n                }\n            ],\n            "description": "Symfony polyfill for the Mbstring extension",\n            "homepage": "https://symfony.com",\n            "keywords": [\n                "compatibility",\n                "mbstring",\n                "polyfill",\n                "portable",\n                "shim"\n            ],\n            "support": {\n                "source": "https://github.com/symfony/polyfill-mbstring/tree/v1.27.0"\n            },\n            "funding": [\n                {\n                    "url": "https://symfony.com/sponsor",\n                    "type": "custom"\n                },\n                {\n                    "url": "https://github.com/fabpot",\n                    "type": "github"\n                },\n                {\n                    "url": "https://tidelift.com/funding/github/packagist/symfony/symfony",\n                    "type": "tidelift"\n                }\n            ],\n            "install-path": "../symfony/polyfill-mbstring"\n        },\n        {\n            "name": "symfony/var-dumper",\n            "version": "v6.3.1",\n            "version_normalized": "6.3.1.0",\n            "source": {\n                "type": "git",\n                "url": "https://github.com/symfony/var-dumper.git",\n                "reference": "c81268d6960ddb47af17391a27d222bd58cf0515"\n            },\n            "dist": {\n                "type": "zip",\n                "url": "https://api.github.com/repos/symfony/var-dumper/zipball/c81268d6960ddb47af17391a27d222bd58cf0515",\n                "reference": "c81268d6960ddb47af17391a27d222bd58cf0515",\n                "shasum": ""\n            },\n            "require": {\n                "php": ">=8.1",\n                "symfony/polyfill-mbstring": "~1.0"\n            },\n            "conflict": {\n                "symfony/console": "<5.4"\n            },\n            "require-dev": {\n                "ext-iconv": "*",\n                "symfony/console": "^5.4|^6.0",\n                "symfony/process": "^5.4|^6.0",\n                "symfony/uid": "^5.4|^6.0",\n                "twig/twig": "^2.13|^3.0.4"\n            },\n            "time": "2023-06-21T12:08:28+00:00",\n            "bin": [\n                "Resources/bin/var-dump-server"\n            ],\n            "type": "library",\n            "installation-source": "dist",\n            "autoload": {\n                "files": [\n                    "Resources/functions/dump.php"\n                ],\n                "psr-4": {\n                    "Symfony\\\\Component\\\\VarDumper\\\\": ""\n                },\n                "exclude-from-classmap": [\n                    "/Tests/"\n                ]\n            },\n            "notification-url": "https://packagist.org/downloads/",\n            "license": [\n                "MIT"\n            ],\n            "authors": [\n                {\n                    "name": "Nicolas Grekas",\n                    "email": "p@tchwork.com"\n                },\n                {\n                    "name": "Symfony Community",\n                    "homepage": "https://symfony.com/contributors"\n                }\n            ],\n            "description": "Provides mechanisms for walking through any arbitrary PHP variable",\n            "homepage": "https://symfony.com",\n            "keywords": [\n                "debug",\n                "dump"\n            ],\n            "support": {\n                "source": "https://github.com/symfony/var-dumper/tree/v6.3.1"\n            },\n            "funding": [\n                {\n                    "url": "https://symfony.com/sponsor",\n                    "type": "custom"\n                },\n                {\n                    "url": "https://github.com/fabpot",\n                    "type": "github"\n                },\n                {\n                    "url": "https://tidelift.com/funding/github/packagist/symfony/symfony",\n                    "type": "tidelift"\n                }\n            ],\n            "install-path": "../symfony/var-dumper"\n        }\n    ],\n    "dev": true,\n    "dev-package-names": []\n}\n',
  )
  php.writeFile(
    '/arena/vendor/composer/installed.php',
    "<?php return array(\n    'root' => array(\n        'name' => '__root__',\n        'pretty_version' => '1.0.0+no-version-set',\n        'version' => '1.0.0.0',\n        'reference' => NULL,\n        'type' => 'library',\n        'install_path' => __DIR__ . '/../../',\n        'aliases' => array(),\n        'dev' => true,\n    ),\n    'versions' => array(\n        '__root__' => array(\n            'pretty_version' => '1.0.0+no-version-set',\n            'version' => '1.0.0.0',\n            'reference' => NULL,\n            'type' => 'library',\n            'install_path' => __DIR__ . '/../../',\n            'aliases' => array(),\n            'dev_requirement' => false,\n        ),\n        'symfony/polyfill-mbstring' => array(\n            'pretty_version' => 'v1.27.0',\n            'version' => '1.27.0.0',\n            'reference' => '8ad114f6b39e2c98a8b0e3bd907732c207c2b534',\n            'type' => 'library',\n            'install_path' => __DIR__ . '/../symfony/polyfill-mbstring',\n            'aliases' => array(),\n            'dev_requirement' => false,\n        ),\n        'symfony/var-dumper' => array(\n            'pretty_version' => 'v6.3.1',\n            'version' => '6.3.1.0',\n            'reference' => 'c81268d6960ddb47af17391a27d222bd58cf0515',\n            'type' => 'library',\n            'install_path' => __DIR__ . '/../symfony/var-dumper',\n            'aliases' => array(),\n            'dev_requirement' => false,\n        ),\n    ),\n);\n",
  )
  php.writeFile(
    '/arena/vendor/composer/InstalledVersions.php',
    "<?php\n\n/*\n * This file is part of Composer.\n *\n * (c) Nils Adermann <naderman@naderman.de>\n *     Jordi Boggiano <j.boggiano@seld.be>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Composer;\n\nuse Composer\\Autoload\\ClassLoader;\nuse Composer\\Semver\\VersionParser;\n\n/**\n * This class is copied in every Composer installed project and available to all\n *\n * See also https://getcomposer.org/doc/07-runtime.md#installed-versions\n *\n * To require its presence, you can require `composer-runtime-api ^2.0`\n *\n * @final\n */\nclass InstalledVersions\n{\n    /**\n     * @var mixed[]|null\n     * @psalm-var array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>}|array{}|null\n     */\n    private static $installed;\n\n    /**\n     * @var bool|null\n     */\n    private static $canGetVendors;\n\n    /**\n     * @var array[]\n     * @psalm-var array<string, array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>}>\n     */\n    private static $installedByVendor = array();\n\n    /**\n     * Returns a list of all package names which are present, either by being installed, replaced or provided\n     *\n     * @return string[]\n     * @psalm-return list<string>\n     */\n    public static function getInstalledPackages()\n    {\n        $packages = array();\n        foreach (self::getInstalled() as $installed) {\n            $packages[] = array_keys($installed['versions']);\n        }\n\n        if (1 === \\count($packages)) {\n            return $packages[0];\n        }\n\n        return array_keys(array_flip(\\call_user_func_array('array_merge', $packages)));\n    }\n\n    /**\n     * Returns a list of all package names with a specific type e.g. 'library'\n     *\n     * @param  string   $type\n     * @return string[]\n     * @psalm-return list<string>\n     */\n    public static function getInstalledPackagesByType($type)\n    {\n        $packagesByType = array();\n\n        foreach (self::getInstalled() as $installed) {\n            foreach ($installed['versions'] as $name => $package) {\n                if (isset($package['type']) && $package['type'] === $type) {\n                    $packagesByType[] = $name;\n                }\n            }\n        }\n\n        return $packagesByType;\n    }\n\n    /**\n     * Checks whether the given package is installed\n     *\n     * This also returns true if the package name is provided or replaced by another package\n     *\n     * @param  string $packageName\n     * @param  bool   $includeDevRequirements\n     * @return bool\n     */\n    public static function isInstalled($packageName, $includeDevRequirements = true)\n    {\n        foreach (self::getInstalled() as $installed) {\n            if (isset($installed['versions'][$packageName])) {\n                return $includeDevRequirements || empty($installed['versions'][$packageName]['dev_requirement']);\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the given package satisfies a version constraint\n     *\n     * e.g. If you want to know whether version 2.3+ of package foo/bar is installed, you would call:\n     *\n     *   Composer\\InstalledVersions::satisfies(new VersionParser, 'foo/bar', '^2.3')\n     *\n     * @param  VersionParser $parser      Install composer/semver to have access to this class and functionality\n     * @param  string        $packageName\n     * @param  string|null   $constraint  A version constraint to check for, if you pass one you have to make sure composer/semver is required by your package\n     * @return bool\n     */\n    public static function satisfies(VersionParser $parser, $packageName, $constraint)\n    {\n        $constraint = $parser->parseConstraints($constraint);\n        $provided = $parser->parseConstraints(self::getVersionRanges($packageName));\n\n        return $provided->matches($constraint);\n    }\n\n    /**\n     * Returns a version constraint representing all the range(s) which are installed for a given package\n     *\n     * It is easier to use this via isInstalled() with the $constraint argument if you need to check\n     * whether a given version of a package is installed, and not just whether it exists\n     *\n     * @param  string $packageName\n     * @return string Version constraint usable with composer/semver\n     */\n    public static function getVersionRanges($packageName)\n    {\n        foreach (self::getInstalled() as $installed) {\n            if (!isset($installed['versions'][$packageName])) {\n                continue;\n            }\n\n            $ranges = array();\n            if (isset($installed['versions'][$packageName]['pretty_version'])) {\n                $ranges[] = $installed['versions'][$packageName]['pretty_version'];\n            }\n            if (array_key_exists('aliases', $installed['versions'][$packageName])) {\n                $ranges = array_merge($ranges, $installed['versions'][$packageName]['aliases']);\n            }\n            if (array_key_exists('replaced', $installed['versions'][$packageName])) {\n                $ranges = array_merge($ranges, $installed['versions'][$packageName]['replaced']);\n            }\n            if (array_key_exists('provided', $installed['versions'][$packageName])) {\n                $ranges = array_merge($ranges, $installed['versions'][$packageName]['provided']);\n            }\n\n            return implode(' || ', $ranges);\n        }\n\n        throw new \\OutOfBoundsException('Package \"' . $packageName . '\" is not installed');\n    }\n\n    /**\n     * @param  string      $packageName\n     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as version, use satisfies or getVersionRanges if you need to know if a given version is present\n     */\n    public static function getVersion($packageName)\n    {\n        foreach (self::getInstalled() as $installed) {\n            if (!isset($installed['versions'][$packageName])) {\n                continue;\n            }\n\n            if (!isset($installed['versions'][$packageName]['version'])) {\n                return null;\n            }\n\n            return $installed['versions'][$packageName]['version'];\n        }\n\n        throw new \\OutOfBoundsException('Package \"' . $packageName . '\" is not installed');\n    }\n\n    /**\n     * @param  string      $packageName\n     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as version, use satisfies or getVersionRanges if you need to know if a given version is present\n     */\n    public static function getPrettyVersion($packageName)\n    {\n        foreach (self::getInstalled() as $installed) {\n            if (!isset($installed['versions'][$packageName])) {\n                continue;\n            }\n\n            if (!isset($installed['versions'][$packageName]['pretty_version'])) {\n                return null;\n            }\n\n            return $installed['versions'][$packageName]['pretty_version'];\n        }\n\n        throw new \\OutOfBoundsException('Package \"' . $packageName . '\" is not installed');\n    }\n\n    /**\n     * @param  string      $packageName\n     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as reference\n     */\n    public static function getReference($packageName)\n    {\n        foreach (self::getInstalled() as $installed) {\n            if (!isset($installed['versions'][$packageName])) {\n                continue;\n            }\n\n            if (!isset($installed['versions'][$packageName]['reference'])) {\n                return null;\n            }\n\n            return $installed['versions'][$packageName]['reference'];\n        }\n\n        throw new \\OutOfBoundsException('Package \"' . $packageName . '\" is not installed');\n    }\n\n    /**\n     * @param  string      $packageName\n     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as install path. Packages of type metapackages also have a null install path.\n     */\n    public static function getInstallPath($packageName)\n    {\n        foreach (self::getInstalled() as $installed) {\n            if (!isset($installed['versions'][$packageName])) {\n                continue;\n            }\n\n            return isset($installed['versions'][$packageName]['install_path']) ? $installed['versions'][$packageName]['install_path'] : null;\n        }\n\n        throw new \\OutOfBoundsException('Package \"' . $packageName . '\" is not installed');\n    }\n\n    /**\n     * @return array\n     * @psalm-return array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}\n     */\n    public static function getRootPackage()\n    {\n        $installed = self::getInstalled();\n\n        return $installed[0]['root'];\n    }\n\n    /**\n     * Returns the raw installed.php data for custom implementations\n     *\n     * @deprecated Use getAllRawData() instead which returns all datasets for all autoloaders present in the process. getRawData only returns the first dataset loaded, which may not be what you expect.\n     * @return array[]\n     * @psalm-return array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>}\n     */\n    public static function getRawData()\n    {\n        @trigger_error('getRawData only returns the first dataset loaded, which may not be what you expect. Use getAllRawData() instead which returns all datasets for all autoloaders present in the process.', E_USER_DEPRECATED);\n\n        if (null === self::$installed) {\n            // only require the installed.php file if this file is loaded from its dumped location,\n            // and not from its source location in the composer/composer package, see https://github.com/composer/composer/issues/9937\n            if (substr(__DIR__, -8, 1) !== 'C') {\n                self::$installed = include __DIR__ . '/installed.php';\n            } else {\n                self::$installed = array();\n            }\n        }\n\n        return self::$installed;\n    }\n\n    /**\n     * Returns the raw data of all installed.php which are currently loaded for custom implementations\n     *\n     * @return array[]\n     * @psalm-return list<array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>}>\n     */\n    public static function getAllRawData()\n    {\n        return self::getInstalled();\n    }\n\n    /**\n     * Lets you reload the static array from another file\n     *\n     * This is only useful for complex integrations in which a project needs to use\n     * this class but then also needs to execute another project's autoloader in process,\n     * and wants to ensure both projects have access to their version of installed.php.\n     *\n     * A typical case would be PHPUnit, where it would need to make sure it reads all\n     * the data it needs from this class, then call reload() with\n     * `require $CWD/vendor/composer/installed.php` (or similar) as input to make sure\n     * the project in which it runs can then also use this class safely, without\n     * interference between PHPUnit's dependencies and the project's dependencies.\n     *\n     * @param  array[] $data A vendor/composer/installed.php data set\n     * @return void\n     *\n     * @psalm-param array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>} $data\n     */\n    public static function reload($data)\n    {\n        self::$installed = $data;\n        self::$installedByVendor = array();\n    }\n\n    /**\n     * @return array[]\n     * @psalm-return list<array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>}>\n     */\n    private static function getInstalled()\n    {\n        if (null === self::$canGetVendors) {\n            self::$canGetVendors = method_exists('Composer\\Autoload\\ClassLoader', 'getRegisteredLoaders');\n        }\n\n        $installed = array();\n\n        if (self::$canGetVendors) {\n            foreach (ClassLoader::getRegisteredLoaders() as $vendorDir => $loader) {\n                if (isset(self::$installedByVendor[$vendorDir])) {\n                    $installed[] = self::$installedByVendor[$vendorDir];\n                } elseif (is_file($vendorDir.'/composer/installed.php')) {\n                    $installed[] = self::$installedByVendor[$vendorDir] = require $vendorDir.'/composer/installed.php';\n                    if (null === self::$installed && strtr($vendorDir.'/composer', '\\\\', '/') === strtr(__DIR__, '\\\\', '/')) {\n                        self::$installed = $installed[count($installed) - 1];\n                    }\n                }\n            }\n        }\n\n        if (null === self::$installed) {\n            // only require the installed.php file if this file is loaded from its dumped location,\n            // and not from its source location in the composer/composer package, see https://github.com/composer/composer/issues/9937\n            if (substr(__DIR__, -8, 1) !== 'C') {\n                self::$installed = require __DIR__ . '/installed.php';\n            } else {\n                self::$installed = array();\n            }\n        }\n        $installed[] = self::$installed;\n\n        return $installed;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/composer/LICENSE',
    '\nCopyright (c) Nils Adermann, Jordi Boggiano\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n',
  )
  php.writeFile(
    '/arena/vendor/composer/platform_check.php',
    "<?php\n\n// platform_check.php @generated by Composer\n\n$issues = array();\n\nif (!(PHP_VERSION_ID >= 80100)) {\n    $issues[] = 'Your Composer dependencies require a PHP version \">= 8.1.0\". You are running ' . PHP_VERSION . '.';\n}\n\nif ($issues) {\n    if (!headers_sent()) {\n        header('HTTP/1.1 500 Internal Server Error');\n    }\n    if (!ini_get('display_errors')) {\n        if (PHP_SAPI === 'cli' || PHP_SAPI === 'phpdbg') {\n            fwrite(STDERR, 'Composer detected issues in your platform:' . PHP_EOL.PHP_EOL . implode(PHP_EOL, $issues) . PHP_EOL.PHP_EOL);\n        } elseif (!headers_sent()) {\n            echo 'Composer detected issues in your platform:' . PHP_EOL.PHP_EOL . str_replace('You are running '.PHP_VERSION.'.', '', implode(PHP_EOL, $issues)) . PHP_EOL.PHP_EOL;\n        }\n    }\n    trigger_error(\n        'Composer detected issues in your platform: ' . implode(' ', $issues),\n        E_USER_ERROR\n    );\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/polyfill-mbstring/bootstrap.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nuse Symfony\\Polyfill\\Mbstring as p;\n\nif (\\PHP_VERSION_ID >= 80000) {\n    return require __DIR__.'/bootstrap80.php';\n}\n\nif (!function_exists('mb_convert_encoding')) {\n    function mb_convert_encoding($string, $to_encoding, $from_encoding = null) { return p\\Mbstring::mb_convert_encoding($string, $to_encoding, $from_encoding); }\n}\nif (!function_exists('mb_decode_mimeheader')) {\n    function mb_decode_mimeheader($string) { return p\\Mbstring::mb_decode_mimeheader($string); }\n}\nif (!function_exists('mb_encode_mimeheader')) {\n    function mb_encode_mimeheader($string, $charset = null, $transfer_encoding = null, $newline = \"\\r\\n\", $indent = 0) { return p\\Mbstring::mb_encode_mimeheader($string, $charset, $transfer_encoding, $newline, $indent); }\n}\nif (!function_exists('mb_decode_numericentity')) {\n    function mb_decode_numericentity($string, $map, $encoding = null) { return p\\Mbstring::mb_decode_numericentity($string, $map, $encoding); }\n}\nif (!function_exists('mb_encode_numericentity')) {\n    function mb_encode_numericentity($string, $map, $encoding = null, $hex = false) { return p\\Mbstring::mb_encode_numericentity($string, $map, $encoding, $hex); }\n}\nif (!function_exists('mb_convert_case')) {\n    function mb_convert_case($string, $mode, $encoding = null) { return p\\Mbstring::mb_convert_case($string, $mode, $encoding); }\n}\nif (!function_exists('mb_internal_encoding')) {\n    function mb_internal_encoding($encoding = null) { return p\\Mbstring::mb_internal_encoding($encoding); }\n}\nif (!function_exists('mb_language')) {\n    function mb_language($language = null) { return p\\Mbstring::mb_language($language); }\n}\nif (!function_exists('mb_list_encodings')) {\n    function mb_list_encodings() { return p\\Mbstring::mb_list_encodings(); }\n}\nif (!function_exists('mb_encoding_aliases')) {\n    function mb_encoding_aliases($encoding) { return p\\Mbstring::mb_encoding_aliases($encoding); }\n}\nif (!function_exists('mb_check_encoding')) {\n    function mb_check_encoding($value = null, $encoding = null) { return p\\Mbstring::mb_check_encoding($value, $encoding); }\n}\nif (!function_exists('mb_detect_encoding')) {\n    function mb_detect_encoding($string, $encodings = null, $strict = false) { return p\\Mbstring::mb_detect_encoding($string, $encodings, $strict); }\n}\nif (!function_exists('mb_detect_order')) {\n    function mb_detect_order($encoding = null) { return p\\Mbstring::mb_detect_order($encoding); }\n}\nif (!function_exists('mb_parse_str')) {\n    function mb_parse_str($string, &$result = []) { parse_str($string, $result); return (bool) $result; }\n}\nif (!function_exists('mb_strlen')) {\n    function mb_strlen($string, $encoding = null) { return p\\Mbstring::mb_strlen($string, $encoding); }\n}\nif (!function_exists('mb_strpos')) {\n    function mb_strpos($haystack, $needle, $offset = 0, $encoding = null) { return p\\Mbstring::mb_strpos($haystack, $needle, $offset, $encoding); }\n}\nif (!function_exists('mb_strtolower')) {\n    function mb_strtolower($string, $encoding = null) { return p\\Mbstring::mb_strtolower($string, $encoding); }\n}\nif (!function_exists('mb_strtoupper')) {\n    function mb_strtoupper($string, $encoding = null) { return p\\Mbstring::mb_strtoupper($string, $encoding); }\n}\nif (!function_exists('mb_substitute_character')) {\n    function mb_substitute_character($substitute_character = null) { return p\\Mbstring::mb_substitute_character($substitute_character); }\n}\nif (!function_exists('mb_substr')) {\n    function mb_substr($string, $start, $length = 2147483647, $encoding = null) { return p\\Mbstring::mb_substr($string, $start, $length, $encoding); }\n}\nif (!function_exists('mb_stripos')) {\n    function mb_stripos($haystack, $needle, $offset = 0, $encoding = null) { return p\\Mbstring::mb_stripos($haystack, $needle, $offset, $encoding); }\n}\nif (!function_exists('mb_stristr')) {\n    function mb_stristr($haystack, $needle, $before_needle = false, $encoding = null) { return p\\Mbstring::mb_stristr($haystack, $needle, $before_needle, $encoding); }\n}\nif (!function_exists('mb_strrchr')) {\n    function mb_strrchr($haystack, $needle, $before_needle = false, $encoding = null) { return p\\Mbstring::mb_strrchr($haystack, $needle, $before_needle, $encoding); }\n}\nif (!function_exists('mb_strrichr')) {\n    function mb_strrichr($haystack, $needle, $before_needle = false, $encoding = null) { return p\\Mbstring::mb_strrichr($haystack, $needle, $before_needle, $encoding); }\n}\nif (!function_exists('mb_strripos')) {\n    function mb_strripos($haystack, $needle, $offset = 0, $encoding = null) { return p\\Mbstring::mb_strripos($haystack, $needle, $offset, $encoding); }\n}\nif (!function_exists('mb_strrpos')) {\n    function mb_strrpos($haystack, $needle, $offset = 0, $encoding = null) { return p\\Mbstring::mb_strrpos($haystack, $needle, $offset, $encoding); }\n}\nif (!function_exists('mb_strstr')) {\n    function mb_strstr($haystack, $needle, $before_needle = false, $encoding = null) { return p\\Mbstring::mb_strstr($haystack, $needle, $before_needle, $encoding); }\n}\nif (!function_exists('mb_get_info')) {\n    function mb_get_info($type = 'all') { return p\\Mbstring::mb_get_info($type); }\n}\nif (!function_exists('mb_http_output')) {\n    function mb_http_output($encoding = null) { return p\\Mbstring::mb_http_output($encoding); }\n}\nif (!function_exists('mb_strwidth')) {\n    function mb_strwidth($string, $encoding = null) { return p\\Mbstring::mb_strwidth($string, $encoding); }\n}\nif (!function_exists('mb_substr_count')) {\n    function mb_substr_count($haystack, $needle, $encoding = null) { return p\\Mbstring::mb_substr_count($haystack, $needle, $encoding); }\n}\nif (!function_exists('mb_output_handler')) {\n    function mb_output_handler($string, $status) { return p\\Mbstring::mb_output_handler($string, $status); }\n}\nif (!function_exists('mb_http_input')) {\n    function mb_http_input($type = null) { return p\\Mbstring::mb_http_input($type); }\n}\n\nif (!function_exists('mb_convert_variables')) {\n    function mb_convert_variables($to_encoding, $from_encoding, &...$vars) { return p\\Mbstring::mb_convert_variables($to_encoding, $from_encoding, ...$vars); }\n}\n\nif (!function_exists('mb_ord')) {\n    function mb_ord($string, $encoding = null) { return p\\Mbstring::mb_ord($string, $encoding); }\n}\nif (!function_exists('mb_chr')) {\n    function mb_chr($codepoint, $encoding = null) { return p\\Mbstring::mb_chr($codepoint, $encoding); }\n}\nif (!function_exists('mb_scrub')) {\n    function mb_scrub($string, $encoding = null) { $encoding = null === $encoding ? mb_internal_encoding() : $encoding; return mb_convert_encoding($string, $encoding, $encoding); }\n}\nif (!function_exists('mb_str_split')) {\n    function mb_str_split($string, $length = 1, $encoding = null) { return p\\Mbstring::mb_str_split($string, $length, $encoding); }\n}\n\nif (extension_loaded('mbstring')) {\n    return;\n}\n\nif (!defined('MB_CASE_UPPER')) {\n    define('MB_CASE_UPPER', 0);\n}\nif (!defined('MB_CASE_LOWER')) {\n    define('MB_CASE_LOWER', 1);\n}\nif (!defined('MB_CASE_TITLE')) {\n    define('MB_CASE_TITLE', 2);\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/polyfill-mbstring/bootstrap80.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nuse Symfony\\Polyfill\\Mbstring as p;\n\nif (!function_exists('mb_convert_encoding')) {\n    function mb_convert_encoding(array|string|null $string, ?string $to_encoding, array|string|null $from_encoding = null): array|string|false { return p\\Mbstring::mb_convert_encoding($string ?? '', (string) $to_encoding, $from_encoding); }\n}\nif (!function_exists('mb_decode_mimeheader')) {\n    function mb_decode_mimeheader(?string $string): string { return p\\Mbstring::mb_decode_mimeheader((string) $string); }\n}\nif (!function_exists('mb_encode_mimeheader')) {\n    function mb_encode_mimeheader(?string $string, ?string $charset = null, ?string $transfer_encoding = null, ?string $newline = \"\\r\\n\", ?int $indent = 0): string { return p\\Mbstring::mb_encode_mimeheader((string) $string, $charset, $transfer_encoding, (string) $newline, (int) $indent); }\n}\nif (!function_exists('mb_decode_numericentity')) {\n    function mb_decode_numericentity(?string $string, array $map, ?string $encoding = null): string { return p\\Mbstring::mb_decode_numericentity((string) $string, $map, $encoding); }\n}\nif (!function_exists('mb_encode_numericentity')) {\n    function mb_encode_numericentity(?string $string, array $map, ?string $encoding = null, ?bool $hex = false): string { return p\\Mbstring::mb_encode_numericentity((string) $string, $map, $encoding, (bool) $hex); }\n}\nif (!function_exists('mb_convert_case')) {\n    function mb_convert_case(?string $string, ?int $mode, ?string $encoding = null): string { return p\\Mbstring::mb_convert_case((string) $string, (int) $mode, $encoding); }\n}\nif (!function_exists('mb_internal_encoding')) {\n    function mb_internal_encoding(?string $encoding = null): string|bool { return p\\Mbstring::mb_internal_encoding($encoding); }\n}\nif (!function_exists('mb_language')) {\n    function mb_language(?string $language = null): string|bool { return p\\Mbstring::mb_language($language); }\n}\nif (!function_exists('mb_list_encodings')) {\n    function mb_list_encodings(): array { return p\\Mbstring::mb_list_encodings(); }\n}\nif (!function_exists('mb_encoding_aliases')) {\n    function mb_encoding_aliases(?string $encoding): array { return p\\Mbstring::mb_encoding_aliases((string) $encoding); }\n}\nif (!function_exists('mb_check_encoding')) {\n    function mb_check_encoding(array|string|null $value = null, ?string $encoding = null): bool { return p\\Mbstring::mb_check_encoding($value, $encoding); }\n}\nif (!function_exists('mb_detect_encoding')) {\n    function mb_detect_encoding(?string $string, array|string|null $encodings = null, ?bool $strict = false): string|false { return p\\Mbstring::mb_detect_encoding((string) $string, $encodings, (bool) $strict); }\n}\nif (!function_exists('mb_detect_order')) {\n    function mb_detect_order(array|string|null $encoding = null): array|bool { return p\\Mbstring::mb_detect_order($encoding); }\n}\nif (!function_exists('mb_parse_str')) {\n    function mb_parse_str(?string $string, &$result = []): bool { parse_str((string) $string, $result); return (bool) $result; }\n}\nif (!function_exists('mb_strlen')) {\n    function mb_strlen(?string $string, ?string $encoding = null): int { return p\\Mbstring::mb_strlen((string) $string, $encoding); }\n}\nif (!function_exists('mb_strpos')) {\n    function mb_strpos(?string $haystack, ?string $needle, ?int $offset = 0, ?string $encoding = null): int|false { return p\\Mbstring::mb_strpos((string) $haystack, (string) $needle, (int) $offset, $encoding); }\n}\nif (!function_exists('mb_strtolower')) {\n    function mb_strtolower(?string $string, ?string $encoding = null): string { return p\\Mbstring::mb_strtolower((string) $string, $encoding); }\n}\nif (!function_exists('mb_strtoupper')) {\n    function mb_strtoupper(?string $string, ?string $encoding = null): string { return p\\Mbstring::mb_strtoupper((string) $string, $encoding); }\n}\nif (!function_exists('mb_substitute_character')) {\n    function mb_substitute_character(string|int|null $substitute_character = null): string|int|bool { return p\\Mbstring::mb_substitute_character($substitute_character); }\n}\nif (!function_exists('mb_substr')) {\n    function mb_substr(?string $string, ?int $start, ?int $length = null, ?string $encoding = null): string { return p\\Mbstring::mb_substr((string) $string, (int) $start, $length, $encoding); }\n}\nif (!function_exists('mb_stripos')) {\n    function mb_stripos(?string $haystack, ?string $needle, ?int $offset = 0, ?string $encoding = null): int|false { return p\\Mbstring::mb_stripos((string) $haystack, (string) $needle, (int) $offset, $encoding); }\n}\nif (!function_exists('mb_stristr')) {\n    function mb_stristr(?string $haystack, ?string $needle, ?bool $before_needle = false, ?string $encoding = null): string|false { return p\\Mbstring::mb_stristr((string) $haystack, (string) $needle, (bool) $before_needle, $encoding); }\n}\nif (!function_exists('mb_strrchr')) {\n    function mb_strrchr(?string $haystack, ?string $needle, ?bool $before_needle = false, ?string $encoding = null): string|false { return p\\Mbstring::mb_strrchr((string) $haystack, (string) $needle, (bool) $before_needle, $encoding); }\n}\nif (!function_exists('mb_strrichr')) {\n    function mb_strrichr(?string $haystack, ?string $needle, ?bool $before_needle = false, ?string $encoding = null): string|false { return p\\Mbstring::mb_strrichr((string) $haystack, (string) $needle, (bool) $before_needle, $encoding); }\n}\nif (!function_exists('mb_strripos')) {\n    function mb_strripos(?string $haystack, ?string $needle, ?int $offset = 0, ?string $encoding = null): int|false { return p\\Mbstring::mb_strripos((string) $haystack, (string) $needle, (int) $offset, $encoding); }\n}\nif (!function_exists('mb_strrpos')) {\n    function mb_strrpos(?string $haystack, ?string $needle, ?int $offset = 0, ?string $encoding = null): int|false { return p\\Mbstring::mb_strrpos((string) $haystack, (string) $needle, (int) $offset, $encoding); }\n}\nif (!function_exists('mb_strstr')) {\n    function mb_strstr(?string $haystack, ?string $needle, ?bool $before_needle = false, ?string $encoding = null): string|false { return p\\Mbstring::mb_strstr((string) $haystack, (string) $needle, (bool) $before_needle, $encoding); }\n}\nif (!function_exists('mb_get_info')) {\n    function mb_get_info(?string $type = 'all'): array|string|int|false { return p\\Mbstring::mb_get_info((string) $type); }\n}\nif (!function_exists('mb_http_output')) {\n    function mb_http_output(?string $encoding = null): string|bool { return p\\Mbstring::mb_http_output($encoding); }\n}\nif (!function_exists('mb_strwidth')) {\n    function mb_strwidth(?string $string, ?string $encoding = null): int { return p\\Mbstring::mb_strwidth((string) $string, $encoding); }\n}\nif (!function_exists('mb_substr_count')) {\n    function mb_substr_count(?string $haystack, ?string $needle, ?string $encoding = null): int { return p\\Mbstring::mb_substr_count((string) $haystack, (string) $needle, $encoding); }\n}\nif (!function_exists('mb_output_handler')) {\n    function mb_output_handler(?string $string, ?int $status): string { return p\\Mbstring::mb_output_handler((string) $string, (int) $status); }\n}\nif (!function_exists('mb_http_input')) {\n    function mb_http_input(?string $type = null): array|string|false { return p\\Mbstring::mb_http_input($type); }\n}\n\nif (!function_exists('mb_convert_variables')) {\n    function mb_convert_variables(?string $to_encoding, array|string|null $from_encoding, mixed &$var, mixed &...$vars): string|false { return p\\Mbstring::mb_convert_variables((string) $to_encoding, $from_encoding ?? '', $var, ...$vars); }\n}\n\nif (!function_exists('mb_ord')) {\n    function mb_ord(?string $string, ?string $encoding = null): int|false { return p\\Mbstring::mb_ord((string) $string, $encoding); }\n}\nif (!function_exists('mb_chr')) {\n    function mb_chr(?int $codepoint, ?string $encoding = null): string|false { return p\\Mbstring::mb_chr((int) $codepoint, $encoding); }\n}\nif (!function_exists('mb_scrub')) {\n    function mb_scrub(?string $string, ?string $encoding = null): string { $encoding ??= mb_internal_encoding(); return mb_convert_encoding((string) $string, $encoding, $encoding); }\n}\nif (!function_exists('mb_str_split')) {\n    function mb_str_split(?string $string, ?int $length = 1, ?string $encoding = null): array { return p\\Mbstring::mb_str_split((string) $string, (int) $length, $encoding); }\n}\n\nif (extension_loaded('mbstring')) {\n    return;\n}\n\nif (!defined('MB_CASE_UPPER')) {\n    define('MB_CASE_UPPER', 0);\n}\nif (!defined('MB_CASE_LOWER')) {\n    define('MB_CASE_LOWER', 1);\n}\nif (!defined('MB_CASE_TITLE')) {\n    define('MB_CASE_TITLE', 2);\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/polyfill-mbstring/composer.json',
    '{\n    "name": "symfony/polyfill-mbstring",\n    "type": "library",\n    "description": "Symfony polyfill for the Mbstring extension",\n    "keywords": ["polyfill", "shim", "compatibility", "portable", "mbstring"],\n    "homepage": "https://symfony.com",\n    "license": "MIT",\n    "authors": [\n        {\n            "name": "Nicolas Grekas",\n            "email": "p@tchwork.com"\n        },\n        {\n            "name": "Symfony Community",\n            "homepage": "https://symfony.com/contributors"\n        }\n    ],\n    "require": {\n        "php": ">=7.1"\n    },\n    "provide": {\n        "ext-mbstring": "*"\n    },\n    "autoload": {\n        "psr-4": { "Symfony\\\\Polyfill\\\\Mbstring\\\\": "" },\n        "files": [ "bootstrap.php" ]\n    },\n    "suggest": {\n        "ext-mbstring": "For best performance"\n    },\n    "minimum-stability": "dev",\n    "extra": {\n        "branch-alias": {\n            "dev-main": "1.27-dev"\n        },\n        "thanks": {\n            "name": "symfony/polyfill",\n            "url": "https://github.com/symfony/polyfill"\n        }\n    }\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/polyfill-mbstring/LICENSE',
    'Copyright (c) 2015-2019 Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/polyfill-mbstring/Mbstring.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Polyfill\\Mbstring;\n\n/**\n * Partial mbstring implementation in PHP, iconv based, UTF-8 centric.\n *\n * Implemented:\n * - mb_chr                  - Returns a specific character from its Unicode code point\n * - mb_convert_encoding     - Convert character encoding\n * - mb_convert_variables    - Convert character code in variable(s)\n * - mb_decode_mimeheader    - Decode string in MIME header field\n * - mb_encode_mimeheader    - Encode string for MIME header XXX NATIVE IMPLEMENTATION IS REALLY BUGGED\n * - mb_decode_numericentity - Decode HTML numeric string reference to character\n * - mb_encode_numericentity - Encode character to HTML numeric string reference\n * - mb_convert_case         - Perform case folding on a string\n * - mb_detect_encoding      - Detect character encoding\n * - mb_get_info             - Get internal settings of mbstring\n * - mb_http_input           - Detect HTTP input character encoding\n * - mb_http_output          - Set/Get HTTP output character encoding\n * - mb_internal_encoding    - Set/Get internal character encoding\n * - mb_list_encodings       - Returns an array of all supported encodings\n * - mb_ord                  - Returns the Unicode code point of a character\n * - mb_output_handler       - Callback function converts character encoding in output buffer\n * - mb_scrub                - Replaces ill-formed byte sequences with substitute characters\n * - mb_strlen               - Get string length\n * - mb_strpos               - Find position of first occurrence of string in a string\n * - mb_strrpos              - Find position of last occurrence of a string in a string\n * - mb_str_split            - Convert a string to an array\n * - mb_strtolower           - Make a string lowercase\n * - mb_strtoupper           - Make a string uppercase\n * - mb_substitute_character - Set/Get substitution character\n * - mb_substr               - Get part of string\n * - mb_stripos              - Finds position of first occurrence of a string within another, case insensitive\n * - mb_stristr              - Finds first occurrence of a string within another, case insensitive\n * - mb_strrchr              - Finds the last occurrence of a character in a string within another\n * - mb_strrichr             - Finds the last occurrence of a character in a string within another, case insensitive\n * - mb_strripos             - Finds position of last occurrence of a string within another, case insensitive\n * - mb_strstr               - Finds first occurrence of a string within another\n * - mb_strwidth             - Return width of string\n * - mb_substr_count         - Count the number of substring occurrences\n *\n * Not implemented:\n * - mb_convert_kana         - Convert \"kana\" one from another (\"zen-kaku\", \"han-kaku\" and more)\n * - mb_ereg_*               - Regular expression with multibyte support\n * - mb_parse_str            - Parse GET/POST/COOKIE data and set global variable\n * - mb_preferred_mime_name  - Get MIME charset string\n * - mb_regex_encoding       - Returns current encoding for multibyte regex as string\n * - mb_regex_set_options    - Set/Get the default options for mbregex functions\n * - mb_send_mail            - Send encoded mail\n * - mb_split                - Split multibyte string using regular expression\n * - mb_strcut               - Get part of string\n * - mb_strimwidth           - Get truncated string with specified width\n *\n * @author Nicolas Grekas <p@tchwork.com>\n *\n * @internal\n */\nfinal class Mbstring\n{\n    public const MB_CASE_FOLD = \\PHP_INT_MAX;\n\n    private const CASE_FOLD = [\n        ['µ', 'ſ', \"\\xCD\\x85\", 'ς', \"\\xCF\\x90\", \"\\xCF\\x91\", \"\\xCF\\x95\", \"\\xCF\\x96\", \"\\xCF\\xB0\", \"\\xCF\\xB1\", \"\\xCF\\xB5\", \"\\xE1\\xBA\\x9B\", \"\\xE1\\xBE\\xBE\"],\n        ['μ', 's', 'ι',        'σ', 'β',        'θ',        'φ',        'π',        'κ',        'ρ',        'ε',        \"\\xE1\\xB9\\xA1\", 'ι'],\n    ];\n\n    private static $encodingList = ['ASCII', 'UTF-8'];\n    private static $language = 'neutral';\n    private static $internalEncoding = 'UTF-8';\n\n    public static function mb_convert_encoding($s, $toEncoding, $fromEncoding = null)\n    {\n        if (\\is_array($fromEncoding) || (null !== $fromEncoding && false !== strpos($fromEncoding, ','))) {\n            $fromEncoding = self::mb_detect_encoding($s, $fromEncoding);\n        } else {\n            $fromEncoding = self::getEncoding($fromEncoding);\n        }\n\n        $toEncoding = self::getEncoding($toEncoding);\n\n        if ('BASE64' === $fromEncoding) {\n            $s = base64_decode($s);\n            $fromEncoding = $toEncoding;\n        }\n\n        if ('BASE64' === $toEncoding) {\n            return base64_encode($s);\n        }\n\n        if ('HTML-ENTITIES' === $toEncoding || 'HTML' === $toEncoding) {\n            if ('HTML-ENTITIES' === $fromEncoding || 'HTML' === $fromEncoding) {\n                $fromEncoding = 'Windows-1252';\n            }\n            if ('UTF-8' !== $fromEncoding) {\n                $s = iconv($fromEncoding, 'UTF-8//IGNORE', $s);\n            }\n\n            return preg_replace_callback('/[\\x80-\\xFF]+/', [__CLASS__, 'html_encoding_callback'], $s);\n        }\n\n        if ('HTML-ENTITIES' === $fromEncoding) {\n            $s = html_entity_decode($s, \\ENT_COMPAT, 'UTF-8');\n            $fromEncoding = 'UTF-8';\n        }\n\n        return iconv($fromEncoding, $toEncoding.'//IGNORE', $s);\n    }\n\n    public static function mb_convert_variables($toEncoding, $fromEncoding, &...$vars)\n    {\n        $ok = true;\n        array_walk_recursive($vars, function (&$v) use (&$ok, $toEncoding, $fromEncoding) {\n            if (false === $v = self::mb_convert_encoding($v, $toEncoding, $fromEncoding)) {\n                $ok = false;\n            }\n        });\n\n        return $ok ? $fromEncoding : false;\n    }\n\n    public static function mb_decode_mimeheader($s)\n    {\n        return iconv_mime_decode($s, 2, self::$internalEncoding);\n    }\n\n    public static function mb_encode_mimeheader($s, $charset = null, $transferEncoding = null, $linefeed = null, $indent = null)\n    {\n        trigger_error('mb_encode_mimeheader() is bugged. Please use iconv_mime_encode() instead', \\E_USER_WARNING);\n    }\n\n    public static function mb_decode_numericentity($s, $convmap, $encoding = null)\n    {\n        if (null !== $s && !\\is_scalar($s) && !(\\is_object($s) && method_exists($s, '__toString'))) {\n            trigger_error('mb_decode_numericentity() expects parameter 1 to be string, '.\\gettype($s).' given', \\E_USER_WARNING);\n\n            return null;\n        }\n\n        if (!\\is_array($convmap) || (80000 > \\PHP_VERSION_ID && !$convmap)) {\n            return false;\n        }\n\n        if (null !== $encoding && !\\is_scalar($encoding)) {\n            trigger_error('mb_decode_numericentity() expects parameter 3 to be string, '.\\gettype($s).' given', \\E_USER_WARNING);\n\n            return '';  // Instead of null (cf. mb_encode_numericentity).\n        }\n\n        $s = (string) $s;\n        if ('' === $s) {\n            return '';\n        }\n\n        $encoding = self::getEncoding($encoding);\n\n        if ('UTF-8' === $encoding) {\n            $encoding = null;\n            if (!preg_match('//u', $s)) {\n                $s = @iconv('UTF-8', 'UTF-8//IGNORE', $s);\n            }\n        } else {\n            $s = iconv($encoding, 'UTF-8//IGNORE', $s);\n        }\n\n        $cnt = floor(\\count($convmap) / 4) * 4;\n\n        for ($i = 0; $i < $cnt; $i += 4) {\n            // collector_decode_htmlnumericentity ignores $convmap[$i + 3]\n            $convmap[$i] += $convmap[$i + 2];\n            $convmap[$i + 1] += $convmap[$i + 2];\n        }\n\n        $s = preg_replace_callback('/&#(?:0*([0-9]+)|x0*([0-9a-fA-F]+))(?!&);?/', function (array $m) use ($cnt, $convmap) {\n            $c = isset($m[2]) ? (int) hexdec($m[2]) : $m[1];\n            for ($i = 0; $i < $cnt; $i += 4) {\n                if ($c >= $convmap[$i] && $c <= $convmap[$i + 1]) {\n                    return self::mb_chr($c - $convmap[$i + 2]);\n                }\n            }\n\n            return $m[0];\n        }, $s);\n\n        if (null === $encoding) {\n            return $s;\n        }\n\n        return iconv('UTF-8', $encoding.'//IGNORE', $s);\n    }\n\n    public static function mb_encode_numericentity($s, $convmap, $encoding = null, $is_hex = false)\n    {\n        if (null !== $s && !\\is_scalar($s) && !(\\is_object($s) && method_exists($s, '__toString'))) {\n            trigger_error('mb_encode_numericentity() expects parameter 1 to be string, '.\\gettype($s).' given', \\E_USER_WARNING);\n\n            return null;\n        }\n\n        if (!\\is_array($convmap) || (80000 > \\PHP_VERSION_ID && !$convmap)) {\n            return false;\n        }\n\n        if (null !== $encoding && !\\is_scalar($encoding)) {\n            trigger_error('mb_encode_numericentity() expects parameter 3 to be string, '.\\gettype($s).' given', \\E_USER_WARNING);\n\n            return null;  // Instead of '' (cf. mb_decode_numericentity).\n        }\n\n        if (null !== $is_hex && !\\is_scalar($is_hex)) {\n            trigger_error('mb_encode_numericentity() expects parameter 4 to be boolean, '.\\gettype($s).' given', \\E_USER_WARNING);\n\n            return null;\n        }\n\n        $s = (string) $s;\n        if ('' === $s) {\n            return '';\n        }\n\n        $encoding = self::getEncoding($encoding);\n\n        if ('UTF-8' === $encoding) {\n            $encoding = null;\n            if (!preg_match('//u', $s)) {\n                $s = @iconv('UTF-8', 'UTF-8//IGNORE', $s);\n            }\n        } else {\n            $s = iconv($encoding, 'UTF-8//IGNORE', $s);\n        }\n\n        static $ulenMask = [\"\\xC0\" => 2, \"\\xD0\" => 2, \"\\xE0\" => 3, \"\\xF0\" => 4];\n\n        $cnt = floor(\\count($convmap) / 4) * 4;\n        $i = 0;\n        $len = \\strlen($s);\n        $result = '';\n\n        while ($i < $len) {\n            $ulen = $s[$i] < \"\\x80\" ? 1 : $ulenMask[$s[$i] & \"\\xF0\"];\n            $uchr = substr($s, $i, $ulen);\n            $i += $ulen;\n            $c = self::mb_ord($uchr);\n\n            for ($j = 0; $j < $cnt; $j += 4) {\n                if ($c >= $convmap[$j] && $c <= $convmap[$j + 1]) {\n                    $cOffset = ($c + $convmap[$j + 2]) & $convmap[$j + 3];\n                    $result .= $is_hex ? sprintf('&#x%X;', $cOffset) : '&#'.$cOffset.';';\n                    continue 2;\n                }\n            }\n            $result .= $uchr;\n        }\n\n        if (null === $encoding) {\n            return $result;\n        }\n\n        return iconv('UTF-8', $encoding.'//IGNORE', $result);\n    }\n\n    public static function mb_convert_case($s, $mode, $encoding = null)\n    {\n        $s = (string) $s;\n        if ('' === $s) {\n            return '';\n        }\n\n        $encoding = self::getEncoding($encoding);\n\n        if ('UTF-8' === $encoding) {\n            $encoding = null;\n            if (!preg_match('//u', $s)) {\n                $s = @iconv('UTF-8', 'UTF-8//IGNORE', $s);\n            }\n        } else {\n            $s = iconv($encoding, 'UTF-8//IGNORE', $s);\n        }\n\n        if (\\MB_CASE_TITLE == $mode) {\n            static $titleRegexp = null;\n            if (null === $titleRegexp) {\n                $titleRegexp = self::getData('titleCaseRegexp');\n            }\n            $s = preg_replace_callback($titleRegexp, [__CLASS__, 'title_case'], $s);\n        } else {\n            if (\\MB_CASE_UPPER == $mode) {\n                static $upper = null;\n                if (null === $upper) {\n                    $upper = self::getData('upperCase');\n                }\n                $map = $upper;\n            } else {\n                if (self::MB_CASE_FOLD === $mode) {\n                    $s = str_replace(self::CASE_FOLD[0], self::CASE_FOLD[1], $s);\n                }\n\n                static $lower = null;\n                if (null === $lower) {\n                    $lower = self::getData('lowerCase');\n                }\n                $map = $lower;\n            }\n\n            static $ulenMask = [\"\\xC0\" => 2, \"\\xD0\" => 2, \"\\xE0\" => 3, \"\\xF0\" => 4];\n\n            $i = 0;\n            $len = \\strlen($s);\n\n            while ($i < $len) {\n                $ulen = $s[$i] < \"\\x80\" ? 1 : $ulenMask[$s[$i] & \"\\xF0\"];\n                $uchr = substr($s, $i, $ulen);\n                $i += $ulen;\n\n                if (isset($map[$uchr])) {\n                    $uchr = $map[$uchr];\n                    $nlen = \\strlen($uchr);\n\n                    if ($nlen == $ulen) {\n                        $nlen = $i;\n                        do {\n                            $s[--$nlen] = $uchr[--$ulen];\n                        } while ($ulen);\n                    } else {\n                        $s = substr_replace($s, $uchr, $i - $ulen, $ulen);\n                        $len += $nlen - $ulen;\n                        $i += $nlen - $ulen;\n                    }\n                }\n            }\n        }\n\n        if (null === $encoding) {\n            return $s;\n        }\n\n        return iconv('UTF-8', $encoding.'//IGNORE', $s);\n    }\n\n    public static function mb_internal_encoding($encoding = null)\n    {\n        if (null === $encoding) {\n            return self::$internalEncoding;\n        }\n\n        $normalizedEncoding = self::getEncoding($encoding);\n\n        if ('UTF-8' === $normalizedEncoding || false !== @iconv($normalizedEncoding, $normalizedEncoding, ' ')) {\n            self::$internalEncoding = $normalizedEncoding;\n\n            return true;\n        }\n\n        if (80000 > \\PHP_VERSION_ID) {\n            return false;\n        }\n\n        throw new \\ValueError(sprintf('Argument #1 ($encoding) must be a valid encoding, \"%s\" given', $encoding));\n    }\n\n    public static function mb_language($lang = null)\n    {\n        if (null === $lang) {\n            return self::$language;\n        }\n\n        switch ($normalizedLang = strtolower($lang)) {\n            case 'uni':\n            case 'neutral':\n                self::$language = $normalizedLang;\n\n                return true;\n        }\n\n        if (80000 > \\PHP_VERSION_ID) {\n            return false;\n        }\n\n        throw new \\ValueError(sprintf('Argument #1 ($language) must be a valid language, \"%s\" given', $lang));\n    }\n\n    public static function mb_list_encodings()\n    {\n        return ['UTF-8'];\n    }\n\n    public static function mb_encoding_aliases($encoding)\n    {\n        switch (strtoupper($encoding)) {\n            case 'UTF8':\n            case 'UTF-8':\n                return ['utf8'];\n        }\n\n        return false;\n    }\n\n    public static function mb_check_encoding($var = null, $encoding = null)\n    {\n        if (null === $encoding) {\n            if (null === $var) {\n                return false;\n            }\n            $encoding = self::$internalEncoding;\n        }\n\n        return self::mb_detect_encoding($var, [$encoding]) || false !== @iconv($encoding, $encoding, $var);\n    }\n\n    public static function mb_detect_encoding($str, $encodingList = null, $strict = false)\n    {\n        if (null === $encodingList) {\n            $encodingList = self::$encodingList;\n        } else {\n            if (!\\is_array($encodingList)) {\n                $encodingList = array_map('trim', explode(',', $encodingList));\n            }\n            $encodingList = array_map('strtoupper', $encodingList);\n        }\n\n        foreach ($encodingList as $enc) {\n            switch ($enc) {\n                case 'ASCII':\n                    if (!preg_match('/[\\x80-\\xFF]/', $str)) {\n                        return $enc;\n                    }\n                    break;\n\n                case 'UTF8':\n                case 'UTF-8':\n                    if (preg_match('//u', $str)) {\n                        return 'UTF-8';\n                    }\n                    break;\n\n                default:\n                    if (0 === strncmp($enc, 'ISO-8859-', 9)) {\n                        return $enc;\n                    }\n            }\n        }\n\n        return false;\n    }\n\n    public static function mb_detect_order($encodingList = null)\n    {\n        if (null === $encodingList) {\n            return self::$encodingList;\n        }\n\n        if (!\\is_array($encodingList)) {\n            $encodingList = array_map('trim', explode(',', $encodingList));\n        }\n        $encodingList = array_map('strtoupper', $encodingList);\n\n        foreach ($encodingList as $enc) {\n            switch ($enc) {\n                default:\n                    if (strncmp($enc, 'ISO-8859-', 9)) {\n                        return false;\n                    }\n                    // no break\n                case 'ASCII':\n                case 'UTF8':\n                case 'UTF-8':\n            }\n        }\n\n        self::$encodingList = $encodingList;\n\n        return true;\n    }\n\n    public static function mb_strlen($s, $encoding = null)\n    {\n        $encoding = self::getEncoding($encoding);\n        if ('CP850' === $encoding || 'ASCII' === $encoding) {\n            return \\strlen($s);\n        }\n\n        return @iconv_strlen($s, $encoding);\n    }\n\n    public static function mb_strpos($haystack, $needle, $offset = 0, $encoding = null)\n    {\n        $encoding = self::getEncoding($encoding);\n        if ('CP850' === $encoding || 'ASCII' === $encoding) {\n            return strpos($haystack, $needle, $offset);\n        }\n\n        $needle = (string) $needle;\n        if ('' === $needle) {\n            if (80000 > \\PHP_VERSION_ID) {\n                trigger_error(__METHOD__.': Empty delimiter', \\E_USER_WARNING);\n\n                return false;\n            }\n\n            return 0;\n        }\n\n        return iconv_strpos($haystack, $needle, $offset, $encoding);\n    }\n\n    public static function mb_strrpos($haystack, $needle, $offset = 0, $encoding = null)\n    {\n        $encoding = self::getEncoding($encoding);\n        if ('CP850' === $encoding || 'ASCII' === $encoding) {\n            return strrpos($haystack, $needle, $offset);\n        }\n\n        if ($offset != (int) $offset) {\n            $offset = 0;\n        } elseif ($offset = (int) $offset) {\n            if ($offset < 0) {\n                if (0 > $offset += self::mb_strlen($needle)) {\n                    $haystack = self::mb_substr($haystack, 0, $offset, $encoding);\n                }\n                $offset = 0;\n            } else {\n                $haystack = self::mb_substr($haystack, $offset, 2147483647, $encoding);\n            }\n        }\n\n        $pos = '' !== $needle || 80000 > \\PHP_VERSION_ID\n            ? iconv_strrpos($haystack, $needle, $encoding)\n            : self::mb_strlen($haystack, $encoding);\n\n        return false !== $pos ? $offset + $pos : false;\n    }\n\n    public static function mb_str_split($string, $split_length = 1, $encoding = null)\n    {\n        if (null !== $string && !\\is_scalar($string) && !(\\is_object($string) && method_exists($string, '__toString'))) {\n            trigger_error('mb_str_split() expects parameter 1 to be string, '.\\gettype($string).' given', \\E_USER_WARNING);\n\n            return null;\n        }\n\n        if (1 > $split_length = (int) $split_length) {\n            if (80000 > \\PHP_VERSION_ID) {\n                trigger_error('The length of each segment must be greater than zero', \\E_USER_WARNING);\n\n                return false;\n            }\n\n            throw new \\ValueError('Argument #2 ($length) must be greater than 0');\n        }\n\n        if (null === $encoding) {\n            $encoding = mb_internal_encoding();\n        }\n\n        if ('UTF-8' === $encoding = self::getEncoding($encoding)) {\n            $rx = '/(';\n            while (65535 < $split_length) {\n                $rx .= '.{65535}';\n                $split_length -= 65535;\n            }\n            $rx .= '.{'.$split_length.'})/us';\n\n            return preg_split($rx, $string, -1, \\PREG_SPLIT_DELIM_CAPTURE | \\PREG_SPLIT_NO_EMPTY);\n        }\n\n        $result = [];\n        $length = mb_strlen($string, $encoding);\n\n        for ($i = 0; $i < $length; $i += $split_length) {\n            $result[] = mb_substr($string, $i, $split_length, $encoding);\n        }\n\n        return $result;\n    }\n\n    public static function mb_strtolower($s, $encoding = null)\n    {\n        return self::mb_convert_case($s, \\MB_CASE_LOWER, $encoding);\n    }\n\n    public static function mb_strtoupper($s, $encoding = null)\n    {\n        return self::mb_convert_case($s, \\MB_CASE_UPPER, $encoding);\n    }\n\n    public static function mb_substitute_character($c = null)\n    {\n        if (null === $c) {\n            return 'none';\n        }\n        if (0 === strcasecmp($c, 'none')) {\n            return true;\n        }\n        if (80000 > \\PHP_VERSION_ID) {\n            return false;\n        }\n        if (\\is_int($c) || 'long' === $c || 'entity' === $c) {\n            return false;\n        }\n\n        throw new \\ValueError('Argument #1 ($substitute_character) must be \"none\", \"long\", \"entity\" or a valid codepoint');\n    }\n\n    public static function mb_substr($s, $start, $length = null, $encoding = null)\n    {\n        $encoding = self::getEncoding($encoding);\n        if ('CP850' === $encoding || 'ASCII' === $encoding) {\n            return (string) substr($s, $start, null === $length ? 2147483647 : $length);\n        }\n\n        if ($start < 0) {\n            $start = iconv_strlen($s, $encoding) + $start;\n            if ($start < 0) {\n                $start = 0;\n            }\n        }\n\n        if (null === $length) {\n            $length = 2147483647;\n        } elseif ($length < 0) {\n            $length = iconv_strlen($s, $encoding) + $length - $start;\n            if ($length < 0) {\n                return '';\n            }\n        }\n\n        return (string) iconv_substr($s, $start, $length, $encoding);\n    }\n\n    public static function mb_stripos($haystack, $needle, $offset = 0, $encoding = null)\n    {\n        $haystack = self::mb_convert_case($haystack, self::MB_CASE_FOLD, $encoding);\n        $needle = self::mb_convert_case($needle, self::MB_CASE_FOLD, $encoding);\n\n        return self::mb_strpos($haystack, $needle, $offset, $encoding);\n    }\n\n    public static function mb_stristr($haystack, $needle, $part = false, $encoding = null)\n    {\n        $pos = self::mb_stripos($haystack, $needle, 0, $encoding);\n\n        return self::getSubpart($pos, $part, $haystack, $encoding);\n    }\n\n    public static function mb_strrchr($haystack, $needle, $part = false, $encoding = null)\n    {\n        $encoding = self::getEncoding($encoding);\n        if ('CP850' === $encoding || 'ASCII' === $encoding) {\n            $pos = strrpos($haystack, $needle);\n        } else {\n            $needle = self::mb_substr($needle, 0, 1, $encoding);\n            $pos = iconv_strrpos($haystack, $needle, $encoding);\n        }\n\n        return self::getSubpart($pos, $part, $haystack, $encoding);\n    }\n\n    public static function mb_strrichr($haystack, $needle, $part = false, $encoding = null)\n    {\n        $needle = self::mb_substr($needle, 0, 1, $encoding);\n        $pos = self::mb_strripos($haystack, $needle, $encoding);\n\n        return self::getSubpart($pos, $part, $haystack, $encoding);\n    }\n\n    public static function mb_strripos($haystack, $needle, $offset = 0, $encoding = null)\n    {\n        $haystack = self::mb_convert_case($haystack, self::MB_CASE_FOLD, $encoding);\n        $needle = self::mb_convert_case($needle, self::MB_CASE_FOLD, $encoding);\n\n        return self::mb_strrpos($haystack, $needle, $offset, $encoding);\n    }\n\n    public static function mb_strstr($haystack, $needle, $part = false, $encoding = null)\n    {\n        $pos = strpos($haystack, $needle);\n        if (false === $pos) {\n            return false;\n        }\n        if ($part) {\n            return substr($haystack, 0, $pos);\n        }\n\n        return substr($haystack, $pos);\n    }\n\n    public static function mb_get_info($type = 'all')\n    {\n        $info = [\n            'internal_encoding' => self::$internalEncoding,\n            'http_output' => 'pass',\n            'http_output_conv_mimetypes' => '^(text/|application/xhtml\\+xml)',\n            'func_overload' => 0,\n            'func_overload_list' => 'no overload',\n            'mail_charset' => 'UTF-8',\n            'mail_header_encoding' => 'BASE64',\n            'mail_body_encoding' => 'BASE64',\n            'illegal_chars' => 0,\n            'encoding_translation' => 'Off',\n            'language' => self::$language,\n            'detect_order' => self::$encodingList,\n            'substitute_character' => 'none',\n            'strict_detection' => 'Off',\n        ];\n\n        if ('all' === $type) {\n            return $info;\n        }\n        if (isset($info[$type])) {\n            return $info[$type];\n        }\n\n        return false;\n    }\n\n    public static function mb_http_input($type = '')\n    {\n        return false;\n    }\n\n    public static function mb_http_output($encoding = null)\n    {\n        return null !== $encoding ? 'pass' === $encoding : 'pass';\n    }\n\n    public static function mb_strwidth($s, $encoding = null)\n    {\n        $encoding = self::getEncoding($encoding);\n\n        if ('UTF-8' !== $encoding) {\n            $s = iconv($encoding, 'UTF-8//IGNORE', $s);\n        }\n\n        $s = preg_replace('/[\\x{1100}-\\x{115F}\\x{2329}\\x{232A}\\x{2E80}-\\x{303E}\\x{3040}-\\x{A4CF}\\x{AC00}-\\x{D7A3}\\x{F900}-\\x{FAFF}\\x{FE10}-\\x{FE19}\\x{FE30}-\\x{FE6F}\\x{FF00}-\\x{FF60}\\x{FFE0}-\\x{FFE6}\\x{20000}-\\x{2FFFD}\\x{30000}-\\x{3FFFD}]/u', '', $s, -1, $wide);\n\n        return ($wide << 1) + iconv_strlen($s, 'UTF-8');\n    }\n\n    public static function mb_substr_count($haystack, $needle, $encoding = null)\n    {\n        return substr_count($haystack, $needle);\n    }\n\n    public static function mb_output_handler($contents, $status)\n    {\n        return $contents;\n    }\n\n    public static function mb_chr($code, $encoding = null)\n    {\n        if (0x80 > $code %= 0x200000) {\n            $s = \\chr($code);\n        } elseif (0x800 > $code) {\n            $s = \\chr(0xC0 | $code >> 6).\\chr(0x80 | $code & 0x3F);\n        } elseif (0x10000 > $code) {\n            $s = \\chr(0xE0 | $code >> 12).\\chr(0x80 | $code >> 6 & 0x3F).\\chr(0x80 | $code & 0x3F);\n        } else {\n            $s = \\chr(0xF0 | $code >> 18).\\chr(0x80 | $code >> 12 & 0x3F).\\chr(0x80 | $code >> 6 & 0x3F).\\chr(0x80 | $code & 0x3F);\n        }\n\n        if ('UTF-8' !== $encoding = self::getEncoding($encoding)) {\n            $s = mb_convert_encoding($s, $encoding, 'UTF-8');\n        }\n\n        return $s;\n    }\n\n    public static function mb_ord($s, $encoding = null)\n    {\n        if ('UTF-8' !== $encoding = self::getEncoding($encoding)) {\n            $s = mb_convert_encoding($s, 'UTF-8', $encoding);\n        }\n\n        if (1 === \\strlen($s)) {\n            return \\ord($s);\n        }\n\n        $code = ($s = unpack('C*', substr($s, 0, 4))) ? $s[1] : 0;\n        if (0xF0 <= $code) {\n            return (($code - 0xF0) << 18) + (($s[2] - 0x80) << 12) + (($s[3] - 0x80) << 6) + $s[4] - 0x80;\n        }\n        if (0xE0 <= $code) {\n            return (($code - 0xE0) << 12) + (($s[2] - 0x80) << 6) + $s[3] - 0x80;\n        }\n        if (0xC0 <= $code) {\n            return (($code - 0xC0) << 6) + $s[2] - 0x80;\n        }\n\n        return $code;\n    }\n\n    private static function getSubpart($pos, $part, $haystack, $encoding)\n    {\n        if (false === $pos) {\n            return false;\n        }\n        if ($part) {\n            return self::mb_substr($haystack, 0, $pos, $encoding);\n        }\n\n        return self::mb_substr($haystack, $pos, null, $encoding);\n    }\n\n    private static function html_encoding_callback(array $m)\n    {\n        $i = 1;\n        $entities = '';\n        $m = unpack('C*', htmlentities($m[0], \\ENT_COMPAT, 'UTF-8'));\n\n        while (isset($m[$i])) {\n            if (0x80 > $m[$i]) {\n                $entities .= \\chr($m[$i++]);\n                continue;\n            }\n            if (0xF0 <= $m[$i]) {\n                $c = (($m[$i++] - 0xF0) << 18) + (($m[$i++] - 0x80) << 12) + (($m[$i++] - 0x80) << 6) + $m[$i++] - 0x80;\n            } elseif (0xE0 <= $m[$i]) {\n                $c = (($m[$i++] - 0xE0) << 12) + (($m[$i++] - 0x80) << 6) + $m[$i++] - 0x80;\n            } else {\n                $c = (($m[$i++] - 0xC0) << 6) + $m[$i++] - 0x80;\n            }\n\n            $entities .= '&#'.$c.';';\n        }\n\n        return $entities;\n    }\n\n    private static function title_case(array $s)\n    {\n        return self::mb_convert_case($s[1], \\MB_CASE_UPPER, 'UTF-8').self::mb_convert_case($s[2], \\MB_CASE_LOWER, 'UTF-8');\n    }\n\n    private static function getData($file)\n    {\n        if (file_exists($file = __DIR__.'/Resources/unidata/'.$file.'.php')) {\n            return require $file;\n        }\n\n        return false;\n    }\n\n    private static function getEncoding($encoding)\n    {\n        if (null === $encoding) {\n            return self::$internalEncoding;\n        }\n\n        if ('UTF-8' === $encoding) {\n            return 'UTF-8';\n        }\n\n        $encoding = strtoupper($encoding);\n\n        if ('8BIT' === $encoding || 'BINARY' === $encoding) {\n            return 'CP850';\n        }\n\n        if ('UTF8' === $encoding) {\n            return 'UTF-8';\n        }\n\n        return $encoding;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/polyfill-mbstring/README.md',
    'Symfony Polyfill / Mbstring\n===========================\n\nThis component provides a partial, native PHP implementation for the\n[Mbstring](https://php.net/mbstring) extension.\n\nMore information can be found in the\n[main Polyfill README](https://github.com/symfony/polyfill/blob/main/README.md).\n\nLicense\n=======\n\nThis library is released under the [MIT license](LICENSE).\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/polyfill-mbstring/Resources/unidata/lowerCase.php',
    "<?php\n\nreturn array (\n  'A' => 'a',\n  'B' => 'b',\n  'C' => 'c',\n  'D' => 'd',\n  'E' => 'e',\n  'F' => 'f',\n  'G' => 'g',\n  'H' => 'h',\n  'I' => 'i',\n  'J' => 'j',\n  'K' => 'k',\n  'L' => 'l',\n  'M' => 'm',\n  'N' => 'n',\n  'O' => 'o',\n  'P' => 'p',\n  'Q' => 'q',\n  'R' => 'r',\n  'S' => 's',\n  'T' => 't',\n  'U' => 'u',\n  'V' => 'v',\n  'W' => 'w',\n  'X' => 'x',\n  'Y' => 'y',\n  'Z' => 'z',\n  'À' => 'à',\n  'Á' => 'á',\n  'Â' => 'â',\n  'Ã' => 'ã',\n  'Ä' => 'ä',\n  'Å' => 'å',\n  'Æ' => 'æ',\n  'Ç' => 'ç',\n  'È' => 'è',\n  'É' => 'é',\n  'Ê' => 'ê',\n  'Ë' => 'ë',\n  'Ì' => 'ì',\n  'Í' => 'í',\n  'Î' => 'î',\n  'Ï' => 'ï',\n  'Ð' => 'ð',\n  'Ñ' => 'ñ',\n  'Ò' => 'ò',\n  'Ó' => 'ó',\n  'Ô' => 'ô',\n  'Õ' => 'õ',\n  'Ö' => 'ö',\n  'Ø' => 'ø',\n  'Ù' => 'ù',\n  'Ú' => 'ú',\n  'Û' => 'û',\n  'Ü' => 'ü',\n  'Ý' => 'ý',\n  'Þ' => 'þ',\n  'Ā' => 'ā',\n  'Ă' => 'ă',\n  'Ą' => 'ą',\n  'Ć' => 'ć',\n  'Ĉ' => 'ĉ',\n  'Ċ' => 'ċ',\n  'Č' => 'č',\n  'Ď' => 'ď',\n  'Đ' => 'đ',\n  'Ē' => 'ē',\n  'Ĕ' => 'ĕ',\n  'Ė' => 'ė',\n  'Ę' => 'ę',\n  'Ě' => 'ě',\n  'Ĝ' => 'ĝ',\n  'Ğ' => 'ğ',\n  'Ġ' => 'ġ',\n  'Ģ' => 'ģ',\n  'Ĥ' => 'ĥ',\n  'Ħ' => 'ħ',\n  'Ĩ' => 'ĩ',\n  'Ī' => 'ī',\n  'Ĭ' => 'ĭ',\n  'Į' => 'į',\n  'İ' => 'i̇',\n  'Ĳ' => 'ĳ',\n  'Ĵ' => 'ĵ',\n  'Ķ' => 'ķ',\n  'Ĺ' => 'ĺ',\n  'Ļ' => 'ļ',\n  'Ľ' => 'ľ',\n  'Ŀ' => 'ŀ',\n  'Ł' => 'ł',\n  'Ń' => 'ń',\n  'Ņ' => 'ņ',\n  'Ň' => 'ň',\n  'Ŋ' => 'ŋ',\n  'Ō' => 'ō',\n  'Ŏ' => 'ŏ',\n  'Ő' => 'ő',\n  'Œ' => 'œ',\n  'Ŕ' => 'ŕ',\n  'Ŗ' => 'ŗ',\n  'Ř' => 'ř',\n  'Ś' => 'ś',\n  'Ŝ' => 'ŝ',\n  'Ş' => 'ş',\n  'Š' => 'š',\n  'Ţ' => 'ţ',\n  'Ť' => 'ť',\n  'Ŧ' => 'ŧ',\n  'Ũ' => 'ũ',\n  'Ū' => 'ū',\n  'Ŭ' => 'ŭ',\n  'Ů' => 'ů',\n  'Ű' => 'ű',\n  'Ų' => 'ų',\n  'Ŵ' => 'ŵ',\n  'Ŷ' => 'ŷ',\n  'Ÿ' => 'ÿ',\n  'Ź' => 'ź',\n  'Ż' => 'ż',\n  'Ž' => 'ž',\n  'Ɓ' => 'ɓ',\n  'Ƃ' => 'ƃ',\n  'Ƅ' => 'ƅ',\n  'Ɔ' => 'ɔ',\n  'Ƈ' => 'ƈ',\n  'Ɖ' => 'ɖ',\n  'Ɗ' => 'ɗ',\n  'Ƌ' => 'ƌ',\n  'Ǝ' => 'ǝ',\n  'Ə' => 'ə',\n  'Ɛ' => 'ɛ',\n  'Ƒ' => 'ƒ',\n  'Ɠ' => 'ɠ',\n  'Ɣ' => 'ɣ',\n  'Ɩ' => 'ɩ',\n  'Ɨ' => 'ɨ',\n  'Ƙ' => 'ƙ',\n  'Ɯ' => 'ɯ',\n  'Ɲ' => 'ɲ',\n  'Ɵ' => 'ɵ',\n  'Ơ' => 'ơ',\n  'Ƣ' => 'ƣ',\n  'Ƥ' => 'ƥ',\n  'Ʀ' => 'ʀ',\n  'Ƨ' => 'ƨ',\n  'Ʃ' => 'ʃ',\n  'Ƭ' => 'ƭ',\n  'Ʈ' => 'ʈ',\n  'Ư' => 'ư',\n  'Ʊ' => 'ʊ',\n  'Ʋ' => 'ʋ',\n  'Ƴ' => 'ƴ',\n  'Ƶ' => 'ƶ',\n  'Ʒ' => 'ʒ',\n  'Ƹ' => 'ƹ',\n  'Ƽ' => 'ƽ',\n  'Ǆ' => 'ǆ',\n  'ǅ' => 'ǆ',\n  'Ǉ' => 'ǉ',\n  'ǈ' => 'ǉ',\n  'Ǌ' => 'ǌ',\n  'ǋ' => 'ǌ',\n  'Ǎ' => 'ǎ',\n  'Ǐ' => 'ǐ',\n  'Ǒ' => 'ǒ',\n  'Ǔ' => 'ǔ',\n  'Ǖ' => 'ǖ',\n  'Ǘ' => 'ǘ',\n  'Ǚ' => 'ǚ',\n  'Ǜ' => 'ǜ',\n  'Ǟ' => 'ǟ',\n  'Ǡ' => 'ǡ',\n  'Ǣ' => 'ǣ',\n  'Ǥ' => 'ǥ',\n  'Ǧ' => 'ǧ',\n  'Ǩ' => 'ǩ',\n  'Ǫ' => 'ǫ',\n  'Ǭ' => 'ǭ',\n  'Ǯ' => 'ǯ',\n  'Ǳ' => 'ǳ',\n  'ǲ' => 'ǳ',\n  'Ǵ' => 'ǵ',\n  'Ƕ' => 'ƕ',\n  'Ƿ' => 'ƿ',\n  'Ǹ' => 'ǹ',\n  'Ǻ' => 'ǻ',\n  'Ǽ' => 'ǽ',\n  'Ǿ' => 'ǿ',\n  'Ȁ' => 'ȁ',\n  'Ȃ' => 'ȃ',\n  'Ȅ' => 'ȅ',\n  'Ȇ' => 'ȇ',\n  'Ȉ' => 'ȉ',\n  'Ȋ' => 'ȋ',\n  'Ȍ' => 'ȍ',\n  'Ȏ' => 'ȏ',\n  'Ȑ' => 'ȑ',\n  'Ȓ' => 'ȓ',\n  'Ȕ' => 'ȕ',\n  'Ȗ' => 'ȗ',\n  'Ș' => 'ș',\n  'Ț' => 'ț',\n  'Ȝ' => 'ȝ',\n  'Ȟ' => 'ȟ',\n  'Ƞ' => 'ƞ',\n  'Ȣ' => 'ȣ',\n  'Ȥ' => 'ȥ',\n  'Ȧ' => 'ȧ',\n  'Ȩ' => 'ȩ',\n  'Ȫ' => 'ȫ',\n  'Ȭ' => 'ȭ',\n  'Ȯ' => 'ȯ',\n  'Ȱ' => 'ȱ',\n  'Ȳ' => 'ȳ',\n  'Ⱥ' => 'ⱥ',\n  'Ȼ' => 'ȼ',\n  'Ƚ' => 'ƚ',\n  'Ⱦ' => 'ⱦ',\n  'Ɂ' => 'ɂ',\n  'Ƀ' => 'ƀ',\n  'Ʉ' => 'ʉ',\n  'Ʌ' => 'ʌ',\n  'Ɇ' => 'ɇ',\n  'Ɉ' => 'ɉ',\n  'Ɋ' => 'ɋ',\n  'Ɍ' => 'ɍ',\n  'Ɏ' => 'ɏ',\n  'Ͱ' => 'ͱ',\n  'Ͳ' => 'ͳ',\n  'Ͷ' => 'ͷ',\n  'Ϳ' => 'ϳ',\n  'Ά' => 'ά',\n  'Έ' => 'έ',\n  'Ή' => 'ή',\n  'Ί' => 'ί',\n  'Ό' => 'ό',\n  'Ύ' => 'ύ',\n  'Ώ' => 'ώ',\n  'Α' => 'α',\n  'Β' => 'β',\n  'Γ' => 'γ',\n  'Δ' => 'δ',\n  'Ε' => 'ε',\n  'Ζ' => 'ζ',\n  'Η' => 'η',\n  'Θ' => 'θ',\n  'Ι' => 'ι',\n  'Κ' => 'κ',\n  'Λ' => 'λ',\n  'Μ' => 'μ',\n  'Ν' => 'ν',\n  'Ξ' => 'ξ',\n  'Ο' => 'ο',\n  'Π' => 'π',\n  'Ρ' => 'ρ',\n  'Σ' => 'σ',\n  'Τ' => 'τ',\n  'Υ' => 'υ',\n  'Φ' => 'φ',\n  'Χ' => 'χ',\n  'Ψ' => 'ψ',\n  'Ω' => 'ω',\n  'Ϊ' => 'ϊ',\n  'Ϋ' => 'ϋ',\n  'Ϗ' => 'ϗ',\n  'Ϙ' => 'ϙ',\n  'Ϛ' => 'ϛ',\n  'Ϝ' => 'ϝ',\n  'Ϟ' => 'ϟ',\n  'Ϡ' => 'ϡ',\n  'Ϣ' => 'ϣ',\n  'Ϥ' => 'ϥ',\n  'Ϧ' => 'ϧ',\n  'Ϩ' => 'ϩ',\n  'Ϫ' => 'ϫ',\n  'Ϭ' => 'ϭ',\n  'Ϯ' => 'ϯ',\n  'ϴ' => 'θ',\n  'Ϸ' => 'ϸ',\n  'Ϲ' => 'ϲ',\n  'Ϻ' => 'ϻ',\n  'Ͻ' => 'ͻ',\n  'Ͼ' => 'ͼ',\n  'Ͽ' => 'ͽ',\n  'Ѐ' => 'ѐ',\n  'Ё' => 'ё',\n  'Ђ' => 'ђ',\n  'Ѓ' => 'ѓ',\n  'Є' => 'є',\n  'Ѕ' => 'ѕ',\n  'І' => 'і',\n  'Ї' => 'ї',\n  'Ј' => 'ј',\n  'Љ' => 'љ',\n  'Њ' => 'њ',\n  'Ћ' => 'ћ',\n  'Ќ' => 'ќ',\n  'Ѝ' => 'ѝ',\n  'Ў' => 'ў',\n  'Џ' => 'џ',\n  'А' => 'а',\n  'Б' => 'б',\n  'В' => 'в',\n  'Г' => 'г',\n  'Д' => 'д',\n  'Е' => 'е',\n  'Ж' => 'ж',\n  'З' => 'з',\n  'И' => 'и',\n  'Й' => 'й',\n  'К' => 'к',\n  'Л' => 'л',\n  'М' => 'м',\n  'Н' => 'н',\n  'О' => 'о',\n  'П' => 'п',\n  'Р' => 'р',\n  'С' => 'с',\n  'Т' => 'т',\n  'У' => 'у',\n  'Ф' => 'ф',\n  'Х' => 'х',\n  'Ц' => 'ц',\n  'Ч' => 'ч',\n  'Ш' => 'ш',\n  'Щ' => 'щ',\n  'Ъ' => 'ъ',\n  'Ы' => 'ы',\n  'Ь' => 'ь',\n  'Э' => 'э',\n  'Ю' => 'ю',\n  'Я' => 'я',\n  'Ѡ' => 'ѡ',\n  'Ѣ' => 'ѣ',\n  'Ѥ' => 'ѥ',\n  'Ѧ' => 'ѧ',\n  'Ѩ' => 'ѩ',\n  'Ѫ' => 'ѫ',\n  'Ѭ' => 'ѭ',\n  'Ѯ' => 'ѯ',\n  'Ѱ' => 'ѱ',\n  'Ѳ' => 'ѳ',\n  'Ѵ' => 'ѵ',\n  'Ѷ' => 'ѷ',\n  'Ѹ' => 'ѹ',\n  'Ѻ' => 'ѻ',\n  'Ѽ' => 'ѽ',\n  'Ѿ' => 'ѿ',\n  'Ҁ' => 'ҁ',\n  'Ҋ' => 'ҋ',\n  'Ҍ' => 'ҍ',\n  'Ҏ' => 'ҏ',\n  'Ґ' => 'ґ',\n  'Ғ' => 'ғ',\n  'Ҕ' => 'ҕ',\n  'Җ' => 'җ',\n  'Ҙ' => 'ҙ',\n  'Қ' => 'қ',\n  'Ҝ' => 'ҝ',\n  'Ҟ' => 'ҟ',\n  'Ҡ' => 'ҡ',\n  'Ң' => 'ң',\n  'Ҥ' => 'ҥ',\n  'Ҧ' => 'ҧ',\n  'Ҩ' => 'ҩ',\n  'Ҫ' => 'ҫ',\n  'Ҭ' => 'ҭ',\n  'Ү' => 'ү',\n  'Ұ' => 'ұ',\n  'Ҳ' => 'ҳ',\n  'Ҵ' => 'ҵ',\n  'Ҷ' => 'ҷ',\n  'Ҹ' => 'ҹ',\n  'Һ' => 'һ',\n  'Ҽ' => 'ҽ',\n  'Ҿ' => 'ҿ',\n  'Ӏ' => 'ӏ',\n  'Ӂ' => 'ӂ',\n  'Ӄ' => 'ӄ',\n  'Ӆ' => 'ӆ',\n  'Ӈ' => 'ӈ',\n  'Ӊ' => 'ӊ',\n  'Ӌ' => 'ӌ',\n  'Ӎ' => 'ӎ',\n  'Ӑ' => 'ӑ',\n  'Ӓ' => 'ӓ',\n  'Ӕ' => 'ӕ',\n  'Ӗ' => 'ӗ',\n  'Ә' => 'ә',\n  'Ӛ' => 'ӛ',\n  'Ӝ' => 'ӝ',\n  'Ӟ' => 'ӟ',\n  'Ӡ' => 'ӡ',\n  'Ӣ' => 'ӣ',\n  'Ӥ' => 'ӥ',\n  'Ӧ' => 'ӧ',\n  'Ө' => 'ө',\n  'Ӫ' => 'ӫ',\n  'Ӭ' => 'ӭ',\n  'Ӯ' => 'ӯ',\n  'Ӱ' => 'ӱ',\n  'Ӳ' => 'ӳ',\n  'Ӵ' => 'ӵ',\n  'Ӷ' => 'ӷ',\n  'Ӹ' => 'ӹ',\n  'Ӻ' => 'ӻ',\n  'Ӽ' => 'ӽ',\n  'Ӿ' => 'ӿ',\n  'Ԁ' => 'ԁ',\n  'Ԃ' => 'ԃ',\n  'Ԅ' => 'ԅ',\n  'Ԇ' => 'ԇ',\n  'Ԉ' => 'ԉ',\n  'Ԋ' => 'ԋ',\n  'Ԍ' => 'ԍ',\n  'Ԏ' => 'ԏ',\n  'Ԑ' => 'ԑ',\n  'Ԓ' => 'ԓ',\n  'Ԕ' => 'ԕ',\n  'Ԗ' => 'ԗ',\n  'Ԙ' => 'ԙ',\n  'Ԛ' => 'ԛ',\n  'Ԝ' => 'ԝ',\n  'Ԟ' => 'ԟ',\n  'Ԡ' => 'ԡ',\n  'Ԣ' => 'ԣ',\n  'Ԥ' => 'ԥ',\n  'Ԧ' => 'ԧ',\n  'Ԩ' => 'ԩ',\n  'Ԫ' => 'ԫ',\n  'Ԭ' => 'ԭ',\n  'Ԯ' => 'ԯ',\n  'Ա' => 'ա',\n  'Բ' => 'բ',\n  'Գ' => 'գ',\n  'Դ' => 'դ',\n  'Ե' => 'ե',\n  'Զ' => 'զ',\n  'Է' => 'է',\n  'Ը' => 'ը',\n  'Թ' => 'թ',\n  'Ժ' => 'ժ',\n  'Ի' => 'ի',\n  'Լ' => 'լ',\n  'Խ' => 'խ',\n  'Ծ' => 'ծ',\n  'Կ' => 'կ',\n  'Հ' => 'հ',\n  'Ձ' => 'ձ',\n  'Ղ' => 'ղ',\n  'Ճ' => 'ճ',\n  'Մ' => 'մ',\n  'Յ' => 'յ',\n  'Ն' => 'ն',\n  'Շ' => 'շ',\n  'Ո' => 'ո',\n  'Չ' => 'չ',\n  'Պ' => 'պ',\n  'Ջ' => 'ջ',\n  'Ռ' => 'ռ',\n  'Ս' => 'ս',\n  'Վ' => 'վ',\n  'Տ' => 'տ',\n  'Ր' => 'ր',\n  'Ց' => 'ց',\n  'Ւ' => 'ւ',\n  'Փ' => 'փ',\n  'Ք' => 'ք',\n  'Օ' => 'օ',\n  'Ֆ' => 'ֆ',\n  'Ⴀ' => 'ⴀ',\n  'Ⴁ' => 'ⴁ',\n  'Ⴂ' => 'ⴂ',\n  'Ⴃ' => 'ⴃ',\n  'Ⴄ' => 'ⴄ',\n  'Ⴅ' => 'ⴅ',\n  'Ⴆ' => 'ⴆ',\n  'Ⴇ' => 'ⴇ',\n  'Ⴈ' => 'ⴈ',\n  'Ⴉ' => 'ⴉ',\n  'Ⴊ' => 'ⴊ',\n  'Ⴋ' => 'ⴋ',\n  'Ⴌ' => 'ⴌ',\n  'Ⴍ' => 'ⴍ',\n  'Ⴎ' => 'ⴎ',\n  'Ⴏ' => 'ⴏ',\n  'Ⴐ' => 'ⴐ',\n  'Ⴑ' => 'ⴑ',\n  'Ⴒ' => 'ⴒ',\n  'Ⴓ' => 'ⴓ',\n  'Ⴔ' => 'ⴔ',\n  'Ⴕ' => 'ⴕ',\n  'Ⴖ' => 'ⴖ',\n  'Ⴗ' => 'ⴗ',\n  'Ⴘ' => 'ⴘ',\n  'Ⴙ' => 'ⴙ',\n  'Ⴚ' => 'ⴚ',\n  'Ⴛ' => 'ⴛ',\n  'Ⴜ' => 'ⴜ',\n  'Ⴝ' => 'ⴝ',\n  'Ⴞ' => 'ⴞ',\n  'Ⴟ' => 'ⴟ',\n  'Ⴠ' => 'ⴠ',\n  'Ⴡ' => 'ⴡ',\n  'Ⴢ' => 'ⴢ',\n  'Ⴣ' => 'ⴣ',\n  'Ⴤ' => 'ⴤ',\n  'Ⴥ' => 'ⴥ',\n  'Ⴧ' => 'ⴧ',\n  'Ⴭ' => 'ⴭ',\n  'Ꭰ' => 'ꭰ',\n  'Ꭱ' => 'ꭱ',\n  'Ꭲ' => 'ꭲ',\n  'Ꭳ' => 'ꭳ',\n  'Ꭴ' => 'ꭴ',\n  'Ꭵ' => 'ꭵ',\n  'Ꭶ' => 'ꭶ',\n  'Ꭷ' => 'ꭷ',\n  'Ꭸ' => 'ꭸ',\n  'Ꭹ' => 'ꭹ',\n  'Ꭺ' => 'ꭺ',\n  'Ꭻ' => 'ꭻ',\n  'Ꭼ' => 'ꭼ',\n  'Ꭽ' => 'ꭽ',\n  'Ꭾ' => 'ꭾ',\n  'Ꭿ' => 'ꭿ',\n  'Ꮀ' => 'ꮀ',\n  'Ꮁ' => 'ꮁ',\n  'Ꮂ' => 'ꮂ',\n  'Ꮃ' => 'ꮃ',\n  'Ꮄ' => 'ꮄ',\n  'Ꮅ' => 'ꮅ',\n  'Ꮆ' => 'ꮆ',\n  'Ꮇ' => 'ꮇ',\n  'Ꮈ' => 'ꮈ',\n  'Ꮉ' => 'ꮉ',\n  'Ꮊ' => 'ꮊ',\n  'Ꮋ' => 'ꮋ',\n  'Ꮌ' => 'ꮌ',\n  'Ꮍ' => 'ꮍ',\n  'Ꮎ' => 'ꮎ',\n  'Ꮏ' => 'ꮏ',\n  'Ꮐ' => 'ꮐ',\n  'Ꮑ' => 'ꮑ',\n  'Ꮒ' => 'ꮒ',\n  'Ꮓ' => 'ꮓ',\n  'Ꮔ' => 'ꮔ',\n  'Ꮕ' => 'ꮕ',\n  'Ꮖ' => 'ꮖ',\n  'Ꮗ' => 'ꮗ',\n  'Ꮘ' => 'ꮘ',\n  'Ꮙ' => 'ꮙ',\n  'Ꮚ' => 'ꮚ',\n  'Ꮛ' => 'ꮛ',\n  'Ꮜ' => 'ꮜ',\n  'Ꮝ' => 'ꮝ',\n  'Ꮞ' => 'ꮞ',\n  'Ꮟ' => 'ꮟ',\n  'Ꮠ' => 'ꮠ',\n  'Ꮡ' => 'ꮡ',\n  'Ꮢ' => 'ꮢ',\n  'Ꮣ' => 'ꮣ',\n  'Ꮤ' => 'ꮤ',\n  'Ꮥ' => 'ꮥ',\n  'Ꮦ' => 'ꮦ',\n  'Ꮧ' => 'ꮧ',\n  'Ꮨ' => 'ꮨ',\n  'Ꮩ' => 'ꮩ',\n  'Ꮪ' => 'ꮪ',\n  'Ꮫ' => 'ꮫ',\n  'Ꮬ' => 'ꮬ',\n  'Ꮭ' => 'ꮭ',\n  'Ꮮ' => 'ꮮ',\n  'Ꮯ' => 'ꮯ',\n  'Ꮰ' => 'ꮰ',\n  'Ꮱ' => 'ꮱ',\n  'Ꮲ' => 'ꮲ',\n  'Ꮳ' => 'ꮳ',\n  'Ꮴ' => 'ꮴ',\n  'Ꮵ' => 'ꮵ',\n  'Ꮶ' => 'ꮶ',\n  'Ꮷ' => 'ꮷ',\n  'Ꮸ' => 'ꮸ',\n  'Ꮹ' => 'ꮹ',\n  'Ꮺ' => 'ꮺ',\n  'Ꮻ' => 'ꮻ',\n  'Ꮼ' => 'ꮼ',\n  'Ꮽ' => 'ꮽ',\n  'Ꮾ' => 'ꮾ',\n  'Ꮿ' => 'ꮿ',\n  'Ᏸ' => 'ᏸ',\n  'Ᏹ' => 'ᏹ',\n  'Ᏺ' => 'ᏺ',\n  'Ᏻ' => 'ᏻ',\n  'Ᏼ' => 'ᏼ',\n  'Ᏽ' => 'ᏽ',\n  'Ა' => 'ა',\n  'Ბ' => 'ბ',\n  'Გ' => 'გ',\n  'Დ' => 'დ',\n  'Ე' => 'ე',\n  'Ვ' => 'ვ',\n  'Ზ' => 'ზ',\n  'Თ' => 'თ',\n  'Ი' => 'ი',\n  'Კ' => 'კ',\n  'Ლ' => 'ლ',\n  'Მ' => 'მ',\n  'Ნ' => 'ნ',\n  'Ო' => 'ო',\n  'Პ' => 'პ',\n  'Ჟ' => 'ჟ',\n  'Რ' => 'რ',\n  'Ს' => 'ს',\n  'Ტ' => 'ტ',\n  'Უ' => 'უ',\n  'Ფ' => 'ფ',\n  'Ქ' => 'ქ',\n  'Ღ' => 'ღ',\n  'Ყ' => 'ყ',\n  'Შ' => 'შ',\n  'Ჩ' => 'ჩ',\n  'Ც' => 'ც',\n  'Ძ' => 'ძ',\n  'Წ' => 'წ',\n  'Ჭ' => 'ჭ',\n  'Ხ' => 'ხ',\n  'Ჯ' => 'ჯ',\n  'Ჰ' => 'ჰ',\n  'Ჱ' => 'ჱ',\n  'Ჲ' => 'ჲ',\n  'Ჳ' => 'ჳ',\n  'Ჴ' => 'ჴ',\n  'Ჵ' => 'ჵ',\n  'Ჶ' => 'ჶ',\n  'Ჷ' => 'ჷ',\n  'Ჸ' => 'ჸ',\n  'Ჹ' => 'ჹ',\n  'Ჺ' => 'ჺ',\n  'Ჽ' => 'ჽ',\n  'Ჾ' => 'ჾ',\n  'Ჿ' => 'ჿ',\n  'Ḁ' => 'ḁ',\n  'Ḃ' => 'ḃ',\n  'Ḅ' => 'ḅ',\n  'Ḇ' => 'ḇ',\n  'Ḉ' => 'ḉ',\n  'Ḋ' => 'ḋ',\n  'Ḍ' => 'ḍ',\n  'Ḏ' => 'ḏ',\n  'Ḑ' => 'ḑ',\n  'Ḓ' => 'ḓ',\n  'Ḕ' => 'ḕ',\n  'Ḗ' => 'ḗ',\n  'Ḙ' => 'ḙ',\n  'Ḛ' => 'ḛ',\n  'Ḝ' => 'ḝ',\n  'Ḟ' => 'ḟ',\n  'Ḡ' => 'ḡ',\n  'Ḣ' => 'ḣ',\n  'Ḥ' => 'ḥ',\n  'Ḧ' => 'ḧ',\n  'Ḩ' => 'ḩ',\n  'Ḫ' => 'ḫ',\n  'Ḭ' => 'ḭ',\n  'Ḯ' => 'ḯ',\n  'Ḱ' => 'ḱ',\n  'Ḳ' => 'ḳ',\n  'Ḵ' => 'ḵ',\n  'Ḷ' => 'ḷ',\n  'Ḹ' => 'ḹ',\n  'Ḻ' => 'ḻ',\n  'Ḽ' => 'ḽ',\n  'Ḿ' => 'ḿ',\n  'Ṁ' => 'ṁ',\n  'Ṃ' => 'ṃ',\n  'Ṅ' => 'ṅ',\n  'Ṇ' => 'ṇ',\n  'Ṉ' => 'ṉ',\n  'Ṋ' => 'ṋ',\n  'Ṍ' => 'ṍ',\n  'Ṏ' => 'ṏ',\n  'Ṑ' => 'ṑ',\n  'Ṓ' => 'ṓ',\n  'Ṕ' => 'ṕ',\n  'Ṗ' => 'ṗ',\n  'Ṙ' => 'ṙ',\n  'Ṛ' => 'ṛ',\n  'Ṝ' => 'ṝ',\n  'Ṟ' => 'ṟ',\n  'Ṡ' => 'ṡ',\n  'Ṣ' => 'ṣ',\n  'Ṥ' => 'ṥ',\n  'Ṧ' => 'ṧ',\n  'Ṩ' => 'ṩ',\n  'Ṫ' => 'ṫ',\n  'Ṭ' => 'ṭ',\n  'Ṯ' => 'ṯ',\n  'Ṱ' => 'ṱ',\n  'Ṳ' => 'ṳ',\n  'Ṵ' => 'ṵ',\n  'Ṷ' => 'ṷ',\n  'Ṹ' => 'ṹ',\n  'Ṻ' => 'ṻ',\n  'Ṽ' => 'ṽ',\n  'Ṿ' => 'ṿ',\n  'Ẁ' => 'ẁ',\n  'Ẃ' => 'ẃ',\n  'Ẅ' => 'ẅ',\n  'Ẇ' => 'ẇ',\n  'Ẉ' => 'ẉ',\n  'Ẋ' => 'ẋ',\n  'Ẍ' => 'ẍ',\n  'Ẏ' => 'ẏ',\n  'Ẑ' => 'ẑ',\n  'Ẓ' => 'ẓ',\n  'Ẕ' => 'ẕ',\n  'ẞ' => 'ß',\n  'Ạ' => 'ạ',\n  'Ả' => 'ả',\n  'Ấ' => 'ấ',\n  'Ầ' => 'ầ',\n  'Ẩ' => 'ẩ',\n  'Ẫ' => 'ẫ',\n  'Ậ' => 'ậ',\n  'Ắ' => 'ắ',\n  'Ằ' => 'ằ',\n  'Ẳ' => 'ẳ',\n  'Ẵ' => 'ẵ',\n  'Ặ' => 'ặ',\n  'Ẹ' => 'ẹ',\n  'Ẻ' => 'ẻ',\n  'Ẽ' => 'ẽ',\n  'Ế' => 'ế',\n  'Ề' => 'ề',\n  'Ể' => 'ể',\n  'Ễ' => 'ễ',\n  'Ệ' => 'ệ',\n  'Ỉ' => 'ỉ',\n  'Ị' => 'ị',\n  'Ọ' => 'ọ',\n  'Ỏ' => 'ỏ',\n  'Ố' => 'ố',\n  'Ồ' => 'ồ',\n  'Ổ' => 'ổ',\n  'Ỗ' => 'ỗ',\n  'Ộ' => 'ộ',\n  'Ớ' => 'ớ',\n  'Ờ' => 'ờ',\n  'Ở' => 'ở',\n  'Ỡ' => 'ỡ',\n  'Ợ' => 'ợ',\n  'Ụ' => 'ụ',\n  'Ủ' => 'ủ',\n  'Ứ' => 'ứ',\n  'Ừ' => 'ừ',\n  'Ử' => 'ử',\n  'Ữ' => 'ữ',\n  'Ự' => 'ự',\n  'Ỳ' => 'ỳ',\n  'Ỵ' => 'ỵ',\n  'Ỷ' => 'ỷ',\n  'Ỹ' => 'ỹ',\n  'Ỻ' => 'ỻ',\n  'Ỽ' => 'ỽ',\n  'Ỿ' => 'ỿ',\n  'Ἀ' => 'ἀ',\n  'Ἁ' => 'ἁ',\n  'Ἂ' => 'ἂ',\n  'Ἃ' => 'ἃ',\n  'Ἄ' => 'ἄ',\n  'Ἅ' => 'ἅ',\n  'Ἆ' => 'ἆ',\n  'Ἇ' => 'ἇ',\n  'Ἐ' => 'ἐ',\n  'Ἑ' => 'ἑ',\n  'Ἒ' => 'ἒ',\n  'Ἓ' => 'ἓ',\n  'Ἔ' => 'ἔ',\n  'Ἕ' => 'ἕ',\n  'Ἠ' => 'ἠ',\n  'Ἡ' => 'ἡ',\n  'Ἢ' => 'ἢ',\n  'Ἣ' => 'ἣ',\n  'Ἤ' => 'ἤ',\n  'Ἥ' => 'ἥ',\n  'Ἦ' => 'ἦ',\n  'Ἧ' => 'ἧ',\n  'Ἰ' => 'ἰ',\n  'Ἱ' => 'ἱ',\n  'Ἲ' => 'ἲ',\n  'Ἳ' => 'ἳ',\n  'Ἴ' => 'ἴ',\n  'Ἵ' => 'ἵ',\n  'Ἶ' => 'ἶ',\n  'Ἷ' => 'ἷ',\n  'Ὀ' => 'ὀ',\n  'Ὁ' => 'ὁ',\n  'Ὂ' => 'ὂ',\n  'Ὃ' => 'ὃ',\n  'Ὄ' => 'ὄ',\n  'Ὅ' => 'ὅ',\n  'Ὑ' => 'ὑ',\n  'Ὓ' => 'ὓ',\n  'Ὕ' => 'ὕ',\n  'Ὗ' => 'ὗ',\n  'Ὠ' => 'ὠ',\n  'Ὡ' => 'ὡ',\n  'Ὢ' => 'ὢ',\n  'Ὣ' => 'ὣ',\n  'Ὤ' => 'ὤ',\n  'Ὥ' => 'ὥ',\n  'Ὦ' => 'ὦ',\n  'Ὧ' => 'ὧ',\n  'ᾈ' => 'ᾀ',\n  'ᾉ' => 'ᾁ',\n  'ᾊ' => 'ᾂ',\n  'ᾋ' => 'ᾃ',\n  'ᾌ' => 'ᾄ',\n  'ᾍ' => 'ᾅ',\n  'ᾎ' => 'ᾆ',\n  'ᾏ' => 'ᾇ',\n  'ᾘ' => 'ᾐ',\n  'ᾙ' => 'ᾑ',\n  'ᾚ' => 'ᾒ',\n  'ᾛ' => 'ᾓ',\n  'ᾜ' => 'ᾔ',\n  'ᾝ' => 'ᾕ',\n  'ᾞ' => 'ᾖ',\n  'ᾟ' => 'ᾗ',\n  'ᾨ' => 'ᾠ',\n  'ᾩ' => 'ᾡ',\n  'ᾪ' => 'ᾢ',\n  'ᾫ' => 'ᾣ',\n  'ᾬ' => 'ᾤ',\n  'ᾭ' => 'ᾥ',\n  'ᾮ' => 'ᾦ',\n  'ᾯ' => 'ᾧ',\n  'Ᾰ' => 'ᾰ',\n  'Ᾱ' => 'ᾱ',\n  'Ὰ' => 'ὰ',\n  'Ά' => 'ά',\n  'ᾼ' => 'ᾳ',\n  'Ὲ' => 'ὲ',\n  'Έ' => 'έ',\n  'Ὴ' => 'ὴ',\n  'Ή' => 'ή',\n  'ῌ' => 'ῃ',\n  'Ῐ' => 'ῐ',\n  'Ῑ' => 'ῑ',\n  'Ὶ' => 'ὶ',\n  'Ί' => 'ί',\n  'Ῠ' => 'ῠ',\n  'Ῡ' => 'ῡ',\n  'Ὺ' => 'ὺ',\n  'Ύ' => 'ύ',\n  'Ῥ' => 'ῥ',\n  'Ὸ' => 'ὸ',\n  'Ό' => 'ό',\n  'Ὼ' => 'ὼ',\n  'Ώ' => 'ώ',\n  'ῼ' => 'ῳ',\n  'Ω' => 'ω',\n  'K' => 'k',\n  'Å' => 'å',\n  'Ⅎ' => 'ⅎ',\n  'Ⅰ' => 'ⅰ',\n  'Ⅱ' => 'ⅱ',\n  'Ⅲ' => 'ⅲ',\n  'Ⅳ' => 'ⅳ',\n  'Ⅴ' => 'ⅴ',\n  'Ⅵ' => 'ⅵ',\n  'Ⅶ' => 'ⅶ',\n  'Ⅷ' => 'ⅷ',\n  'Ⅸ' => 'ⅸ',\n  'Ⅹ' => 'ⅹ',\n  'Ⅺ' => 'ⅺ',\n  'Ⅻ' => 'ⅻ',\n  'Ⅼ' => 'ⅼ',\n  'Ⅽ' => 'ⅽ',\n  'Ⅾ' => 'ⅾ',\n  'Ⅿ' => 'ⅿ',\n  'Ↄ' => 'ↄ',\n  'Ⓐ' => 'ⓐ',\n  'Ⓑ' => 'ⓑ',\n  'Ⓒ' => 'ⓒ',\n  'Ⓓ' => 'ⓓ',\n  'Ⓔ' => 'ⓔ',\n  'Ⓕ' => 'ⓕ',\n  'Ⓖ' => 'ⓖ',\n  'Ⓗ' => 'ⓗ',\n  'Ⓘ' => 'ⓘ',\n  'Ⓙ' => 'ⓙ',\n  'Ⓚ' => 'ⓚ',\n  'Ⓛ' => 'ⓛ',\n  'Ⓜ' => 'ⓜ',\n  'Ⓝ' => 'ⓝ',\n  'Ⓞ' => 'ⓞ',\n  'Ⓟ' => 'ⓟ',\n  'Ⓠ' => 'ⓠ',\n  'Ⓡ' => 'ⓡ',\n  'Ⓢ' => 'ⓢ',\n  'Ⓣ' => 'ⓣ',\n  'Ⓤ' => 'ⓤ',\n  'Ⓥ' => 'ⓥ',\n  'Ⓦ' => 'ⓦ',\n  'Ⓧ' => 'ⓧ',\n  'Ⓨ' => 'ⓨ',\n  'Ⓩ' => 'ⓩ',\n  'Ⰰ' => 'ⰰ',\n  'Ⰱ' => 'ⰱ',\n  'Ⰲ' => 'ⰲ',\n  'Ⰳ' => 'ⰳ',\n  'Ⰴ' => 'ⰴ',\n  'Ⰵ' => 'ⰵ',\n  'Ⰶ' => 'ⰶ',\n  'Ⰷ' => 'ⰷ',\n  'Ⰸ' => 'ⰸ',\n  'Ⰹ' => 'ⰹ',\n  'Ⰺ' => 'ⰺ',\n  'Ⰻ' => 'ⰻ',\n  'Ⰼ' => 'ⰼ',\n  'Ⰽ' => 'ⰽ',\n  'Ⰾ' => 'ⰾ',\n  'Ⰿ' => 'ⰿ',\n  'Ⱀ' => 'ⱀ',\n  'Ⱁ' => 'ⱁ',\n  'Ⱂ' => 'ⱂ',\n  'Ⱃ' => 'ⱃ',\n  'Ⱄ' => 'ⱄ',\n  'Ⱅ' => 'ⱅ',\n  'Ⱆ' => 'ⱆ',\n  'Ⱇ' => 'ⱇ',\n  'Ⱈ' => 'ⱈ',\n  'Ⱉ' => 'ⱉ',\n  'Ⱊ' => 'ⱊ',\n  'Ⱋ' => 'ⱋ',\n  'Ⱌ' => 'ⱌ',\n  'Ⱍ' => 'ⱍ',\n  'Ⱎ' => 'ⱎ',\n  'Ⱏ' => 'ⱏ',\n  'Ⱐ' => 'ⱐ',\n  'Ⱑ' => 'ⱑ',\n  'Ⱒ' => 'ⱒ',\n  'Ⱓ' => 'ⱓ',\n  'Ⱔ' => 'ⱔ',\n  'Ⱕ' => 'ⱕ',\n  'Ⱖ' => 'ⱖ',\n  'Ⱗ' => 'ⱗ',\n  'Ⱘ' => 'ⱘ',\n  'Ⱙ' => 'ⱙ',\n  'Ⱚ' => 'ⱚ',\n  'Ⱛ' => 'ⱛ',\n  'Ⱜ' => 'ⱜ',\n  'Ⱝ' => 'ⱝ',\n  'Ⱞ' => 'ⱞ',\n  'Ⱡ' => 'ⱡ',\n  'Ɫ' => 'ɫ',\n  'Ᵽ' => 'ᵽ',\n  'Ɽ' => 'ɽ',\n  'Ⱨ' => 'ⱨ',\n  'Ⱪ' => 'ⱪ',\n  'Ⱬ' => 'ⱬ',\n  'Ɑ' => 'ɑ',\n  'Ɱ' => 'ɱ',\n  'Ɐ' => 'ɐ',\n  'Ɒ' => 'ɒ',\n  'Ⱳ' => 'ⱳ',\n  'Ⱶ' => 'ⱶ',\n  'Ȿ' => 'ȿ',\n  'Ɀ' => 'ɀ',\n  'Ⲁ' => 'ⲁ',\n  'Ⲃ' => 'ⲃ',\n  'Ⲅ' => 'ⲅ',\n  'Ⲇ' => 'ⲇ',\n  'Ⲉ' => 'ⲉ',\n  'Ⲋ' => 'ⲋ',\n  'Ⲍ' => 'ⲍ',\n  'Ⲏ' => 'ⲏ',\n  'Ⲑ' => 'ⲑ',\n  'Ⲓ' => 'ⲓ',\n  'Ⲕ' => 'ⲕ',\n  'Ⲗ' => 'ⲗ',\n  'Ⲙ' => 'ⲙ',\n  'Ⲛ' => 'ⲛ',\n  'Ⲝ' => 'ⲝ',\n  'Ⲟ' => 'ⲟ',\n  'Ⲡ' => 'ⲡ',\n  'Ⲣ' => 'ⲣ',\n  'Ⲥ' => 'ⲥ',\n  'Ⲧ' => 'ⲧ',\n  'Ⲩ' => 'ⲩ',\n  'Ⲫ' => 'ⲫ',\n  'Ⲭ' => 'ⲭ',\n  'Ⲯ' => 'ⲯ',\n  'Ⲱ' => 'ⲱ',\n  'Ⲳ' => 'ⲳ',\n  'Ⲵ' => 'ⲵ',\n  'Ⲷ' => 'ⲷ',\n  'Ⲹ' => 'ⲹ',\n  'Ⲻ' => 'ⲻ',\n  'Ⲽ' => 'ⲽ',\n  'Ⲿ' => 'ⲿ',\n  'Ⳁ' => 'ⳁ',\n  'Ⳃ' => 'ⳃ',\n  'Ⳅ' => 'ⳅ',\n  'Ⳇ' => 'ⳇ',\n  'Ⳉ' => 'ⳉ',\n  'Ⳋ' => 'ⳋ',\n  'Ⳍ' => 'ⳍ',\n  'Ⳏ' => 'ⳏ',\n  'Ⳑ' => 'ⳑ',\n  'Ⳓ' => 'ⳓ',\n  'Ⳕ' => 'ⳕ',\n  'Ⳗ' => 'ⳗ',\n  'Ⳙ' => 'ⳙ',\n  'Ⳛ' => 'ⳛ',\n  'Ⳝ' => 'ⳝ',\n  'Ⳟ' => 'ⳟ',\n  'Ⳡ' => 'ⳡ',\n  'Ⳣ' => 'ⳣ',\n  'Ⳬ' => 'ⳬ',\n  'Ⳮ' => 'ⳮ',\n  'Ⳳ' => 'ⳳ',\n  'Ꙁ' => 'ꙁ',\n  'Ꙃ' => 'ꙃ',\n  'Ꙅ' => 'ꙅ',\n  'Ꙇ' => 'ꙇ',\n  'Ꙉ' => 'ꙉ',\n  'Ꙋ' => 'ꙋ',\n  'Ꙍ' => 'ꙍ',\n  'Ꙏ' => 'ꙏ',\n  'Ꙑ' => 'ꙑ',\n  'Ꙓ' => 'ꙓ',\n  'Ꙕ' => 'ꙕ',\n  'Ꙗ' => 'ꙗ',\n  'Ꙙ' => 'ꙙ',\n  'Ꙛ' => 'ꙛ',\n  'Ꙝ' => 'ꙝ',\n  'Ꙟ' => 'ꙟ',\n  'Ꙡ' => 'ꙡ',\n  'Ꙣ' => 'ꙣ',\n  'Ꙥ' => 'ꙥ',\n  'Ꙧ' => 'ꙧ',\n  'Ꙩ' => 'ꙩ',\n  'Ꙫ' => 'ꙫ',\n  'Ꙭ' => 'ꙭ',\n  'Ꚁ' => 'ꚁ',\n  'Ꚃ' => 'ꚃ',\n  'Ꚅ' => 'ꚅ',\n  'Ꚇ' => 'ꚇ',\n  'Ꚉ' => 'ꚉ',\n  'Ꚋ' => 'ꚋ',\n  'Ꚍ' => 'ꚍ',\n  'Ꚏ' => 'ꚏ',\n  'Ꚑ' => 'ꚑ',\n  'Ꚓ' => 'ꚓ',\n  'Ꚕ' => 'ꚕ',\n  'Ꚗ' => 'ꚗ',\n  'Ꚙ' => 'ꚙ',\n  'Ꚛ' => 'ꚛ',\n  'Ꜣ' => 'ꜣ',\n  'Ꜥ' => 'ꜥ',\n  'Ꜧ' => 'ꜧ',\n  'Ꜩ' => 'ꜩ',\n  'Ꜫ' => 'ꜫ',\n  'Ꜭ' => 'ꜭ',\n  'Ꜯ' => 'ꜯ',\n  'Ꜳ' => 'ꜳ',\n  'Ꜵ' => 'ꜵ',\n  'Ꜷ' => 'ꜷ',\n  'Ꜹ' => 'ꜹ',\n  'Ꜻ' => 'ꜻ',\n  'Ꜽ' => 'ꜽ',\n  'Ꜿ' => 'ꜿ',\n  'Ꝁ' => 'ꝁ',\n  'Ꝃ' => 'ꝃ',\n  'Ꝅ' => 'ꝅ',\n  'Ꝇ' => 'ꝇ',\n  'Ꝉ' => 'ꝉ',\n  'Ꝋ' => 'ꝋ',\n  'Ꝍ' => 'ꝍ',\n  'Ꝏ' => 'ꝏ',\n  'Ꝑ' => 'ꝑ',\n  'Ꝓ' => 'ꝓ',\n  'Ꝕ' => 'ꝕ',\n  'Ꝗ' => 'ꝗ',\n  'Ꝙ' => 'ꝙ',\n  'Ꝛ' => 'ꝛ',\n  'Ꝝ' => 'ꝝ',\n  'Ꝟ' => 'ꝟ',\n  'Ꝡ' => 'ꝡ',\n  'Ꝣ' => 'ꝣ',\n  'Ꝥ' => 'ꝥ',\n  'Ꝧ' => 'ꝧ',\n  'Ꝩ' => 'ꝩ',\n  'Ꝫ' => 'ꝫ',\n  'Ꝭ' => 'ꝭ',\n  'Ꝯ' => 'ꝯ',\n  'Ꝺ' => 'ꝺ',\n  'Ꝼ' => 'ꝼ',\n  'Ᵹ' => 'ᵹ',\n  'Ꝿ' => 'ꝿ',\n  'Ꞁ' => 'ꞁ',\n  'Ꞃ' => 'ꞃ',\n  'Ꞅ' => 'ꞅ',\n  'Ꞇ' => 'ꞇ',\n  'Ꞌ' => 'ꞌ',\n  'Ɥ' => 'ɥ',\n  'Ꞑ' => 'ꞑ',\n  'Ꞓ' => 'ꞓ',\n  'Ꞗ' => 'ꞗ',\n  'Ꞙ' => 'ꞙ',\n  'Ꞛ' => 'ꞛ',\n  'Ꞝ' => 'ꞝ',\n  'Ꞟ' => 'ꞟ',\n  'Ꞡ' => 'ꞡ',\n  'Ꞣ' => 'ꞣ',\n  'Ꞥ' => 'ꞥ',\n  'Ꞧ' => 'ꞧ',\n  'Ꞩ' => 'ꞩ',\n  'Ɦ' => 'ɦ',\n  'Ɜ' => 'ɜ',\n  'Ɡ' => 'ɡ',\n  'Ɬ' => 'ɬ',\n  'Ɪ' => 'ɪ',\n  'Ʞ' => 'ʞ',\n  'Ʇ' => 'ʇ',\n  'Ʝ' => 'ʝ',\n  'Ꭓ' => 'ꭓ',\n  'Ꞵ' => 'ꞵ',\n  'Ꞷ' => 'ꞷ',\n  'Ꞹ' => 'ꞹ',\n  'Ꞻ' => 'ꞻ',\n  'Ꞽ' => 'ꞽ',\n  'Ꞿ' => 'ꞿ',\n  'Ꟃ' => 'ꟃ',\n  'Ꞔ' => 'ꞔ',\n  'Ʂ' => 'ʂ',\n  'Ᶎ' => 'ᶎ',\n  'Ꟈ' => 'ꟈ',\n  'Ꟊ' => 'ꟊ',\n  'Ꟶ' => 'ꟶ',\n  'Ａ' => 'ａ',\n  'Ｂ' => 'ｂ',\n  'Ｃ' => 'ｃ',\n  'Ｄ' => 'ｄ',\n  'Ｅ' => 'ｅ',\n  'Ｆ' => 'ｆ',\n  'Ｇ' => 'ｇ',\n  'Ｈ' => 'ｈ',\n  'Ｉ' => 'ｉ',\n  'Ｊ' => 'ｊ',\n  'Ｋ' => 'ｋ',\n  'Ｌ' => 'ｌ',\n  'Ｍ' => 'ｍ',\n  'Ｎ' => 'ｎ',\n  'Ｏ' => 'ｏ',\n  'Ｐ' => 'ｐ',\n  'Ｑ' => 'ｑ',\n  'Ｒ' => 'ｒ',\n  'Ｓ' => 'ｓ',\n  'Ｔ' => 'ｔ',\n  'Ｕ' => 'ｕ',\n  'Ｖ' => 'ｖ',\n  'Ｗ' => 'ｗ',\n  'Ｘ' => 'ｘ',\n  'Ｙ' => 'ｙ',\n  'Ｚ' => 'ｚ',\n  '𐐀' => '𐐨',\n  '𐐁' => '𐐩',\n  '𐐂' => '𐐪',\n  '𐐃' => '𐐫',\n  '𐐄' => '𐐬',\n  '𐐅' => '𐐭',\n  '𐐆' => '𐐮',\n  '𐐇' => '𐐯',\n  '𐐈' => '𐐰',\n  '𐐉' => '𐐱',\n  '𐐊' => '𐐲',\n  '𐐋' => '𐐳',\n  '𐐌' => '𐐴',\n  '𐐍' => '𐐵',\n  '𐐎' => '𐐶',\n  '𐐏' => '𐐷',\n  '𐐐' => '𐐸',\n  '𐐑' => '𐐹',\n  '𐐒' => '𐐺',\n  '𐐓' => '𐐻',\n  '𐐔' => '𐐼',\n  '𐐕' => '𐐽',\n  '𐐖' => '𐐾',\n  '𐐗' => '𐐿',\n  '𐐘' => '𐑀',\n  '𐐙' => '𐑁',\n  '𐐚' => '𐑂',\n  '𐐛' => '𐑃',\n  '𐐜' => '𐑄',\n  '𐐝' => '𐑅',\n  '𐐞' => '𐑆',\n  '𐐟' => '𐑇',\n  '𐐠' => '𐑈',\n  '𐐡' => '𐑉',\n  '𐐢' => '𐑊',\n  '𐐣' => '𐑋',\n  '𐐤' => '𐑌',\n  '𐐥' => '𐑍',\n  '𐐦' => '𐑎',\n  '𐐧' => '𐑏',\n  '𐒰' => '𐓘',\n  '𐒱' => '𐓙',\n  '𐒲' => '𐓚',\n  '𐒳' => '𐓛',\n  '𐒴' => '𐓜',\n  '𐒵' => '𐓝',\n  '𐒶' => '𐓞',\n  '𐒷' => '𐓟',\n  '𐒸' => '𐓠',\n  '𐒹' => '𐓡',\n  '𐒺' => '𐓢',\n  '𐒻' => '𐓣',\n  '𐒼' => '𐓤',\n  '𐒽' => '𐓥',\n  '𐒾' => '𐓦',\n  '𐒿' => '𐓧',\n  '𐓀' => '𐓨',\n  '𐓁' => '𐓩',\n  '𐓂' => '𐓪',\n  '𐓃' => '𐓫',\n  '𐓄' => '𐓬',\n  '𐓅' => '𐓭',\n  '𐓆' => '𐓮',\n  '𐓇' => '𐓯',\n  '𐓈' => '𐓰',\n  '𐓉' => '𐓱',\n  '𐓊' => '𐓲',\n  '𐓋' => '𐓳',\n  '𐓌' => '𐓴',\n  '𐓍' => '𐓵',\n  '𐓎' => '𐓶',\n  '𐓏' => '𐓷',\n  '𐓐' => '𐓸',\n  '𐓑' => '𐓹',\n  '𐓒' => '𐓺',\n  '𐓓' => '𐓻',\n  '𐲀' => '𐳀',\n  '𐲁' => '𐳁',\n  '𐲂' => '𐳂',\n  '𐲃' => '𐳃',\n  '𐲄' => '𐳄',\n  '𐲅' => '𐳅',\n  '𐲆' => '𐳆',\n  '𐲇' => '𐳇',\n  '𐲈' => '𐳈',\n  '𐲉' => '𐳉',\n  '𐲊' => '𐳊',\n  '𐲋' => '𐳋',\n  '𐲌' => '𐳌',\n  '𐲍' => '𐳍',\n  '𐲎' => '𐳎',\n  '𐲏' => '𐳏',\n  '𐲐' => '𐳐',\n  '𐲑' => '𐳑',\n  '𐲒' => '𐳒',\n  '𐲓' => '𐳓',\n  '𐲔' => '𐳔',\n  '𐲕' => '𐳕',\n  '𐲖' => '𐳖',\n  '𐲗' => '𐳗',\n  '𐲘' => '𐳘',\n  '𐲙' => '𐳙',\n  '𐲚' => '𐳚',\n  '𐲛' => '𐳛',\n  '𐲜' => '𐳜',\n  '𐲝' => '𐳝',\n  '𐲞' => '𐳞',\n  '𐲟' => '𐳟',\n  '𐲠' => '𐳠',\n  '𐲡' => '𐳡',\n  '𐲢' => '𐳢',\n  '𐲣' => '𐳣',\n  '𐲤' => '𐳤',\n  '𐲥' => '𐳥',\n  '𐲦' => '𐳦',\n  '𐲧' => '𐳧',\n  '𐲨' => '𐳨',\n  '𐲩' => '𐳩',\n  '𐲪' => '𐳪',\n  '𐲫' => '𐳫',\n  '𐲬' => '𐳬',\n  '𐲭' => '𐳭',\n  '𐲮' => '𐳮',\n  '𐲯' => '𐳯',\n  '𐲰' => '𐳰',\n  '𐲱' => '𐳱',\n  '𐲲' => '𐳲',\n  '𑢠' => '𑣀',\n  '𑢡' => '𑣁',\n  '𑢢' => '𑣂',\n  '𑢣' => '𑣃',\n  '𑢤' => '𑣄',\n  '𑢥' => '𑣅',\n  '𑢦' => '𑣆',\n  '𑢧' => '𑣇',\n  '𑢨' => '𑣈',\n  '𑢩' => '𑣉',\n  '𑢪' => '𑣊',\n  '𑢫' => '𑣋',\n  '𑢬' => '𑣌',\n  '𑢭' => '𑣍',\n  '𑢮' => '𑣎',\n  '𑢯' => '𑣏',\n  '𑢰' => '𑣐',\n  '𑢱' => '𑣑',\n  '𑢲' => '𑣒',\n  '𑢳' => '𑣓',\n  '𑢴' => '𑣔',\n  '𑢵' => '𑣕',\n  '𑢶' => '𑣖',\n  '𑢷' => '𑣗',\n  '𑢸' => '𑣘',\n  '𑢹' => '𑣙',\n  '𑢺' => '𑣚',\n  '𑢻' => '𑣛',\n  '𑢼' => '𑣜',\n  '𑢽' => '𑣝',\n  '𑢾' => '𑣞',\n  '𑢿' => '𑣟',\n  '𖹀' => '𖹠',\n  '𖹁' => '𖹡',\n  '𖹂' => '𖹢',\n  '𖹃' => '𖹣',\n  '𖹄' => '𖹤',\n  '𖹅' => '𖹥',\n  '𖹆' => '𖹦',\n  '𖹇' => '𖹧',\n  '𖹈' => '𖹨',\n  '𖹉' => '𖹩',\n  '𖹊' => '𖹪',\n  '𖹋' => '𖹫',\n  '𖹌' => '𖹬',\n  '𖹍' => '𖹭',\n  '𖹎' => '𖹮',\n  '𖹏' => '𖹯',\n  '𖹐' => '𖹰',\n  '𖹑' => '𖹱',\n  '𖹒' => '𖹲',\n  '𖹓' => '𖹳',\n  '𖹔' => '𖹴',\n  '𖹕' => '𖹵',\n  '𖹖' => '𖹶',\n  '𖹗' => '𖹷',\n  '𖹘' => '𖹸',\n  '𖹙' => '𖹹',\n  '𖹚' => '𖹺',\n  '𖹛' => '𖹻',\n  '𖹜' => '𖹼',\n  '𖹝' => '𖹽',\n  '𖹞' => '𖹾',\n  '𖹟' => '𖹿',\n  '𞤀' => '𞤢',\n  '𞤁' => '𞤣',\n  '𞤂' => '𞤤',\n  '𞤃' => '𞤥',\n  '𞤄' => '𞤦',\n  '𞤅' => '𞤧',\n  '𞤆' => '𞤨',\n  '𞤇' => '𞤩',\n  '𞤈' => '𞤪',\n  '𞤉' => '𞤫',\n  '𞤊' => '𞤬',\n  '𞤋' => '𞤭',\n  '𞤌' => '𞤮',\n  '𞤍' => '𞤯',\n  '𞤎' => '𞤰',\n  '𞤏' => '𞤱',\n  '𞤐' => '𞤲',\n  '𞤑' => '𞤳',\n  '𞤒' => '𞤴',\n  '𞤓' => '𞤵',\n  '𞤔' => '𞤶',\n  '𞤕' => '𞤷',\n  '𞤖' => '𞤸',\n  '𞤗' => '𞤹',\n  '𞤘' => '𞤺',\n  '𞤙' => '𞤻',\n  '𞤚' => '𞤼',\n  '𞤛' => '𞤽',\n  '𞤜' => '𞤾',\n  '𞤝' => '𞤿',\n  '𞤞' => '𞥀',\n  '𞤟' => '𞥁',\n  '𞤠' => '𞥂',\n  '𞤡' => '𞥃',\n);\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/polyfill-mbstring/Resources/unidata/titleCaseRegexp.php',
    "<?php\n\n// from Case_Ignorable in https://unicode.org/Public/UNIDATA/DerivedCoreProperties.txt\n\nreturn '/(?<![\\x{0027}\\x{002E}\\x{003A}\\x{005E}\\x{0060}\\x{00A8}\\x{00AD}\\x{00AF}\\x{00B4}\\x{00B7}\\x{00B8}\\x{02B0}-\\x{02C1}\\x{02C2}-\\x{02C5}\\x{02C6}-\\x{02D1}\\x{02D2}-\\x{02DF}\\x{02E0}-\\x{02E4}\\x{02E5}-\\x{02EB}\\x{02EC}\\x{02ED}\\x{02EE}\\x{02EF}-\\x{02FF}\\x{0300}-\\x{036F}\\x{0374}\\x{0375}\\x{037A}\\x{0384}-\\x{0385}\\x{0387}\\x{0483}-\\x{0487}\\x{0488}-\\x{0489}\\x{0559}\\x{0591}-\\x{05BD}\\x{05BF}\\x{05C1}-\\x{05C2}\\x{05C4}-\\x{05C5}\\x{05C7}\\x{05F4}\\x{0600}-\\x{0605}\\x{0610}-\\x{061A}\\x{061C}\\x{0640}\\x{064B}-\\x{065F}\\x{0670}\\x{06D6}-\\x{06DC}\\x{06DD}\\x{06DF}-\\x{06E4}\\x{06E5}-\\x{06E6}\\x{06E7}-\\x{06E8}\\x{06EA}-\\x{06ED}\\x{070F}\\x{0711}\\x{0730}-\\x{074A}\\x{07A6}-\\x{07B0}\\x{07EB}-\\x{07F3}\\x{07F4}-\\x{07F5}\\x{07FA}\\x{07FD}\\x{0816}-\\x{0819}\\x{081A}\\x{081B}-\\x{0823}\\x{0824}\\x{0825}-\\x{0827}\\x{0828}\\x{0829}-\\x{082D}\\x{0859}-\\x{085B}\\x{08D3}-\\x{08E1}\\x{08E2}\\x{08E3}-\\x{0902}\\x{093A}\\x{093C}\\x{0941}-\\x{0948}\\x{094D}\\x{0951}-\\x{0957}\\x{0962}-\\x{0963}\\x{0971}\\x{0981}\\x{09BC}\\x{09C1}-\\x{09C4}\\x{09CD}\\x{09E2}-\\x{09E3}\\x{09FE}\\x{0A01}-\\x{0A02}\\x{0A3C}\\x{0A41}-\\x{0A42}\\x{0A47}-\\x{0A48}\\x{0A4B}-\\x{0A4D}\\x{0A51}\\x{0A70}-\\x{0A71}\\x{0A75}\\x{0A81}-\\x{0A82}\\x{0ABC}\\x{0AC1}-\\x{0AC5}\\x{0AC7}-\\x{0AC8}\\x{0ACD}\\x{0AE2}-\\x{0AE3}\\x{0AFA}-\\x{0AFF}\\x{0B01}\\x{0B3C}\\x{0B3F}\\x{0B41}-\\x{0B44}\\x{0B4D}\\x{0B56}\\x{0B62}-\\x{0B63}\\x{0B82}\\x{0BC0}\\x{0BCD}\\x{0C00}\\x{0C04}\\x{0C3E}-\\x{0C40}\\x{0C46}-\\x{0C48}\\x{0C4A}-\\x{0C4D}\\x{0C55}-\\x{0C56}\\x{0C62}-\\x{0C63}\\x{0C81}\\x{0CBC}\\x{0CBF}\\x{0CC6}\\x{0CCC}-\\x{0CCD}\\x{0CE2}-\\x{0CE3}\\x{0D00}-\\x{0D01}\\x{0D3B}-\\x{0D3C}\\x{0D41}-\\x{0D44}\\x{0D4D}\\x{0D62}-\\x{0D63}\\x{0DCA}\\x{0DD2}-\\x{0DD4}\\x{0DD6}\\x{0E31}\\x{0E34}-\\x{0E3A}\\x{0E46}\\x{0E47}-\\x{0E4E}\\x{0EB1}\\x{0EB4}-\\x{0EB9}\\x{0EBB}-\\x{0EBC}\\x{0EC6}\\x{0EC8}-\\x{0ECD}\\x{0F18}-\\x{0F19}\\x{0F35}\\x{0F37}\\x{0F39}\\x{0F71}-\\x{0F7E}\\x{0F80}-\\x{0F84}\\x{0F86}-\\x{0F87}\\x{0F8D}-\\x{0F97}\\x{0F99}-\\x{0FBC}\\x{0FC6}\\x{102D}-\\x{1030}\\x{1032}-\\x{1037}\\x{1039}-\\x{103A}\\x{103D}-\\x{103E}\\x{1058}-\\x{1059}\\x{105E}-\\x{1060}\\x{1071}-\\x{1074}\\x{1082}\\x{1085}-\\x{1086}\\x{108D}\\x{109D}\\x{10FC}\\x{135D}-\\x{135F}\\x{1712}-\\x{1714}\\x{1732}-\\x{1734}\\x{1752}-\\x{1753}\\x{1772}-\\x{1773}\\x{17B4}-\\x{17B5}\\x{17B7}-\\x{17BD}\\x{17C6}\\x{17C9}-\\x{17D3}\\x{17D7}\\x{17DD}\\x{180B}-\\x{180D}\\x{180E}\\x{1843}\\x{1885}-\\x{1886}\\x{18A9}\\x{1920}-\\x{1922}\\x{1927}-\\x{1928}\\x{1932}\\x{1939}-\\x{193B}\\x{1A17}-\\x{1A18}\\x{1A1B}\\x{1A56}\\x{1A58}-\\x{1A5E}\\x{1A60}\\x{1A62}\\x{1A65}-\\x{1A6C}\\x{1A73}-\\x{1A7C}\\x{1A7F}\\x{1AA7}\\x{1AB0}-\\x{1ABD}\\x{1ABE}\\x{1B00}-\\x{1B03}\\x{1B34}\\x{1B36}-\\x{1B3A}\\x{1B3C}\\x{1B42}\\x{1B6B}-\\x{1B73}\\x{1B80}-\\x{1B81}\\x{1BA2}-\\x{1BA5}\\x{1BA8}-\\x{1BA9}\\x{1BAB}-\\x{1BAD}\\x{1BE6}\\x{1BE8}-\\x{1BE9}\\x{1BED}\\x{1BEF}-\\x{1BF1}\\x{1C2C}-\\x{1C33}\\x{1C36}-\\x{1C37}\\x{1C78}-\\x{1C7D}\\x{1CD0}-\\x{1CD2}\\x{1CD4}-\\x{1CE0}\\x{1CE2}-\\x{1CE8}\\x{1CED}\\x{1CF4}\\x{1CF8}-\\x{1CF9}\\x{1D2C}-\\x{1D6A}\\x{1D78}\\x{1D9B}-\\x{1DBF}\\x{1DC0}-\\x{1DF9}\\x{1DFB}-\\x{1DFF}\\x{1FBD}\\x{1FBF}-\\x{1FC1}\\x{1FCD}-\\x{1FCF}\\x{1FDD}-\\x{1FDF}\\x{1FED}-\\x{1FEF}\\x{1FFD}-\\x{1FFE}\\x{200B}-\\x{200F}\\x{2018}\\x{2019}\\x{2024}\\x{2027}\\x{202A}-\\x{202E}\\x{2060}-\\x{2064}\\x{2066}-\\x{206F}\\x{2071}\\x{207F}\\x{2090}-\\x{209C}\\x{20D0}-\\x{20DC}\\x{20DD}-\\x{20E0}\\x{20E1}\\x{20E2}-\\x{20E4}\\x{20E5}-\\x{20F0}\\x{2C7C}-\\x{2C7D}\\x{2CEF}-\\x{2CF1}\\x{2D6F}\\x{2D7F}\\x{2DE0}-\\x{2DFF}\\x{2E2F}\\x{3005}\\x{302A}-\\x{302D}\\x{3031}-\\x{3035}\\x{303B}\\x{3099}-\\x{309A}\\x{309B}-\\x{309C}\\x{309D}-\\x{309E}\\x{30FC}-\\x{30FE}\\x{A015}\\x{A4F8}-\\x{A4FD}\\x{A60C}\\x{A66F}\\x{A670}-\\x{A672}\\x{A674}-\\x{A67D}\\x{A67F}\\x{A69C}-\\x{A69D}\\x{A69E}-\\x{A69F}\\x{A6F0}-\\x{A6F1}\\x{A700}-\\x{A716}\\x{A717}-\\x{A71F}\\x{A720}-\\x{A721}\\x{A770}\\x{A788}\\x{A789}-\\x{A78A}\\x{A7F8}-\\x{A7F9}\\x{A802}\\x{A806}\\x{A80B}\\x{A825}-\\x{A826}\\x{A8C4}-\\x{A8C5}\\x{A8E0}-\\x{A8F1}\\x{A8FF}\\x{A926}-\\x{A92D}\\x{A947}-\\x{A951}\\x{A980}-\\x{A982}\\x{A9B3}\\x{A9B6}-\\x{A9B9}\\x{A9BC}\\x{A9CF}\\x{A9E5}\\x{A9E6}\\x{AA29}-\\x{AA2E}\\x{AA31}-\\x{AA32}\\x{AA35}-\\x{AA36}\\x{AA43}\\x{AA4C}\\x{AA70}\\x{AA7C}\\x{AAB0}\\x{AAB2}-\\x{AAB4}\\x{AAB7}-\\x{AAB8}\\x{AABE}-\\x{AABF}\\x{AAC1}\\x{AADD}\\x{AAEC}-\\x{AAED}\\x{AAF3}-\\x{AAF4}\\x{AAF6}\\x{AB5B}\\x{AB5C}-\\x{AB5F}\\x{ABE5}\\x{ABE8}\\x{ABED}\\x{FB1E}\\x{FBB2}-\\x{FBC1}\\x{FE00}-\\x{FE0F}\\x{FE13}\\x{FE20}-\\x{FE2F}\\x{FE52}\\x{FE55}\\x{FEFF}\\x{FF07}\\x{FF0E}\\x{FF1A}\\x{FF3E}\\x{FF40}\\x{FF70}\\x{FF9E}-\\x{FF9F}\\x{FFE3}\\x{FFF9}-\\x{FFFB}\\x{101FD}\\x{102E0}\\x{10376}-\\x{1037A}\\x{10A01}-\\x{10A03}\\x{10A05}-\\x{10A06}\\x{10A0C}-\\x{10A0F}\\x{10A38}-\\x{10A3A}\\x{10A3F}\\x{10AE5}-\\x{10AE6}\\x{10D24}-\\x{10D27}\\x{10F46}-\\x{10F50}\\x{11001}\\x{11038}-\\x{11046}\\x{1107F}-\\x{11081}\\x{110B3}-\\x{110B6}\\x{110B9}-\\x{110BA}\\x{110BD}\\x{110CD}\\x{11100}-\\x{11102}\\x{11127}-\\x{1112B}\\x{1112D}-\\x{11134}\\x{11173}\\x{11180}-\\x{11181}\\x{111B6}-\\x{111BE}\\x{111C9}-\\x{111CC}\\x{1122F}-\\x{11231}\\x{11234}\\x{11236}-\\x{11237}\\x{1123E}\\x{112DF}\\x{112E3}-\\x{112EA}\\x{11300}-\\x{11301}\\x{1133B}-\\x{1133C}\\x{11340}\\x{11366}-\\x{1136C}\\x{11370}-\\x{11374}\\x{11438}-\\x{1143F}\\x{11442}-\\x{11444}\\x{11446}\\x{1145E}\\x{114B3}-\\x{114B8}\\x{114BA}\\x{114BF}-\\x{114C0}\\x{114C2}-\\x{114C3}\\x{115B2}-\\x{115B5}\\x{115BC}-\\x{115BD}\\x{115BF}-\\x{115C0}\\x{115DC}-\\x{115DD}\\x{11633}-\\x{1163A}\\x{1163D}\\x{1163F}-\\x{11640}\\x{116AB}\\x{116AD}\\x{116B0}-\\x{116B5}\\x{116B7}\\x{1171D}-\\x{1171F}\\x{11722}-\\x{11725}\\x{11727}-\\x{1172B}\\x{1182F}-\\x{11837}\\x{11839}-\\x{1183A}\\x{11A01}-\\x{11A0A}\\x{11A33}-\\x{11A38}\\x{11A3B}-\\x{11A3E}\\x{11A47}\\x{11A51}-\\x{11A56}\\x{11A59}-\\x{11A5B}\\x{11A8A}-\\x{11A96}\\x{11A98}-\\x{11A99}\\x{11C30}-\\x{11C36}\\x{11C38}-\\x{11C3D}\\x{11C3F}\\x{11C92}-\\x{11CA7}\\x{11CAA}-\\x{11CB0}\\x{11CB2}-\\x{11CB3}\\x{11CB5}-\\x{11CB6}\\x{11D31}-\\x{11D36}\\x{11D3A}\\x{11D3C}-\\x{11D3D}\\x{11D3F}-\\x{11D45}\\x{11D47}\\x{11D90}-\\x{11D91}\\x{11D95}\\x{11D97}\\x{11EF3}-\\x{11EF4}\\x{16AF0}-\\x{16AF4}\\x{16B30}-\\x{16B36}\\x{16B40}-\\x{16B43}\\x{16F8F}-\\x{16F92}\\x{16F93}-\\x{16F9F}\\x{16FE0}-\\x{16FE1}\\x{1BC9D}-\\x{1BC9E}\\x{1BCA0}-\\x{1BCA3}\\x{1D167}-\\x{1D169}\\x{1D173}-\\x{1D17A}\\x{1D17B}-\\x{1D182}\\x{1D185}-\\x{1D18B}\\x{1D1AA}-\\x{1D1AD}\\x{1D242}-\\x{1D244}\\x{1DA00}-\\x{1DA36}\\x{1DA3B}-\\x{1DA6C}\\x{1DA75}\\x{1DA84}\\x{1DA9B}-\\x{1DA9F}\\x{1DAA1}-\\x{1DAAF}\\x{1E000}-\\x{1E006}\\x{1E008}-\\x{1E018}\\x{1E01B}-\\x{1E021}\\x{1E023}-\\x{1E024}\\x{1E026}-\\x{1E02A}\\x{1E8D0}-\\x{1E8D6}\\x{1E944}-\\x{1E94A}\\x{1F3FB}-\\x{1F3FF}\\x{E0001}\\x{E0020}-\\x{E007F}\\x{E0100}-\\x{E01EF}])(\\pL)(\\pL*+)/u';\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/polyfill-mbstring/Resources/unidata/upperCase.php',
    "<?php\n\nreturn array (\n  'a' => 'A',\n  'b' => 'B',\n  'c' => 'C',\n  'd' => 'D',\n  'e' => 'E',\n  'f' => 'F',\n  'g' => 'G',\n  'h' => 'H',\n  'i' => 'I',\n  'j' => 'J',\n  'k' => 'K',\n  'l' => 'L',\n  'm' => 'M',\n  'n' => 'N',\n  'o' => 'O',\n  'p' => 'P',\n  'q' => 'Q',\n  'r' => 'R',\n  's' => 'S',\n  't' => 'T',\n  'u' => 'U',\n  'v' => 'V',\n  'w' => 'W',\n  'x' => 'X',\n  'y' => 'Y',\n  'z' => 'Z',\n  'µ' => 'Μ',\n  'à' => 'À',\n  'á' => 'Á',\n  'â' => 'Â',\n  'ã' => 'Ã',\n  'ä' => 'Ä',\n  'å' => 'Å',\n  'æ' => 'Æ',\n  'ç' => 'Ç',\n  'è' => 'È',\n  'é' => 'É',\n  'ê' => 'Ê',\n  'ë' => 'Ë',\n  'ì' => 'Ì',\n  'í' => 'Í',\n  'î' => 'Î',\n  'ï' => 'Ï',\n  'ð' => 'Ð',\n  'ñ' => 'Ñ',\n  'ò' => 'Ò',\n  'ó' => 'Ó',\n  'ô' => 'Ô',\n  'õ' => 'Õ',\n  'ö' => 'Ö',\n  'ø' => 'Ø',\n  'ù' => 'Ù',\n  'ú' => 'Ú',\n  'û' => 'Û',\n  'ü' => 'Ü',\n  'ý' => 'Ý',\n  'þ' => 'Þ',\n  'ÿ' => 'Ÿ',\n  'ā' => 'Ā',\n  'ă' => 'Ă',\n  'ą' => 'Ą',\n  'ć' => 'Ć',\n  'ĉ' => 'Ĉ',\n  'ċ' => 'Ċ',\n  'č' => 'Č',\n  'ď' => 'Ď',\n  'đ' => 'Đ',\n  'ē' => 'Ē',\n  'ĕ' => 'Ĕ',\n  'ė' => 'Ė',\n  'ę' => 'Ę',\n  'ě' => 'Ě',\n  'ĝ' => 'Ĝ',\n  'ğ' => 'Ğ',\n  'ġ' => 'Ġ',\n  'ģ' => 'Ģ',\n  'ĥ' => 'Ĥ',\n  'ħ' => 'Ħ',\n  'ĩ' => 'Ĩ',\n  'ī' => 'Ī',\n  'ĭ' => 'Ĭ',\n  'į' => 'Į',\n  'ı' => 'I',\n  'ĳ' => 'Ĳ',\n  'ĵ' => 'Ĵ',\n  'ķ' => 'Ķ',\n  'ĺ' => 'Ĺ',\n  'ļ' => 'Ļ',\n  'ľ' => 'Ľ',\n  'ŀ' => 'Ŀ',\n  'ł' => 'Ł',\n  'ń' => 'Ń',\n  'ņ' => 'Ņ',\n  'ň' => 'Ň',\n  'ŋ' => 'Ŋ',\n  'ō' => 'Ō',\n  'ŏ' => 'Ŏ',\n  'ő' => 'Ő',\n  'œ' => 'Œ',\n  'ŕ' => 'Ŕ',\n  'ŗ' => 'Ŗ',\n  'ř' => 'Ř',\n  'ś' => 'Ś',\n  'ŝ' => 'Ŝ',\n  'ş' => 'Ş',\n  'š' => 'Š',\n  'ţ' => 'Ţ',\n  'ť' => 'Ť',\n  'ŧ' => 'Ŧ',\n  'ũ' => 'Ũ',\n  'ū' => 'Ū',\n  'ŭ' => 'Ŭ',\n  'ů' => 'Ů',\n  'ű' => 'Ű',\n  'ų' => 'Ų',\n  'ŵ' => 'Ŵ',\n  'ŷ' => 'Ŷ',\n  'ź' => 'Ź',\n  'ż' => 'Ż',\n  'ž' => 'Ž',\n  'ſ' => 'S',\n  'ƀ' => 'Ƀ',\n  'ƃ' => 'Ƃ',\n  'ƅ' => 'Ƅ',\n  'ƈ' => 'Ƈ',\n  'ƌ' => 'Ƌ',\n  'ƒ' => 'Ƒ',\n  'ƕ' => 'Ƕ',\n  'ƙ' => 'Ƙ',\n  'ƚ' => 'Ƚ',\n  'ƞ' => 'Ƞ',\n  'ơ' => 'Ơ',\n  'ƣ' => 'Ƣ',\n  'ƥ' => 'Ƥ',\n  'ƨ' => 'Ƨ',\n  'ƭ' => 'Ƭ',\n  'ư' => 'Ư',\n  'ƴ' => 'Ƴ',\n  'ƶ' => 'Ƶ',\n  'ƹ' => 'Ƹ',\n  'ƽ' => 'Ƽ',\n  'ƿ' => 'Ƿ',\n  'ǅ' => 'Ǆ',\n  'ǆ' => 'Ǆ',\n  'ǈ' => 'Ǉ',\n  'ǉ' => 'Ǉ',\n  'ǋ' => 'Ǌ',\n  'ǌ' => 'Ǌ',\n  'ǎ' => 'Ǎ',\n  'ǐ' => 'Ǐ',\n  'ǒ' => 'Ǒ',\n  'ǔ' => 'Ǔ',\n  'ǖ' => 'Ǖ',\n  'ǘ' => 'Ǘ',\n  'ǚ' => 'Ǚ',\n  'ǜ' => 'Ǜ',\n  'ǝ' => 'Ǝ',\n  'ǟ' => 'Ǟ',\n  'ǡ' => 'Ǡ',\n  'ǣ' => 'Ǣ',\n  'ǥ' => 'Ǥ',\n  'ǧ' => 'Ǧ',\n  'ǩ' => 'Ǩ',\n  'ǫ' => 'Ǫ',\n  'ǭ' => 'Ǭ',\n  'ǯ' => 'Ǯ',\n  'ǲ' => 'Ǳ',\n  'ǳ' => 'Ǳ',\n  'ǵ' => 'Ǵ',\n  'ǹ' => 'Ǹ',\n  'ǻ' => 'Ǻ',\n  'ǽ' => 'Ǽ',\n  'ǿ' => 'Ǿ',\n  'ȁ' => 'Ȁ',\n  'ȃ' => 'Ȃ',\n  'ȅ' => 'Ȅ',\n  'ȇ' => 'Ȇ',\n  'ȉ' => 'Ȉ',\n  'ȋ' => 'Ȋ',\n  'ȍ' => 'Ȍ',\n  'ȏ' => 'Ȏ',\n  'ȑ' => 'Ȑ',\n  'ȓ' => 'Ȓ',\n  'ȕ' => 'Ȕ',\n  'ȗ' => 'Ȗ',\n  'ș' => 'Ș',\n  'ț' => 'Ț',\n  'ȝ' => 'Ȝ',\n  'ȟ' => 'Ȟ',\n  'ȣ' => 'Ȣ',\n  'ȥ' => 'Ȥ',\n  'ȧ' => 'Ȧ',\n  'ȩ' => 'Ȩ',\n  'ȫ' => 'Ȫ',\n  'ȭ' => 'Ȭ',\n  'ȯ' => 'Ȯ',\n  'ȱ' => 'Ȱ',\n  'ȳ' => 'Ȳ',\n  'ȼ' => 'Ȼ',\n  'ȿ' => 'Ȿ',\n  'ɀ' => 'Ɀ',\n  'ɂ' => 'Ɂ',\n  'ɇ' => 'Ɇ',\n  'ɉ' => 'Ɉ',\n  'ɋ' => 'Ɋ',\n  'ɍ' => 'Ɍ',\n  'ɏ' => 'Ɏ',\n  'ɐ' => 'Ɐ',\n  'ɑ' => 'Ɑ',\n  'ɒ' => 'Ɒ',\n  'ɓ' => 'Ɓ',\n  'ɔ' => 'Ɔ',\n  'ɖ' => 'Ɖ',\n  'ɗ' => 'Ɗ',\n  'ə' => 'Ə',\n  'ɛ' => 'Ɛ',\n  'ɜ' => 'Ɜ',\n  'ɠ' => 'Ɠ',\n  'ɡ' => 'Ɡ',\n  'ɣ' => 'Ɣ',\n  'ɥ' => 'Ɥ',\n  'ɦ' => 'Ɦ',\n  'ɨ' => 'Ɨ',\n  'ɩ' => 'Ɩ',\n  'ɪ' => 'Ɪ',\n  'ɫ' => 'Ɫ',\n  'ɬ' => 'Ɬ',\n  'ɯ' => 'Ɯ',\n  'ɱ' => 'Ɱ',\n  'ɲ' => 'Ɲ',\n  'ɵ' => 'Ɵ',\n  'ɽ' => 'Ɽ',\n  'ʀ' => 'Ʀ',\n  'ʂ' => 'Ʂ',\n  'ʃ' => 'Ʃ',\n  'ʇ' => 'Ʇ',\n  'ʈ' => 'Ʈ',\n  'ʉ' => 'Ʉ',\n  'ʊ' => 'Ʊ',\n  'ʋ' => 'Ʋ',\n  'ʌ' => 'Ʌ',\n  'ʒ' => 'Ʒ',\n  'ʝ' => 'Ʝ',\n  'ʞ' => 'Ʞ',\n  'ͅ' => 'Ι',\n  'ͱ' => 'Ͱ',\n  'ͳ' => 'Ͳ',\n  'ͷ' => 'Ͷ',\n  'ͻ' => 'Ͻ',\n  'ͼ' => 'Ͼ',\n  'ͽ' => 'Ͽ',\n  'ά' => 'Ά',\n  'έ' => 'Έ',\n  'ή' => 'Ή',\n  'ί' => 'Ί',\n  'α' => 'Α',\n  'β' => 'Β',\n  'γ' => 'Γ',\n  'δ' => 'Δ',\n  'ε' => 'Ε',\n  'ζ' => 'Ζ',\n  'η' => 'Η',\n  'θ' => 'Θ',\n  'ι' => 'Ι',\n  'κ' => 'Κ',\n  'λ' => 'Λ',\n  'μ' => 'Μ',\n  'ν' => 'Ν',\n  'ξ' => 'Ξ',\n  'ο' => 'Ο',\n  'π' => 'Π',\n  'ρ' => 'Ρ',\n  'ς' => 'Σ',\n  'σ' => 'Σ',\n  'τ' => 'Τ',\n  'υ' => 'Υ',\n  'φ' => 'Φ',\n  'χ' => 'Χ',\n  'ψ' => 'Ψ',\n  'ω' => 'Ω',\n  'ϊ' => 'Ϊ',\n  'ϋ' => 'Ϋ',\n  'ό' => 'Ό',\n  'ύ' => 'Ύ',\n  'ώ' => 'Ώ',\n  'ϐ' => 'Β',\n  'ϑ' => 'Θ',\n  'ϕ' => 'Φ',\n  'ϖ' => 'Π',\n  'ϗ' => 'Ϗ',\n  'ϙ' => 'Ϙ',\n  'ϛ' => 'Ϛ',\n  'ϝ' => 'Ϝ',\n  'ϟ' => 'Ϟ',\n  'ϡ' => 'Ϡ',\n  'ϣ' => 'Ϣ',\n  'ϥ' => 'Ϥ',\n  'ϧ' => 'Ϧ',\n  'ϩ' => 'Ϩ',\n  'ϫ' => 'Ϫ',\n  'ϭ' => 'Ϭ',\n  'ϯ' => 'Ϯ',\n  'ϰ' => 'Κ',\n  'ϱ' => 'Ρ',\n  'ϲ' => 'Ϲ',\n  'ϳ' => 'Ϳ',\n  'ϵ' => 'Ε',\n  'ϸ' => 'Ϸ',\n  'ϻ' => 'Ϻ',\n  'а' => 'А',\n  'б' => 'Б',\n  'в' => 'В',\n  'г' => 'Г',\n  'д' => 'Д',\n  'е' => 'Е',\n  'ж' => 'Ж',\n  'з' => 'З',\n  'и' => 'И',\n  'й' => 'Й',\n  'к' => 'К',\n  'л' => 'Л',\n  'м' => 'М',\n  'н' => 'Н',\n  'о' => 'О',\n  'п' => 'П',\n  'р' => 'Р',\n  'с' => 'С',\n  'т' => 'Т',\n  'у' => 'У',\n  'ф' => 'Ф',\n  'х' => 'Х',\n  'ц' => 'Ц',\n  'ч' => 'Ч',\n  'ш' => 'Ш',\n  'щ' => 'Щ',\n  'ъ' => 'Ъ',\n  'ы' => 'Ы',\n  'ь' => 'Ь',\n  'э' => 'Э',\n  'ю' => 'Ю',\n  'я' => 'Я',\n  'ѐ' => 'Ѐ',\n  'ё' => 'Ё',\n  'ђ' => 'Ђ',\n  'ѓ' => 'Ѓ',\n  'є' => 'Є',\n  'ѕ' => 'Ѕ',\n  'і' => 'І',\n  'ї' => 'Ї',\n  'ј' => 'Ј',\n  'љ' => 'Љ',\n  'њ' => 'Њ',\n  'ћ' => 'Ћ',\n  'ќ' => 'Ќ',\n  'ѝ' => 'Ѝ',\n  'ў' => 'Ў',\n  'џ' => 'Џ',\n  'ѡ' => 'Ѡ',\n  'ѣ' => 'Ѣ',\n  'ѥ' => 'Ѥ',\n  'ѧ' => 'Ѧ',\n  'ѩ' => 'Ѩ',\n  'ѫ' => 'Ѫ',\n  'ѭ' => 'Ѭ',\n  'ѯ' => 'Ѯ',\n  'ѱ' => 'Ѱ',\n  'ѳ' => 'Ѳ',\n  'ѵ' => 'Ѵ',\n  'ѷ' => 'Ѷ',\n  'ѹ' => 'Ѹ',\n  'ѻ' => 'Ѻ',\n  'ѽ' => 'Ѽ',\n  'ѿ' => 'Ѿ',\n  'ҁ' => 'Ҁ',\n  'ҋ' => 'Ҋ',\n  'ҍ' => 'Ҍ',\n  'ҏ' => 'Ҏ',\n  'ґ' => 'Ґ',\n  'ғ' => 'Ғ',\n  'ҕ' => 'Ҕ',\n  'җ' => 'Җ',\n  'ҙ' => 'Ҙ',\n  'қ' => 'Қ',\n  'ҝ' => 'Ҝ',\n  'ҟ' => 'Ҟ',\n  'ҡ' => 'Ҡ',\n  'ң' => 'Ң',\n  'ҥ' => 'Ҥ',\n  'ҧ' => 'Ҧ',\n  'ҩ' => 'Ҩ',\n  'ҫ' => 'Ҫ',\n  'ҭ' => 'Ҭ',\n  'ү' => 'Ү',\n  'ұ' => 'Ұ',\n  'ҳ' => 'Ҳ',\n  'ҵ' => 'Ҵ',\n  'ҷ' => 'Ҷ',\n  'ҹ' => 'Ҹ',\n  'һ' => 'Һ',\n  'ҽ' => 'Ҽ',\n  'ҿ' => 'Ҿ',\n  'ӂ' => 'Ӂ',\n  'ӄ' => 'Ӄ',\n  'ӆ' => 'Ӆ',\n  'ӈ' => 'Ӈ',\n  'ӊ' => 'Ӊ',\n  'ӌ' => 'Ӌ',\n  'ӎ' => 'Ӎ',\n  'ӏ' => 'Ӏ',\n  'ӑ' => 'Ӑ',\n  'ӓ' => 'Ӓ',\n  'ӕ' => 'Ӕ',\n  'ӗ' => 'Ӗ',\n  'ә' => 'Ә',\n  'ӛ' => 'Ӛ',\n  'ӝ' => 'Ӝ',\n  'ӟ' => 'Ӟ',\n  'ӡ' => 'Ӡ',\n  'ӣ' => 'Ӣ',\n  'ӥ' => 'Ӥ',\n  'ӧ' => 'Ӧ',\n  'ө' => 'Ө',\n  'ӫ' => 'Ӫ',\n  'ӭ' => 'Ӭ',\n  'ӯ' => 'Ӯ',\n  'ӱ' => 'Ӱ',\n  'ӳ' => 'Ӳ',\n  'ӵ' => 'Ӵ',\n  'ӷ' => 'Ӷ',\n  'ӹ' => 'Ӹ',\n  'ӻ' => 'Ӻ',\n  'ӽ' => 'Ӽ',\n  'ӿ' => 'Ӿ',\n  'ԁ' => 'Ԁ',\n  'ԃ' => 'Ԃ',\n  'ԅ' => 'Ԅ',\n  'ԇ' => 'Ԇ',\n  'ԉ' => 'Ԉ',\n  'ԋ' => 'Ԋ',\n  'ԍ' => 'Ԍ',\n  'ԏ' => 'Ԏ',\n  'ԑ' => 'Ԑ',\n  'ԓ' => 'Ԓ',\n  'ԕ' => 'Ԕ',\n  'ԗ' => 'Ԗ',\n  'ԙ' => 'Ԙ',\n  'ԛ' => 'Ԛ',\n  'ԝ' => 'Ԝ',\n  'ԟ' => 'Ԟ',\n  'ԡ' => 'Ԡ',\n  'ԣ' => 'Ԣ',\n  'ԥ' => 'Ԥ',\n  'ԧ' => 'Ԧ',\n  'ԩ' => 'Ԩ',\n  'ԫ' => 'Ԫ',\n  'ԭ' => 'Ԭ',\n  'ԯ' => 'Ԯ',\n  'ա' => 'Ա',\n  'բ' => 'Բ',\n  'գ' => 'Գ',\n  'դ' => 'Դ',\n  'ե' => 'Ե',\n  'զ' => 'Զ',\n  'է' => 'Է',\n  'ը' => 'Ը',\n  'թ' => 'Թ',\n  'ժ' => 'Ժ',\n  'ի' => 'Ի',\n  'լ' => 'Լ',\n  'խ' => 'Խ',\n  'ծ' => 'Ծ',\n  'կ' => 'Կ',\n  'հ' => 'Հ',\n  'ձ' => 'Ձ',\n  'ղ' => 'Ղ',\n  'ճ' => 'Ճ',\n  'մ' => 'Մ',\n  'յ' => 'Յ',\n  'ն' => 'Ն',\n  'շ' => 'Շ',\n  'ո' => 'Ո',\n  'չ' => 'Չ',\n  'պ' => 'Պ',\n  'ջ' => 'Ջ',\n  'ռ' => 'Ռ',\n  'ս' => 'Ս',\n  'վ' => 'Վ',\n  'տ' => 'Տ',\n  'ր' => 'Ր',\n  'ց' => 'Ց',\n  'ւ' => 'Ւ',\n  'փ' => 'Փ',\n  'ք' => 'Ք',\n  'օ' => 'Օ',\n  'ֆ' => 'Ֆ',\n  'ა' => 'Ა',\n  'ბ' => 'Ბ',\n  'გ' => 'Გ',\n  'დ' => 'Დ',\n  'ე' => 'Ე',\n  'ვ' => 'Ვ',\n  'ზ' => 'Ზ',\n  'თ' => 'Თ',\n  'ი' => 'Ი',\n  'კ' => 'Კ',\n  'ლ' => 'Ლ',\n  'მ' => 'Მ',\n  'ნ' => 'Ნ',\n  'ო' => 'Ო',\n  'პ' => 'Პ',\n  'ჟ' => 'Ჟ',\n  'რ' => 'Რ',\n  'ს' => 'Ს',\n  'ტ' => 'Ტ',\n  'უ' => 'Უ',\n  'ფ' => 'Ფ',\n  'ქ' => 'Ქ',\n  'ღ' => 'Ღ',\n  'ყ' => 'Ყ',\n  'შ' => 'Შ',\n  'ჩ' => 'Ჩ',\n  'ც' => 'Ც',\n  'ძ' => 'Ძ',\n  'წ' => 'Წ',\n  'ჭ' => 'Ჭ',\n  'ხ' => 'Ხ',\n  'ჯ' => 'Ჯ',\n  'ჰ' => 'Ჰ',\n  'ჱ' => 'Ჱ',\n  'ჲ' => 'Ჲ',\n  'ჳ' => 'Ჳ',\n  'ჴ' => 'Ჴ',\n  'ჵ' => 'Ჵ',\n  'ჶ' => 'Ჶ',\n  'ჷ' => 'Ჷ',\n  'ჸ' => 'Ჸ',\n  'ჹ' => 'Ჹ',\n  'ჺ' => 'Ჺ',\n  'ჽ' => 'Ჽ',\n  'ჾ' => 'Ჾ',\n  'ჿ' => 'Ჿ',\n  'ᏸ' => 'Ᏸ',\n  'ᏹ' => 'Ᏹ',\n  'ᏺ' => 'Ᏺ',\n  'ᏻ' => 'Ᏻ',\n  'ᏼ' => 'Ᏼ',\n  'ᏽ' => 'Ᏽ',\n  'ᲀ' => 'В',\n  'ᲁ' => 'Д',\n  'ᲂ' => 'О',\n  'ᲃ' => 'С',\n  'ᲄ' => 'Т',\n  'ᲅ' => 'Т',\n  'ᲆ' => 'Ъ',\n  'ᲇ' => 'Ѣ',\n  'ᲈ' => 'Ꙋ',\n  'ᵹ' => 'Ᵹ',\n  'ᵽ' => 'Ᵽ',\n  'ᶎ' => 'Ᶎ',\n  'ḁ' => 'Ḁ',\n  'ḃ' => 'Ḃ',\n  'ḅ' => 'Ḅ',\n  'ḇ' => 'Ḇ',\n  'ḉ' => 'Ḉ',\n  'ḋ' => 'Ḋ',\n  'ḍ' => 'Ḍ',\n  'ḏ' => 'Ḏ',\n  'ḑ' => 'Ḑ',\n  'ḓ' => 'Ḓ',\n  'ḕ' => 'Ḕ',\n  'ḗ' => 'Ḗ',\n  'ḙ' => 'Ḙ',\n  'ḛ' => 'Ḛ',\n  'ḝ' => 'Ḝ',\n  'ḟ' => 'Ḟ',\n  'ḡ' => 'Ḡ',\n  'ḣ' => 'Ḣ',\n  'ḥ' => 'Ḥ',\n  'ḧ' => 'Ḧ',\n  'ḩ' => 'Ḩ',\n  'ḫ' => 'Ḫ',\n  'ḭ' => 'Ḭ',\n  'ḯ' => 'Ḯ',\n  'ḱ' => 'Ḱ',\n  'ḳ' => 'Ḳ',\n  'ḵ' => 'Ḵ',\n  'ḷ' => 'Ḷ',\n  'ḹ' => 'Ḹ',\n  'ḻ' => 'Ḻ',\n  'ḽ' => 'Ḽ',\n  'ḿ' => 'Ḿ',\n  'ṁ' => 'Ṁ',\n  'ṃ' => 'Ṃ',\n  'ṅ' => 'Ṅ',\n  'ṇ' => 'Ṇ',\n  'ṉ' => 'Ṉ',\n  'ṋ' => 'Ṋ',\n  'ṍ' => 'Ṍ',\n  'ṏ' => 'Ṏ',\n  'ṑ' => 'Ṑ',\n  'ṓ' => 'Ṓ',\n  'ṕ' => 'Ṕ',\n  'ṗ' => 'Ṗ',\n  'ṙ' => 'Ṙ',\n  'ṛ' => 'Ṛ',\n  'ṝ' => 'Ṝ',\n  'ṟ' => 'Ṟ',\n  'ṡ' => 'Ṡ',\n  'ṣ' => 'Ṣ',\n  'ṥ' => 'Ṥ',\n  'ṧ' => 'Ṧ',\n  'ṩ' => 'Ṩ',\n  'ṫ' => 'Ṫ',\n  'ṭ' => 'Ṭ',\n  'ṯ' => 'Ṯ',\n  'ṱ' => 'Ṱ',\n  'ṳ' => 'Ṳ',\n  'ṵ' => 'Ṵ',\n  'ṷ' => 'Ṷ',\n  'ṹ' => 'Ṹ',\n  'ṻ' => 'Ṻ',\n  'ṽ' => 'Ṽ',\n  'ṿ' => 'Ṿ',\n  'ẁ' => 'Ẁ',\n  'ẃ' => 'Ẃ',\n  'ẅ' => 'Ẅ',\n  'ẇ' => 'Ẇ',\n  'ẉ' => 'Ẉ',\n  'ẋ' => 'Ẋ',\n  'ẍ' => 'Ẍ',\n  'ẏ' => 'Ẏ',\n  'ẑ' => 'Ẑ',\n  'ẓ' => 'Ẓ',\n  'ẕ' => 'Ẕ',\n  'ẛ' => 'Ṡ',\n  'ạ' => 'Ạ',\n  'ả' => 'Ả',\n  'ấ' => 'Ấ',\n  'ầ' => 'Ầ',\n  'ẩ' => 'Ẩ',\n  'ẫ' => 'Ẫ',\n  'ậ' => 'Ậ',\n  'ắ' => 'Ắ',\n  'ằ' => 'Ằ',\n  'ẳ' => 'Ẳ',\n  'ẵ' => 'Ẵ',\n  'ặ' => 'Ặ',\n  'ẹ' => 'Ẹ',\n  'ẻ' => 'Ẻ',\n  'ẽ' => 'Ẽ',\n  'ế' => 'Ế',\n  'ề' => 'Ề',\n  'ể' => 'Ể',\n  'ễ' => 'Ễ',\n  'ệ' => 'Ệ',\n  'ỉ' => 'Ỉ',\n  'ị' => 'Ị',\n  'ọ' => 'Ọ',\n  'ỏ' => 'Ỏ',\n  'ố' => 'Ố',\n  'ồ' => 'Ồ',\n  'ổ' => 'Ổ',\n  'ỗ' => 'Ỗ',\n  'ộ' => 'Ộ',\n  'ớ' => 'Ớ',\n  'ờ' => 'Ờ',\n  'ở' => 'Ở',\n  'ỡ' => 'Ỡ',\n  'ợ' => 'Ợ',\n  'ụ' => 'Ụ',\n  'ủ' => 'Ủ',\n  'ứ' => 'Ứ',\n  'ừ' => 'Ừ',\n  'ử' => 'Ử',\n  'ữ' => 'Ữ',\n  'ự' => 'Ự',\n  'ỳ' => 'Ỳ',\n  'ỵ' => 'Ỵ',\n  'ỷ' => 'Ỷ',\n  'ỹ' => 'Ỹ',\n  'ỻ' => 'Ỻ',\n  'ỽ' => 'Ỽ',\n  'ỿ' => 'Ỿ',\n  'ἀ' => 'Ἀ',\n  'ἁ' => 'Ἁ',\n  'ἂ' => 'Ἂ',\n  'ἃ' => 'Ἃ',\n  'ἄ' => 'Ἄ',\n  'ἅ' => 'Ἅ',\n  'ἆ' => 'Ἆ',\n  'ἇ' => 'Ἇ',\n  'ἐ' => 'Ἐ',\n  'ἑ' => 'Ἑ',\n  'ἒ' => 'Ἒ',\n  'ἓ' => 'Ἓ',\n  'ἔ' => 'Ἔ',\n  'ἕ' => 'Ἕ',\n  'ἠ' => 'Ἠ',\n  'ἡ' => 'Ἡ',\n  'ἢ' => 'Ἢ',\n  'ἣ' => 'Ἣ',\n  'ἤ' => 'Ἤ',\n  'ἥ' => 'Ἥ',\n  'ἦ' => 'Ἦ',\n  'ἧ' => 'Ἧ',\n  'ἰ' => 'Ἰ',\n  'ἱ' => 'Ἱ',\n  'ἲ' => 'Ἲ',\n  'ἳ' => 'Ἳ',\n  'ἴ' => 'Ἴ',\n  'ἵ' => 'Ἵ',\n  'ἶ' => 'Ἶ',\n  'ἷ' => 'Ἷ',\n  'ὀ' => 'Ὀ',\n  'ὁ' => 'Ὁ',\n  'ὂ' => 'Ὂ',\n  'ὃ' => 'Ὃ',\n  'ὄ' => 'Ὄ',\n  'ὅ' => 'Ὅ',\n  'ὑ' => 'Ὑ',\n  'ὓ' => 'Ὓ',\n  'ὕ' => 'Ὕ',\n  'ὗ' => 'Ὗ',\n  'ὠ' => 'Ὠ',\n  'ὡ' => 'Ὡ',\n  'ὢ' => 'Ὢ',\n  'ὣ' => 'Ὣ',\n  'ὤ' => 'Ὤ',\n  'ὥ' => 'Ὥ',\n  'ὦ' => 'Ὦ',\n  'ὧ' => 'Ὧ',\n  'ὰ' => 'Ὰ',\n  'ά' => 'Ά',\n  'ὲ' => 'Ὲ',\n  'έ' => 'Έ',\n  'ὴ' => 'Ὴ',\n  'ή' => 'Ή',\n  'ὶ' => 'Ὶ',\n  'ί' => 'Ί',\n  'ὸ' => 'Ὸ',\n  'ό' => 'Ό',\n  'ὺ' => 'Ὺ',\n  'ύ' => 'Ύ',\n  'ὼ' => 'Ὼ',\n  'ώ' => 'Ώ',\n  'ᾀ' => 'ἈΙ',\n  'ᾁ' => 'ἉΙ',\n  'ᾂ' => 'ἊΙ',\n  'ᾃ' => 'ἋΙ',\n  'ᾄ' => 'ἌΙ',\n  'ᾅ' => 'ἍΙ',\n  'ᾆ' => 'ἎΙ',\n  'ᾇ' => 'ἏΙ',\n  'ᾐ' => 'ἨΙ',\n  'ᾑ' => 'ἩΙ',\n  'ᾒ' => 'ἪΙ',\n  'ᾓ' => 'ἫΙ',\n  'ᾔ' => 'ἬΙ',\n  'ᾕ' => 'ἭΙ',\n  'ᾖ' => 'ἮΙ',\n  'ᾗ' => 'ἯΙ',\n  'ᾠ' => 'ὨΙ',\n  'ᾡ' => 'ὩΙ',\n  'ᾢ' => 'ὪΙ',\n  'ᾣ' => 'ὫΙ',\n  'ᾤ' => 'ὬΙ',\n  'ᾥ' => 'ὭΙ',\n  'ᾦ' => 'ὮΙ',\n  'ᾧ' => 'ὯΙ',\n  'ᾰ' => 'Ᾰ',\n  'ᾱ' => 'Ᾱ',\n  'ᾳ' => 'ΑΙ',\n  'ι' => 'Ι',\n  'ῃ' => 'ΗΙ',\n  'ῐ' => 'Ῐ',\n  'ῑ' => 'Ῑ',\n  'ῠ' => 'Ῠ',\n  'ῡ' => 'Ῡ',\n  'ῥ' => 'Ῥ',\n  'ῳ' => 'ΩΙ',\n  'ⅎ' => 'Ⅎ',\n  'ⅰ' => 'Ⅰ',\n  'ⅱ' => 'Ⅱ',\n  'ⅲ' => 'Ⅲ',\n  'ⅳ' => 'Ⅳ',\n  'ⅴ' => 'Ⅴ',\n  'ⅵ' => 'Ⅵ',\n  'ⅶ' => 'Ⅶ',\n  'ⅷ' => 'Ⅷ',\n  'ⅸ' => 'Ⅸ',\n  'ⅹ' => 'Ⅹ',\n  'ⅺ' => 'Ⅺ',\n  'ⅻ' => 'Ⅻ',\n  'ⅼ' => 'Ⅼ',\n  'ⅽ' => 'Ⅽ',\n  'ⅾ' => 'Ⅾ',\n  'ⅿ' => 'Ⅿ',\n  'ↄ' => 'Ↄ',\n  'ⓐ' => 'Ⓐ',\n  'ⓑ' => 'Ⓑ',\n  'ⓒ' => 'Ⓒ',\n  'ⓓ' => 'Ⓓ',\n  'ⓔ' => 'Ⓔ',\n  'ⓕ' => 'Ⓕ',\n  'ⓖ' => 'Ⓖ',\n  'ⓗ' => 'Ⓗ',\n  'ⓘ' => 'Ⓘ',\n  'ⓙ' => 'Ⓙ',\n  'ⓚ' => 'Ⓚ',\n  'ⓛ' => 'Ⓛ',\n  'ⓜ' => 'Ⓜ',\n  'ⓝ' => 'Ⓝ',\n  'ⓞ' => 'Ⓞ',\n  'ⓟ' => 'Ⓟ',\n  'ⓠ' => 'Ⓠ',\n  'ⓡ' => 'Ⓡ',\n  'ⓢ' => 'Ⓢ',\n  'ⓣ' => 'Ⓣ',\n  'ⓤ' => 'Ⓤ',\n  'ⓥ' => 'Ⓥ',\n  'ⓦ' => 'Ⓦ',\n  'ⓧ' => 'Ⓧ',\n  'ⓨ' => 'Ⓨ',\n  'ⓩ' => 'Ⓩ',\n  'ⰰ' => 'Ⰰ',\n  'ⰱ' => 'Ⰱ',\n  'ⰲ' => 'Ⰲ',\n  'ⰳ' => 'Ⰳ',\n  'ⰴ' => 'Ⰴ',\n  'ⰵ' => 'Ⰵ',\n  'ⰶ' => 'Ⰶ',\n  'ⰷ' => 'Ⰷ',\n  'ⰸ' => 'Ⰸ',\n  'ⰹ' => 'Ⰹ',\n  'ⰺ' => 'Ⰺ',\n  'ⰻ' => 'Ⰻ',\n  'ⰼ' => 'Ⰼ',\n  'ⰽ' => 'Ⰽ',\n  'ⰾ' => 'Ⰾ',\n  'ⰿ' => 'Ⰿ',\n  'ⱀ' => 'Ⱀ',\n  'ⱁ' => 'Ⱁ',\n  'ⱂ' => 'Ⱂ',\n  'ⱃ' => 'Ⱃ',\n  'ⱄ' => 'Ⱄ',\n  'ⱅ' => 'Ⱅ',\n  'ⱆ' => 'Ⱆ',\n  'ⱇ' => 'Ⱇ',\n  'ⱈ' => 'Ⱈ',\n  'ⱉ' => 'Ⱉ',\n  'ⱊ' => 'Ⱊ',\n  'ⱋ' => 'Ⱋ',\n  'ⱌ' => 'Ⱌ',\n  'ⱍ' => 'Ⱍ',\n  'ⱎ' => 'Ⱎ',\n  'ⱏ' => 'Ⱏ',\n  'ⱐ' => 'Ⱐ',\n  'ⱑ' => 'Ⱑ',\n  'ⱒ' => 'Ⱒ',\n  'ⱓ' => 'Ⱓ',\n  'ⱔ' => 'Ⱔ',\n  'ⱕ' => 'Ⱕ',\n  'ⱖ' => 'Ⱖ',\n  'ⱗ' => 'Ⱗ',\n  'ⱘ' => 'Ⱘ',\n  'ⱙ' => 'Ⱙ',\n  'ⱚ' => 'Ⱚ',\n  'ⱛ' => 'Ⱛ',\n  'ⱜ' => 'Ⱜ',\n  'ⱝ' => 'Ⱝ',\n  'ⱞ' => 'Ⱞ',\n  'ⱡ' => 'Ⱡ',\n  'ⱥ' => 'Ⱥ',\n  'ⱦ' => 'Ⱦ',\n  'ⱨ' => 'Ⱨ',\n  'ⱪ' => 'Ⱪ',\n  'ⱬ' => 'Ⱬ',\n  'ⱳ' => 'Ⱳ',\n  'ⱶ' => 'Ⱶ',\n  'ⲁ' => 'Ⲁ',\n  'ⲃ' => 'Ⲃ',\n  'ⲅ' => 'Ⲅ',\n  'ⲇ' => 'Ⲇ',\n  'ⲉ' => 'Ⲉ',\n  'ⲋ' => 'Ⲋ',\n  'ⲍ' => 'Ⲍ',\n  'ⲏ' => 'Ⲏ',\n  'ⲑ' => 'Ⲑ',\n  'ⲓ' => 'Ⲓ',\n  'ⲕ' => 'Ⲕ',\n  'ⲗ' => 'Ⲗ',\n  'ⲙ' => 'Ⲙ',\n  'ⲛ' => 'Ⲛ',\n  'ⲝ' => 'Ⲝ',\n  'ⲟ' => 'Ⲟ',\n  'ⲡ' => 'Ⲡ',\n  'ⲣ' => 'Ⲣ',\n  'ⲥ' => 'Ⲥ',\n  'ⲧ' => 'Ⲧ',\n  'ⲩ' => 'Ⲩ',\n  'ⲫ' => 'Ⲫ',\n  'ⲭ' => 'Ⲭ',\n  'ⲯ' => 'Ⲯ',\n  'ⲱ' => 'Ⲱ',\n  'ⲳ' => 'Ⲳ',\n  'ⲵ' => 'Ⲵ',\n  'ⲷ' => 'Ⲷ',\n  'ⲹ' => 'Ⲹ',\n  'ⲻ' => 'Ⲻ',\n  'ⲽ' => 'Ⲽ',\n  'ⲿ' => 'Ⲿ',\n  'ⳁ' => 'Ⳁ',\n  'ⳃ' => 'Ⳃ',\n  'ⳅ' => 'Ⳅ',\n  'ⳇ' => 'Ⳇ',\n  'ⳉ' => 'Ⳉ',\n  'ⳋ' => 'Ⳋ',\n  'ⳍ' => 'Ⳍ',\n  'ⳏ' => 'Ⳏ',\n  'ⳑ' => 'Ⳑ',\n  'ⳓ' => 'Ⳓ',\n  'ⳕ' => 'Ⳕ',\n  'ⳗ' => 'Ⳗ',\n  'ⳙ' => 'Ⳙ',\n  'ⳛ' => 'Ⳛ',\n  'ⳝ' => 'Ⳝ',\n  'ⳟ' => 'Ⳟ',\n  'ⳡ' => 'Ⳡ',\n  'ⳣ' => 'Ⳣ',\n  'ⳬ' => 'Ⳬ',\n  'ⳮ' => 'Ⳮ',\n  'ⳳ' => 'Ⳳ',\n  'ⴀ' => 'Ⴀ',\n  'ⴁ' => 'Ⴁ',\n  'ⴂ' => 'Ⴂ',\n  'ⴃ' => 'Ⴃ',\n  'ⴄ' => 'Ⴄ',\n  'ⴅ' => 'Ⴅ',\n  'ⴆ' => 'Ⴆ',\n  'ⴇ' => 'Ⴇ',\n  'ⴈ' => 'Ⴈ',\n  'ⴉ' => 'Ⴉ',\n  'ⴊ' => 'Ⴊ',\n  'ⴋ' => 'Ⴋ',\n  'ⴌ' => 'Ⴌ',\n  'ⴍ' => 'Ⴍ',\n  'ⴎ' => 'Ⴎ',\n  'ⴏ' => 'Ⴏ',\n  'ⴐ' => 'Ⴐ',\n  'ⴑ' => 'Ⴑ',\n  'ⴒ' => 'Ⴒ',\n  'ⴓ' => 'Ⴓ',\n  'ⴔ' => 'Ⴔ',\n  'ⴕ' => 'Ⴕ',\n  'ⴖ' => 'Ⴖ',\n  'ⴗ' => 'Ⴗ',\n  'ⴘ' => 'Ⴘ',\n  'ⴙ' => 'Ⴙ',\n  'ⴚ' => 'Ⴚ',\n  'ⴛ' => 'Ⴛ',\n  'ⴜ' => 'Ⴜ',\n  'ⴝ' => 'Ⴝ',\n  'ⴞ' => 'Ⴞ',\n  'ⴟ' => 'Ⴟ',\n  'ⴠ' => 'Ⴠ',\n  'ⴡ' => 'Ⴡ',\n  'ⴢ' => 'Ⴢ',\n  'ⴣ' => 'Ⴣ',\n  'ⴤ' => 'Ⴤ',\n  'ⴥ' => 'Ⴥ',\n  'ⴧ' => 'Ⴧ',\n  'ⴭ' => 'Ⴭ',\n  'ꙁ' => 'Ꙁ',\n  'ꙃ' => 'Ꙃ',\n  'ꙅ' => 'Ꙅ',\n  'ꙇ' => 'Ꙇ',\n  'ꙉ' => 'Ꙉ',\n  'ꙋ' => 'Ꙋ',\n  'ꙍ' => 'Ꙍ',\n  'ꙏ' => 'Ꙏ',\n  'ꙑ' => 'Ꙑ',\n  'ꙓ' => 'Ꙓ',\n  'ꙕ' => 'Ꙕ',\n  'ꙗ' => 'Ꙗ',\n  'ꙙ' => 'Ꙙ',\n  'ꙛ' => 'Ꙛ',\n  'ꙝ' => 'Ꙝ',\n  'ꙟ' => 'Ꙟ',\n  'ꙡ' => 'Ꙡ',\n  'ꙣ' => 'Ꙣ',\n  'ꙥ' => 'Ꙥ',\n  'ꙧ' => 'Ꙧ',\n  'ꙩ' => 'Ꙩ',\n  'ꙫ' => 'Ꙫ',\n  'ꙭ' => 'Ꙭ',\n  'ꚁ' => 'Ꚁ',\n  'ꚃ' => 'Ꚃ',\n  'ꚅ' => 'Ꚅ',\n  'ꚇ' => 'Ꚇ',\n  'ꚉ' => 'Ꚉ',\n  'ꚋ' => 'Ꚋ',\n  'ꚍ' => 'Ꚍ',\n  'ꚏ' => 'Ꚏ',\n  'ꚑ' => 'Ꚑ',\n  'ꚓ' => 'Ꚓ',\n  'ꚕ' => 'Ꚕ',\n  'ꚗ' => 'Ꚗ',\n  'ꚙ' => 'Ꚙ',\n  'ꚛ' => 'Ꚛ',\n  'ꜣ' => 'Ꜣ',\n  'ꜥ' => 'Ꜥ',\n  'ꜧ' => 'Ꜧ',\n  'ꜩ' => 'Ꜩ',\n  'ꜫ' => 'Ꜫ',\n  'ꜭ' => 'Ꜭ',\n  'ꜯ' => 'Ꜯ',\n  'ꜳ' => 'Ꜳ',\n  'ꜵ' => 'Ꜵ',\n  'ꜷ' => 'Ꜷ',\n  'ꜹ' => 'Ꜹ',\n  'ꜻ' => 'Ꜻ',\n  'ꜽ' => 'Ꜽ',\n  'ꜿ' => 'Ꜿ',\n  'ꝁ' => 'Ꝁ',\n  'ꝃ' => 'Ꝃ',\n  'ꝅ' => 'Ꝅ',\n  'ꝇ' => 'Ꝇ',\n  'ꝉ' => 'Ꝉ',\n  'ꝋ' => 'Ꝋ',\n  'ꝍ' => 'Ꝍ',\n  'ꝏ' => 'Ꝏ',\n  'ꝑ' => 'Ꝑ',\n  'ꝓ' => 'Ꝓ',\n  'ꝕ' => 'Ꝕ',\n  'ꝗ' => 'Ꝗ',\n  'ꝙ' => 'Ꝙ',\n  'ꝛ' => 'Ꝛ',\n  'ꝝ' => 'Ꝝ',\n  'ꝟ' => 'Ꝟ',\n  'ꝡ' => 'Ꝡ',\n  'ꝣ' => 'Ꝣ',\n  'ꝥ' => 'Ꝥ',\n  'ꝧ' => 'Ꝧ',\n  'ꝩ' => 'Ꝩ',\n  'ꝫ' => 'Ꝫ',\n  'ꝭ' => 'Ꝭ',\n  'ꝯ' => 'Ꝯ',\n  'ꝺ' => 'Ꝺ',\n  'ꝼ' => 'Ꝼ',\n  'ꝿ' => 'Ꝿ',\n  'ꞁ' => 'Ꞁ',\n  'ꞃ' => 'Ꞃ',\n  'ꞅ' => 'Ꞅ',\n  'ꞇ' => 'Ꞇ',\n  'ꞌ' => 'Ꞌ',\n  'ꞑ' => 'Ꞑ',\n  'ꞓ' => 'Ꞓ',\n  'ꞔ' => 'Ꞔ',\n  'ꞗ' => 'Ꞗ',\n  'ꞙ' => 'Ꞙ',\n  'ꞛ' => 'Ꞛ',\n  'ꞝ' => 'Ꞝ',\n  'ꞟ' => 'Ꞟ',\n  'ꞡ' => 'Ꞡ',\n  'ꞣ' => 'Ꞣ',\n  'ꞥ' => 'Ꞥ',\n  'ꞧ' => 'Ꞧ',\n  'ꞩ' => 'Ꞩ',\n  'ꞵ' => 'Ꞵ',\n  'ꞷ' => 'Ꞷ',\n  'ꞹ' => 'Ꞹ',\n  'ꞻ' => 'Ꞻ',\n  'ꞽ' => 'Ꞽ',\n  'ꞿ' => 'Ꞿ',\n  'ꟃ' => 'Ꟃ',\n  'ꟈ' => 'Ꟈ',\n  'ꟊ' => 'Ꟊ',\n  'ꟶ' => 'Ꟶ',\n  'ꭓ' => 'Ꭓ',\n  'ꭰ' => 'Ꭰ',\n  'ꭱ' => 'Ꭱ',\n  'ꭲ' => 'Ꭲ',\n  'ꭳ' => 'Ꭳ',\n  'ꭴ' => 'Ꭴ',\n  'ꭵ' => 'Ꭵ',\n  'ꭶ' => 'Ꭶ',\n  'ꭷ' => 'Ꭷ',\n  'ꭸ' => 'Ꭸ',\n  'ꭹ' => 'Ꭹ',\n  'ꭺ' => 'Ꭺ',\n  'ꭻ' => 'Ꭻ',\n  'ꭼ' => 'Ꭼ',\n  'ꭽ' => 'Ꭽ',\n  'ꭾ' => 'Ꭾ',\n  'ꭿ' => 'Ꭿ',\n  'ꮀ' => 'Ꮀ',\n  'ꮁ' => 'Ꮁ',\n  'ꮂ' => 'Ꮂ',\n  'ꮃ' => 'Ꮃ',\n  'ꮄ' => 'Ꮄ',\n  'ꮅ' => 'Ꮅ',\n  'ꮆ' => 'Ꮆ',\n  'ꮇ' => 'Ꮇ',\n  'ꮈ' => 'Ꮈ',\n  'ꮉ' => 'Ꮉ',\n  'ꮊ' => 'Ꮊ',\n  'ꮋ' => 'Ꮋ',\n  'ꮌ' => 'Ꮌ',\n  'ꮍ' => 'Ꮍ',\n  'ꮎ' => 'Ꮎ',\n  'ꮏ' => 'Ꮏ',\n  'ꮐ' => 'Ꮐ',\n  'ꮑ' => 'Ꮑ',\n  'ꮒ' => 'Ꮒ',\n  'ꮓ' => 'Ꮓ',\n  'ꮔ' => 'Ꮔ',\n  'ꮕ' => 'Ꮕ',\n  'ꮖ' => 'Ꮖ',\n  'ꮗ' => 'Ꮗ',\n  'ꮘ' => 'Ꮘ',\n  'ꮙ' => 'Ꮙ',\n  'ꮚ' => 'Ꮚ',\n  'ꮛ' => 'Ꮛ',\n  'ꮜ' => 'Ꮜ',\n  'ꮝ' => 'Ꮝ',\n  'ꮞ' => 'Ꮞ',\n  'ꮟ' => 'Ꮟ',\n  'ꮠ' => 'Ꮠ',\n  'ꮡ' => 'Ꮡ',\n  'ꮢ' => 'Ꮢ',\n  'ꮣ' => 'Ꮣ',\n  'ꮤ' => 'Ꮤ',\n  'ꮥ' => 'Ꮥ',\n  'ꮦ' => 'Ꮦ',\n  'ꮧ' => 'Ꮧ',\n  'ꮨ' => 'Ꮨ',\n  'ꮩ' => 'Ꮩ',\n  'ꮪ' => 'Ꮪ',\n  'ꮫ' => 'Ꮫ',\n  'ꮬ' => 'Ꮬ',\n  'ꮭ' => 'Ꮭ',\n  'ꮮ' => 'Ꮮ',\n  'ꮯ' => 'Ꮯ',\n  'ꮰ' => 'Ꮰ',\n  'ꮱ' => 'Ꮱ',\n  'ꮲ' => 'Ꮲ',\n  'ꮳ' => 'Ꮳ',\n  'ꮴ' => 'Ꮴ',\n  'ꮵ' => 'Ꮵ',\n  'ꮶ' => 'Ꮶ',\n  'ꮷ' => 'Ꮷ',\n  'ꮸ' => 'Ꮸ',\n  'ꮹ' => 'Ꮹ',\n  'ꮺ' => 'Ꮺ',\n  'ꮻ' => 'Ꮻ',\n  'ꮼ' => 'Ꮼ',\n  'ꮽ' => 'Ꮽ',\n  'ꮾ' => 'Ꮾ',\n  'ꮿ' => 'Ꮿ',\n  'ａ' => 'Ａ',\n  'ｂ' => 'Ｂ',\n  'ｃ' => 'Ｃ',\n  'ｄ' => 'Ｄ',\n  'ｅ' => 'Ｅ',\n  'ｆ' => 'Ｆ',\n  'ｇ' => 'Ｇ',\n  'ｈ' => 'Ｈ',\n  'ｉ' => 'Ｉ',\n  'ｊ' => 'Ｊ',\n  'ｋ' => 'Ｋ',\n  'ｌ' => 'Ｌ',\n  'ｍ' => 'Ｍ',\n  'ｎ' => 'Ｎ',\n  'ｏ' => 'Ｏ',\n  'ｐ' => 'Ｐ',\n  'ｑ' => 'Ｑ',\n  'ｒ' => 'Ｒ',\n  'ｓ' => 'Ｓ',\n  'ｔ' => 'Ｔ',\n  'ｕ' => 'Ｕ',\n  'ｖ' => 'Ｖ',\n  'ｗ' => 'Ｗ',\n  'ｘ' => 'Ｘ',\n  'ｙ' => 'Ｙ',\n  'ｚ' => 'Ｚ',\n  '𐐨' => '𐐀',\n  '𐐩' => '𐐁',\n  '𐐪' => '𐐂',\n  '𐐫' => '𐐃',\n  '𐐬' => '𐐄',\n  '𐐭' => '𐐅',\n  '𐐮' => '𐐆',\n  '𐐯' => '𐐇',\n  '𐐰' => '𐐈',\n  '𐐱' => '𐐉',\n  '𐐲' => '𐐊',\n  '𐐳' => '𐐋',\n  '𐐴' => '𐐌',\n  '𐐵' => '𐐍',\n  '𐐶' => '𐐎',\n  '𐐷' => '𐐏',\n  '𐐸' => '𐐐',\n  '𐐹' => '𐐑',\n  '𐐺' => '𐐒',\n  '𐐻' => '𐐓',\n  '𐐼' => '𐐔',\n  '𐐽' => '𐐕',\n  '𐐾' => '𐐖',\n  '𐐿' => '𐐗',\n  '𐑀' => '𐐘',\n  '𐑁' => '𐐙',\n  '𐑂' => '𐐚',\n  '𐑃' => '𐐛',\n  '𐑄' => '𐐜',\n  '𐑅' => '𐐝',\n  '𐑆' => '𐐞',\n  '𐑇' => '𐐟',\n  '𐑈' => '𐐠',\n  '𐑉' => '𐐡',\n  '𐑊' => '𐐢',\n  '𐑋' => '𐐣',\n  '𐑌' => '𐐤',\n  '𐑍' => '𐐥',\n  '𐑎' => '𐐦',\n  '𐑏' => '𐐧',\n  '𐓘' => '𐒰',\n  '𐓙' => '𐒱',\n  '𐓚' => '𐒲',\n  '𐓛' => '𐒳',\n  '𐓜' => '𐒴',\n  '𐓝' => '𐒵',\n  '𐓞' => '𐒶',\n  '𐓟' => '𐒷',\n  '𐓠' => '𐒸',\n  '𐓡' => '𐒹',\n  '𐓢' => '𐒺',\n  '𐓣' => '𐒻',\n  '𐓤' => '𐒼',\n  '𐓥' => '𐒽',\n  '𐓦' => '𐒾',\n  '𐓧' => '𐒿',\n  '𐓨' => '𐓀',\n  '𐓩' => '𐓁',\n  '𐓪' => '𐓂',\n  '𐓫' => '𐓃',\n  '𐓬' => '𐓄',\n  '𐓭' => '𐓅',\n  '𐓮' => '𐓆',\n  '𐓯' => '𐓇',\n  '𐓰' => '𐓈',\n  '𐓱' => '𐓉',\n  '𐓲' => '𐓊',\n  '𐓳' => '𐓋',\n  '𐓴' => '𐓌',\n  '𐓵' => '𐓍',\n  '𐓶' => '𐓎',\n  '𐓷' => '𐓏',\n  '𐓸' => '𐓐',\n  '𐓹' => '𐓑',\n  '𐓺' => '𐓒',\n  '𐓻' => '𐓓',\n  '𐳀' => '𐲀',\n  '𐳁' => '𐲁',\n  '𐳂' => '𐲂',\n  '𐳃' => '𐲃',\n  '𐳄' => '𐲄',\n  '𐳅' => '𐲅',\n  '𐳆' => '𐲆',\n  '𐳇' => '𐲇',\n  '𐳈' => '𐲈',\n  '𐳉' => '𐲉',\n  '𐳊' => '𐲊',\n  '𐳋' => '𐲋',\n  '𐳌' => '𐲌',\n  '𐳍' => '𐲍',\n  '𐳎' => '𐲎',\n  '𐳏' => '𐲏',\n  '𐳐' => '𐲐',\n  '𐳑' => '𐲑',\n  '𐳒' => '𐲒',\n  '𐳓' => '𐲓',\n  '𐳔' => '𐲔',\n  '𐳕' => '𐲕',\n  '𐳖' => '𐲖',\n  '𐳗' => '𐲗',\n  '𐳘' => '𐲘',\n  '𐳙' => '𐲙',\n  '𐳚' => '𐲚',\n  '𐳛' => '𐲛',\n  '𐳜' => '𐲜',\n  '𐳝' => '𐲝',\n  '𐳞' => '𐲞',\n  '𐳟' => '𐲟',\n  '𐳠' => '𐲠',\n  '𐳡' => '𐲡',\n  '𐳢' => '𐲢',\n  '𐳣' => '𐲣',\n  '𐳤' => '𐲤',\n  '𐳥' => '𐲥',\n  '𐳦' => '𐲦',\n  '𐳧' => '𐲧',\n  '𐳨' => '𐲨',\n  '𐳩' => '𐲩',\n  '𐳪' => '𐲪',\n  '𐳫' => '𐲫',\n  '𐳬' => '𐲬',\n  '𐳭' => '𐲭',\n  '𐳮' => '𐲮',\n  '𐳯' => '𐲯',\n  '𐳰' => '𐲰',\n  '𐳱' => '𐲱',\n  '𐳲' => '𐲲',\n  '𑣀' => '𑢠',\n  '𑣁' => '𑢡',\n  '𑣂' => '𑢢',\n  '𑣃' => '𑢣',\n  '𑣄' => '𑢤',\n  '𑣅' => '𑢥',\n  '𑣆' => '𑢦',\n  '𑣇' => '𑢧',\n  '𑣈' => '𑢨',\n  '𑣉' => '𑢩',\n  '𑣊' => '𑢪',\n  '𑣋' => '𑢫',\n  '𑣌' => '𑢬',\n  '𑣍' => '𑢭',\n  '𑣎' => '𑢮',\n  '𑣏' => '𑢯',\n  '𑣐' => '𑢰',\n  '𑣑' => '𑢱',\n  '𑣒' => '𑢲',\n  '𑣓' => '𑢳',\n  '𑣔' => '𑢴',\n  '𑣕' => '𑢵',\n  '𑣖' => '𑢶',\n  '𑣗' => '𑢷',\n  '𑣘' => '𑢸',\n  '𑣙' => '𑢹',\n  '𑣚' => '𑢺',\n  '𑣛' => '𑢻',\n  '𑣜' => '𑢼',\n  '𑣝' => '𑢽',\n  '𑣞' => '𑢾',\n  '𑣟' => '𑢿',\n  '𖹠' => '𖹀',\n  '𖹡' => '𖹁',\n  '𖹢' => '𖹂',\n  '𖹣' => '𖹃',\n  '𖹤' => '𖹄',\n  '𖹥' => '𖹅',\n  '𖹦' => '𖹆',\n  '𖹧' => '𖹇',\n  '𖹨' => '𖹈',\n  '𖹩' => '𖹉',\n  '𖹪' => '𖹊',\n  '𖹫' => '𖹋',\n  '𖹬' => '𖹌',\n  '𖹭' => '𖹍',\n  '𖹮' => '𖹎',\n  '𖹯' => '𖹏',\n  '𖹰' => '𖹐',\n  '𖹱' => '𖹑',\n  '𖹲' => '𖹒',\n  '𖹳' => '𖹓',\n  '𖹴' => '𖹔',\n  '𖹵' => '𖹕',\n  '𖹶' => '𖹖',\n  '𖹷' => '𖹗',\n  '𖹸' => '𖹘',\n  '𖹹' => '𖹙',\n  '𖹺' => '𖹚',\n  '𖹻' => '𖹛',\n  '𖹼' => '𖹜',\n  '𖹽' => '𖹝',\n  '𖹾' => '𖹞',\n  '𖹿' => '𖹟',\n  '𞤢' => '𞤀',\n  '𞤣' => '𞤁',\n  '𞤤' => '𞤂',\n  '𞤥' => '𞤃',\n  '𞤦' => '𞤄',\n  '𞤧' => '𞤅',\n  '𞤨' => '𞤆',\n  '𞤩' => '𞤇',\n  '𞤪' => '𞤈',\n  '𞤫' => '𞤉',\n  '𞤬' => '𞤊',\n  '𞤭' => '𞤋',\n  '𞤮' => '𞤌',\n  '𞤯' => '𞤍',\n  '𞤰' => '𞤎',\n  '𞤱' => '𞤏',\n  '𞤲' => '𞤐',\n  '𞤳' => '𞤑',\n  '𞤴' => '𞤒',\n  '𞤵' => '𞤓',\n  '𞤶' => '𞤔',\n  '𞤷' => '𞤕',\n  '𞤸' => '𞤖',\n  '𞤹' => '𞤗',\n  '𞤺' => '𞤘',\n  '𞤻' => '𞤙',\n  '𞤼' => '𞤚',\n  '𞤽' => '𞤛',\n  '𞤾' => '𞤜',\n  '𞤿' => '𞤝',\n  '𞥀' => '𞤞',\n  '𞥁' => '𞤟',\n  '𞥂' => '𞤠',\n  '𞥃' => '𞤡',\n  'ß' => 'SS',\n  'ﬀ' => 'FF',\n  'ﬁ' => 'FI',\n  'ﬂ' => 'FL',\n  'ﬃ' => 'FFI',\n  'ﬄ' => 'FFL',\n  'ﬅ' => 'ST',\n  'ﬆ' => 'ST',\n  'և' => 'ԵՒ',\n  'ﬓ' => 'ՄՆ',\n  'ﬔ' => 'ՄԵ',\n  'ﬕ' => 'ՄԻ',\n  'ﬖ' => 'ՎՆ',\n  'ﬗ' => 'ՄԽ',\n  'ŉ' => 'ʼN',\n  'ΐ' => 'Ϊ́',\n  'ΰ' => 'Ϋ́',\n  'ǰ' => 'J̌',\n  'ẖ' => 'H̱',\n  'ẗ' => 'T̈',\n  'ẘ' => 'W̊',\n  'ẙ' => 'Y̊',\n  'ẚ' => 'Aʾ',\n  'ὐ' => 'Υ̓',\n  'ὒ' => 'Υ̓̀',\n  'ὔ' => 'Υ̓́',\n  'ὖ' => 'Υ̓͂',\n  'ᾶ' => 'Α͂',\n  'ῆ' => 'Η͂',\n  'ῒ' => 'Ϊ̀',\n  'ΐ' => 'Ϊ́',\n  'ῖ' => 'Ι͂',\n  'ῗ' => 'Ϊ͂',\n  'ῢ' => 'Ϋ̀',\n  'ΰ' => 'Ϋ́',\n  'ῤ' => 'Ρ̓',\n  'ῦ' => 'Υ͂',\n  'ῧ' => 'Ϋ͂',\n  'ῶ' => 'Ω͂',\n  'ᾈ' => 'ἈΙ',\n  'ᾉ' => 'ἉΙ',\n  'ᾊ' => 'ἊΙ',\n  'ᾋ' => 'ἋΙ',\n  'ᾌ' => 'ἌΙ',\n  'ᾍ' => 'ἍΙ',\n  'ᾎ' => 'ἎΙ',\n  'ᾏ' => 'ἏΙ',\n  'ᾘ' => 'ἨΙ',\n  'ᾙ' => 'ἩΙ',\n  'ᾚ' => 'ἪΙ',\n  'ᾛ' => 'ἫΙ',\n  'ᾜ' => 'ἬΙ',\n  'ᾝ' => 'ἭΙ',\n  'ᾞ' => 'ἮΙ',\n  'ᾟ' => 'ἯΙ',\n  'ᾨ' => 'ὨΙ',\n  'ᾩ' => 'ὩΙ',\n  'ᾪ' => 'ὪΙ',\n  'ᾫ' => 'ὫΙ',\n  'ᾬ' => 'ὬΙ',\n  'ᾭ' => 'ὭΙ',\n  'ᾮ' => 'ὮΙ',\n  'ᾯ' => 'ὯΙ',\n  'ᾼ' => 'ΑΙ',\n  'ῌ' => 'ΗΙ',\n  'ῼ' => 'ΩΙ',\n  'ᾲ' => 'ᾺΙ',\n  'ᾴ' => 'ΆΙ',\n  'ῂ' => 'ῊΙ',\n  'ῄ' => 'ΉΙ',\n  'ῲ' => 'ῺΙ',\n  'ῴ' => 'ΏΙ',\n  'ᾷ' => 'Α͂Ι',\n  'ῇ' => 'Η͂Ι',\n  'ῷ' => 'Ω͂Ι',\n);\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/AmqpCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Casts Amqp related classes to array representation.\n *\n * @author Grégoire Pineau <lyrixx@lyrixx.info>\n *\n * @final\n */\nclass AmqpCaster\n{\n    private const FLAGS = [\n        \\AMQP_DURABLE => 'AMQP_DURABLE',\n        \\AMQP_PASSIVE => 'AMQP_PASSIVE',\n        \\AMQP_EXCLUSIVE => 'AMQP_EXCLUSIVE',\n        \\AMQP_AUTODELETE => 'AMQP_AUTODELETE',\n        \\AMQP_INTERNAL => 'AMQP_INTERNAL',\n        \\AMQP_NOLOCAL => 'AMQP_NOLOCAL',\n        \\AMQP_AUTOACK => 'AMQP_AUTOACK',\n        \\AMQP_IFEMPTY => 'AMQP_IFEMPTY',\n        \\AMQP_IFUNUSED => 'AMQP_IFUNUSED',\n        \\AMQP_MANDATORY => 'AMQP_MANDATORY',\n        \\AMQP_IMMEDIATE => 'AMQP_IMMEDIATE',\n        \\AMQP_MULTIPLE => 'AMQP_MULTIPLE',\n        \\AMQP_NOWAIT => 'AMQP_NOWAIT',\n        \\AMQP_REQUEUE => 'AMQP_REQUEUE',\n    ];\n\n    private const EXCHANGE_TYPES = [\n        \\AMQP_EX_TYPE_DIRECT => 'AMQP_EX_TYPE_DIRECT',\n        \\AMQP_EX_TYPE_FANOUT => 'AMQP_EX_TYPE_FANOUT',\n        \\AMQP_EX_TYPE_TOPIC => 'AMQP_EX_TYPE_TOPIC',\n        \\AMQP_EX_TYPE_HEADERS => 'AMQP_EX_TYPE_HEADERS',\n    ];\n\n    /**\n     * @return array\n     */\n    public static function castConnection(\\AMQPConnection $c, array $a, Stub $stub, bool $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        $a += [\n            $prefix.'is_connected' => $c->isConnected(),\n        ];\n\n        // Recent version of the extension already expose private properties\n        if (isset($a[\"\\x00AMQPConnection\\x00login\"])) {\n            return $a;\n        }\n\n        // BC layer in the amqp lib\n        if (method_exists($c, 'getReadTimeout')) {\n            $timeout = $c->getReadTimeout();\n        } else {\n            $timeout = $c->getTimeout();\n        }\n\n        $a += [\n            $prefix.'is_connected' => $c->isConnected(),\n            $prefix.'login' => $c->getLogin(),\n            $prefix.'password' => $c->getPassword(),\n            $prefix.'host' => $c->getHost(),\n            $prefix.'vhost' => $c->getVhost(),\n            $prefix.'port' => $c->getPort(),\n            $prefix.'read_timeout' => $timeout,\n        ];\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castChannel(\\AMQPChannel $c, array $a, Stub $stub, bool $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        $a += [\n            $prefix.'is_connected' => $c->isConnected(),\n            $prefix.'channel_id' => $c->getChannelId(),\n        ];\n\n        // Recent version of the extension already expose private properties\n        if (isset($a[\"\\x00AMQPChannel\\x00connection\"])) {\n            return $a;\n        }\n\n        $a += [\n            $prefix.'connection' => $c->getConnection(),\n            $prefix.'prefetch_size' => $c->getPrefetchSize(),\n            $prefix.'prefetch_count' => $c->getPrefetchCount(),\n        ];\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castQueue(\\AMQPQueue $c, array $a, Stub $stub, bool $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        $a += [\n            $prefix.'flags' => self::extractFlags($c->getFlags()),\n        ];\n\n        // Recent version of the extension already expose private properties\n        if (isset($a[\"\\x00AMQPQueue\\x00name\"])) {\n            return $a;\n        }\n\n        $a += [\n            $prefix.'connection' => $c->getConnection(),\n            $prefix.'channel' => $c->getChannel(),\n            $prefix.'name' => $c->getName(),\n            $prefix.'arguments' => $c->getArguments(),\n        ];\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castExchange(\\AMQPExchange $c, array $a, Stub $stub, bool $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        $a += [\n            $prefix.'flags' => self::extractFlags($c->getFlags()),\n        ];\n\n        $type = isset(self::EXCHANGE_TYPES[$c->getType()]) ? new ConstStub(self::EXCHANGE_TYPES[$c->getType()], $c->getType()) : $c->getType();\n\n        // Recent version of the extension already expose private properties\n        if (isset($a[\"\\x00AMQPExchange\\x00name\"])) {\n            $a[\"\\x00AMQPExchange\\x00type\"] = $type;\n\n            return $a;\n        }\n\n        $a += [\n            $prefix.'connection' => $c->getConnection(),\n            $prefix.'channel' => $c->getChannel(),\n            $prefix.'name' => $c->getName(),\n            $prefix.'type' => $type,\n            $prefix.'arguments' => $c->getArguments(),\n        ];\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castEnvelope(\\AMQPEnvelope $c, array $a, Stub $stub, bool $isNested, int $filter = 0)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        $deliveryMode = new ConstStub($c->getDeliveryMode().(2 === $c->getDeliveryMode() ? ' (persistent)' : ' (non-persistent)'), $c->getDeliveryMode());\n\n        // Recent version of the extension already expose private properties\n        if (isset($a[\"\\x00AMQPEnvelope\\x00body\"])) {\n            $a[\"\\0AMQPEnvelope\\0delivery_mode\"] = $deliveryMode;\n\n            return $a;\n        }\n\n        if (!($filter & Caster::EXCLUDE_VERBOSE)) {\n            $a += [$prefix.'body' => $c->getBody()];\n        }\n\n        $a += [\n            $prefix.'delivery_tag' => $c->getDeliveryTag(),\n            $prefix.'is_redelivery' => $c->isRedelivery(),\n            $prefix.'exchange_name' => $c->getExchangeName(),\n            $prefix.'routing_key' => $c->getRoutingKey(),\n            $prefix.'content_type' => $c->getContentType(),\n            $prefix.'content_encoding' => $c->getContentEncoding(),\n            $prefix.'headers' => $c->getHeaders(),\n            $prefix.'delivery_mode' => $deliveryMode,\n            $prefix.'priority' => $c->getPriority(),\n            $prefix.'correlation_id' => $c->getCorrelationId(),\n            $prefix.'reply_to' => $c->getReplyTo(),\n            $prefix.'expiration' => $c->getExpiration(),\n            $prefix.'message_id' => $c->getMessageId(),\n            $prefix.'timestamp' => $c->getTimeStamp(),\n            $prefix.'type' => $c->getType(),\n            $prefix.'user_id' => $c->getUserId(),\n            $prefix.'app_id' => $c->getAppId(),\n        ];\n\n        return $a;\n    }\n\n    private static function extractFlags(int $flags): ConstStub\n    {\n        $flagsArray = [];\n\n        foreach (self::FLAGS as $value => $name) {\n            if ($flags & $value) {\n                $flagsArray[] = $name;\n            }\n        }\n\n        if (!$flagsArray) {\n            $flagsArray = ['AMQP_NOPARAM'];\n        }\n\n        return new ConstStub(implode('|', $flagsArray), $flags);\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/ArgsStub.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Represents a list of function arguments.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass ArgsStub extends EnumStub\n{\n    private static array $parameters = [];\n\n    public function __construct(array $args, string $function, ?string $class)\n    {\n        [$variadic, $params] = self::getParameters($function, $class);\n\n        $values = [];\n        foreach ($args as $k => $v) {\n            $values[$k] = !\\is_scalar($v) && !$v instanceof Stub ? new CutStub($v) : $v;\n        }\n        if (null === $params) {\n            parent::__construct($values, false);\n\n            return;\n        }\n        if (\\count($values) < \\count($params)) {\n            $params = \\array_slice($params, 0, \\count($values));\n        } elseif (\\count($values) > \\count($params)) {\n            $values[] = new EnumStub(array_splice($values, \\count($params)), false);\n            $params[] = $variadic;\n        }\n        if (['...'] === $params) {\n            $this->dumpKeys = false;\n            $this->value = $values[0]->value;\n        } else {\n            $this->value = array_combine($params, $values);\n        }\n    }\n\n    private static function getParameters(string $function, ?string $class): array\n    {\n        if (isset(self::$parameters[$k = $class.'::'.$function])) {\n            return self::$parameters[$k];\n        }\n\n        try {\n            $r = null !== $class ? new \\ReflectionMethod($class, $function) : new \\ReflectionFunction($function);\n        } catch (\\ReflectionException) {\n            return [null, null];\n        }\n\n        $variadic = '...';\n        $params = [];\n        foreach ($r->getParameters() as $v) {\n            $k = '$'.$v->name;\n            if ($v->isPassedByReference()) {\n                $k = '&'.$k;\n            }\n            if ($v->isVariadic()) {\n                $variadic .= $k;\n            } else {\n                $params[] = $k;\n            }\n        }\n\n        return self::$parameters[$k] = [$variadic, $params];\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/Caster.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Helper for filtering out properties in casters.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n *\n * @final\n */\nclass Caster\n{\n    public const EXCLUDE_VERBOSE = 1;\n    public const EXCLUDE_VIRTUAL = 2;\n    public const EXCLUDE_DYNAMIC = 4;\n    public const EXCLUDE_PUBLIC = 8;\n    public const EXCLUDE_PROTECTED = 16;\n    public const EXCLUDE_PRIVATE = 32;\n    public const EXCLUDE_NULL = 64;\n    public const EXCLUDE_EMPTY = 128;\n    public const EXCLUDE_NOT_IMPORTANT = 256;\n    public const EXCLUDE_STRICT = 512;\n\n    public const PREFIX_VIRTUAL = "\\0~\\0";\n    public const PREFIX_DYNAMIC = "\\0+\\0";\n    public const PREFIX_PROTECTED = "\\0*\\0";\n    // usage: sprintf(Caster::PATTERN_PRIVATE, $class, $property)\n    public const PATTERN_PRIVATE = "\\0%s\\0%s";\n\n    /**\n     * Casts objects to arrays and adds the dynamic property prefix.\n     *\n     * @param bool $hasDebugInfo Whether the __debugInfo method exists on $obj or not\n     */\n    public static function castObject(object $obj, string $class, bool $hasDebugInfo = false, string $debugClass = null): array\n    {\n        if ($hasDebugInfo) {\n            try {\n                $debugInfo = $obj->__debugInfo();\n            } catch (\\Throwable) {\n                // ignore failing __debugInfo()\n                $hasDebugInfo = false;\n            }\n        }\n\n        $a = $obj instanceof \\Closure ? [] : (array) $obj;\n\n        if ($obj instanceof \\__PHP_Incomplete_Class) {\n            return $a;\n        }\n\n        if ($a) {\n            static $publicProperties = [];\n            $debugClass ??= get_debug_type($obj);\n\n            $i = 0;\n            $prefixedKeys = [];\n            foreach ($a as $k => $v) {\n                if ("\\0" !== ($k[0] ?? \'\')) {\n                    if (!isset($publicProperties[$class])) {\n                        foreach ((new \\ReflectionClass($class))->getProperties(\\ReflectionProperty::IS_PUBLIC) as $prop) {\n                            $publicProperties[$class][$prop->name] = true;\n                        }\n                    }\n                    if (!isset($publicProperties[$class][$k])) {\n                        $prefixedKeys[$i] = self::PREFIX_DYNAMIC.$k;\n                    }\n                } elseif ($debugClass !== $class && 1 === strpos($k, $class)) {\n                    $prefixedKeys[$i] = "\\0".$debugClass.strrchr($k, "\\0");\n                }\n                ++$i;\n            }\n            if ($prefixedKeys) {\n                $keys = array_keys($a);\n                foreach ($prefixedKeys as $i => $k) {\n                    $keys[$i] = $k;\n                }\n                $a = array_combine($keys, $a);\n            }\n        }\n\n        if ($hasDebugInfo && \\is_array($debugInfo)) {\n            foreach ($debugInfo as $k => $v) {\n                if (!isset($k[0]) || "\\0" !== $k[0]) {\n                    if (\\array_key_exists(self::PREFIX_DYNAMIC.$k, $a)) {\n                        continue;\n                    }\n                    $k = self::PREFIX_VIRTUAL.$k;\n                }\n\n                unset($a[$k]);\n                $a[$k] = $v;\n            }\n        }\n\n        return $a;\n    }\n\n    /**\n     * Filters out the specified properties.\n     *\n     * By default, a single match in the $filter bit field filters properties out, following an "or" logic.\n     * When EXCLUDE_STRICT is set, an "and" logic is applied: all bits must match for a property to be removed.\n     *\n     * @param array    $a                The array containing the properties to filter\n     * @param int      $filter           A bit field of Caster::EXCLUDE_* constants specifying which properties to filter out\n     * @param string[] $listedProperties List of properties to exclude when Caster::EXCLUDE_VERBOSE is set, and to preserve when Caster::EXCLUDE_NOT_IMPORTANT is set\n     * @param int|null &$count           Set to the number of removed properties\n     */\n    public static function filter(array $a, int $filter, array $listedProperties = [], ?int &$count = 0): array\n    {\n        $count = 0;\n\n        foreach ($a as $k => $v) {\n            $type = self::EXCLUDE_STRICT & $filter;\n\n            if (null === $v) {\n                $type |= self::EXCLUDE_NULL & $filter;\n                $type |= self::EXCLUDE_EMPTY & $filter;\n            } elseif (false === $v || \'\' === $v || \'0\' === $v || 0 === $v || 0.0 === $v || [] === $v) {\n                $type |= self::EXCLUDE_EMPTY & $filter;\n            }\n            if ((self::EXCLUDE_NOT_IMPORTANT & $filter) && !\\in_array($k, $listedProperties, true)) {\n                $type |= self::EXCLUDE_NOT_IMPORTANT;\n            }\n            if ((self::EXCLUDE_VERBOSE & $filter) && \\in_array($k, $listedProperties, true)) {\n                $type |= self::EXCLUDE_VERBOSE;\n            }\n\n            if (!isset($k[1]) || "\\0" !== $k[0]) {\n                $type |= self::EXCLUDE_PUBLIC & $filter;\n            } elseif (\'~\' === $k[1]) {\n                $type |= self::EXCLUDE_VIRTUAL & $filter;\n            } elseif (\'+\' === $k[1]) {\n                $type |= self::EXCLUDE_DYNAMIC & $filter;\n            } elseif (\'*\' === $k[1]) {\n                $type |= self::EXCLUDE_PROTECTED & $filter;\n            } else {\n                $type |= self::EXCLUDE_PRIVATE & $filter;\n            }\n\n            if ((self::EXCLUDE_STRICT & $filter) ? $type === $filter : $type) {\n                unset($a[$k]);\n                ++$count;\n            }\n        }\n\n        return $a;\n    }\n\n    public static function castPhpIncompleteClass(\\__PHP_Incomplete_Class $c, array $a, Stub $stub, bool $isNested): array\n    {\n        if (isset($a[\'__PHP_Incomplete_Class_Name\'])) {\n            $stub->class .= \'(\'.$a[\'__PHP_Incomplete_Class_Name\'].\')\';\n            unset($a[\'__PHP_Incomplete_Class_Name\']);\n        }\n\n        return $a;\n    }\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/ClassStub.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Represents a PHP class identifier.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass ClassStub extends ConstStub\n{\n    /**\n     * @param string   $identifier A PHP identifier, e.g. a class, method, interface, etc. name\n     * @param callable $callable   The callable targeted by the identifier when it is ambiguous or not a real PHP identifier\n     */\n    public function __construct(string $identifier, callable|array|string $callable = null)\n    {\n        $this->value = $identifier;\n\n        try {\n            if (null !== $callable) {\n                if ($callable instanceof \\Closure) {\n                    $r = new \\ReflectionFunction($callable);\n                } elseif (\\is_object($callable)) {\n                    $r = [$callable, '__invoke'];\n                } elseif (\\is_array($callable)) {\n                    $r = $callable;\n                } elseif (false !== $i = strpos($callable, '::')) {\n                    $r = [substr($callable, 0, $i), substr($callable, 2 + $i)];\n                } else {\n                    $r = new \\ReflectionFunction($callable);\n                }\n            } elseif (0 < $i = strpos($identifier, '::') ?: strpos($identifier, '->')) {\n                $r = [substr($identifier, 0, $i), substr($identifier, 2 + $i)];\n            } else {\n                $r = new \\ReflectionClass($identifier);\n            }\n\n            if (\\is_array($r)) {\n                try {\n                    $r = new \\ReflectionMethod($r[0], $r[1]);\n                } catch (\\ReflectionException) {\n                    $r = new \\ReflectionClass($r[0]);\n                }\n            }\n\n            if (str_contains($identifier, \"@anonymous\\0\")) {\n                $this->value = $identifier = preg_replace_callback('/[a-zA-Z_\\x7f-\\xff][\\\\\\\\a-zA-Z0-9_\\x7f-\\xff]*+@anonymous\\x00.*?\\.php(?:0x?|:[0-9]++\\$)[0-9a-fA-F]++/', fn ($m) => class_exists($m[0], false) ? (get_parent_class($m[0]) ?: key(class_implements($m[0])) ?: 'class').'@anonymous' : $m[0], $identifier);\n            }\n\n            if (null !== $callable && $r instanceof \\ReflectionFunctionAbstract) {\n                $s = ReflectionCaster::castFunctionAbstract($r, [], new Stub(), true, Caster::EXCLUDE_VERBOSE);\n                $s = ReflectionCaster::getSignature($s);\n\n                if (str_ends_with($identifier, '()')) {\n                    $this->value = substr_replace($identifier, $s, -2);\n                } else {\n                    $this->value .= $s;\n                }\n            }\n        } catch (\\ReflectionException) {\n            return;\n        } finally {\n            if (0 < $i = strrpos($this->value, '\\\\')) {\n                $this->attr['ellipsis'] = \\strlen($this->value) - $i;\n                $this->attr['ellipsis-type'] = 'class';\n                $this->attr['ellipsis-tail'] = 1;\n            }\n        }\n\n        if ($f = $r->getFileName()) {\n            $this->attr['file'] = $f;\n            $this->attr['line'] = $r->getStartLine();\n        }\n    }\n\n    /**\n     * @return mixed\n     */\n    public static function wrapCallable(mixed $callable)\n    {\n        if (\\is_object($callable) || !\\is_callable($callable)) {\n            return $callable;\n        }\n\n        if (!\\is_array($callable)) {\n            $callable = new static($callable, $callable);\n        } elseif (\\is_string($callable[0])) {\n            $callable[0] = new static($callable[0], $callable);\n        } else {\n            $callable[1] = new static($callable[1], $callable);\n        }\n\n        return $callable;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/ConstStub.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Represents a PHP constant and its value.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass ConstStub extends Stub\n{\n    public function __construct(string $name, string|int|float $value = null)\n    {\n        $this->class = $name;\n        $this->value = 1 < \\func_num_args() ? $value : $name;\n    }\n\n    public function __toString(): string\n    {\n        return (string) $this->value;\n    }\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/CutArrayStub.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\n/**\n * Represents a cut array.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass CutArrayStub extends CutStub\n{\n    public $preservedSubset;\n\n    public function __construct(array $value, array $preservedKeys)\n    {\n        parent::__construct($value);\n\n        $this->preservedSubset = array_intersect_key($value, array_flip($preservedKeys));\n        $this->cut -= \\count($this->preservedSubset);\n    }\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/CutStub.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Represents the main properties of a PHP variable, pre-casted by a caster.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass CutStub extends Stub\n{\n    public function __construct(mixed $value)\n    {\n        $this->value = $value;\n\n        switch (\\gettype($value)) {\n            case 'object':\n                $this->type = self::TYPE_OBJECT;\n                $this->class = $value::class;\n\n                if ($value instanceof \\Closure) {\n                    ReflectionCaster::castClosure($value, [], $this, true, Caster::EXCLUDE_VERBOSE);\n                }\n\n                $this->cut = -1;\n                break;\n\n            case 'array':\n                $this->type = self::TYPE_ARRAY;\n                $this->class = self::ARRAY_ASSOC;\n                $this->cut = $this->value = \\count($value);\n                break;\n\n            case 'resource':\n            case 'unknown type':\n            case 'resource (closed)':\n                $this->type = self::TYPE_RESOURCE;\n                $this->handle = (int) $value;\n                if ('Unknown' === $this->class = @get_resource_type($value)) {\n                    $this->class = 'Closed';\n                }\n                $this->cut = -1;\n                break;\n\n            case 'string':\n                $this->type = self::TYPE_STRING;\n                $this->class = preg_match('//u', $value) ? self::STRING_UTF8 : self::STRING_BINARY;\n                $this->cut = self::STRING_BINARY === $this->class ? \\strlen($value) : mb_strlen($value, 'UTF-8');\n                $this->value = '';\n                break;\n        }\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/DateCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Casts DateTimeInterface related classes to array representation.\n *\n * @author Dany Maillard <danymaillard93b@gmail.com>\n *\n * @final\n */\nclass DateCaster\n{\n    private const PERIOD_LIMIT = 3;\n\n    /**\n     * @return array\n     */\n    public static function castDateTime(\\DateTimeInterface $d, array $a, Stub $stub, bool $isNested, int $filter)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n        $location = $d->getTimezone() ? $d->getTimezone()->getLocation() : null;\n        $fromNow = (new \\DateTimeImmutable())->diff($d);\n\n        $title = $d->format('l, F j, Y')\n            .\"\\n\".self::formatInterval($fromNow).' from now'\n            .($location ? ($d->format('I') ? \"\\nDST On\" : \"\\nDST Off\") : '')\n        ;\n\n        unset(\n            $a[Caster::PREFIX_DYNAMIC.'date'],\n            $a[Caster::PREFIX_DYNAMIC.'timezone'],\n            $a[Caster::PREFIX_DYNAMIC.'timezone_type']\n        );\n        $a[$prefix.'date'] = new ConstStub(self::formatDateTime($d, $location ? ' e (P)' : ' P'), $title);\n\n        $stub->class .= $d->format(' @U');\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castInterval(\\DateInterval $interval, array $a, Stub $stub, bool $isNested, int $filter)\n    {\n        $now = new \\DateTimeImmutable('@0', new \\DateTimeZone('UTC'));\n        $numberOfSeconds = $now->add($interval)->getTimestamp() - $now->getTimestamp();\n        $title = number_format($numberOfSeconds, 0, '.', ' ').'s';\n\n        $i = [Caster::PREFIX_VIRTUAL.'interval' => new ConstStub(self::formatInterval($interval), $title)];\n\n        return $filter & Caster::EXCLUDE_VERBOSE ? $i : $i + $a;\n    }\n\n    private static function formatInterval(\\DateInterval $i): string\n    {\n        $format = '%R ';\n\n        if (0 === $i->y && 0 === $i->m && ($i->h >= 24 || $i->i >= 60 || $i->s >= 60)) {\n            $d = new \\DateTimeImmutable('@0', new \\DateTimeZone('UTC'));\n            $i = $d->diff($d->add($i)); // recalculate carry over points\n            $format .= 0 < $i->days ? '%ad ' : '';\n        } else {\n            $format .= ($i->y ? '%yy ' : '').($i->m ? '%mm ' : '').($i->d ? '%dd ' : '');\n        }\n\n        $format .= $i->h || $i->i || $i->s || $i->f ? '%H:%I:'.self::formatSeconds($i->s, substr($i->f, 2)) : '';\n        $format = '%R ' === $format ? '0s' : $format;\n\n        return $i->format(rtrim($format));\n    }\n\n    /**\n     * @return array\n     */\n    public static function castTimeZone(\\DateTimeZone $timeZone, array $a, Stub $stub, bool $isNested, int $filter)\n    {\n        $location = $timeZone->getLocation();\n        $formatted = (new \\DateTimeImmutable('now', $timeZone))->format($location ? 'e (P)' : 'P');\n        $title = $location && \\extension_loaded('intl') ? \\Locale::getDisplayRegion('-'.$location['country_code']) : '';\n\n        $z = [Caster::PREFIX_VIRTUAL.'timezone' => new ConstStub($formatted, $title)];\n\n        return $filter & Caster::EXCLUDE_VERBOSE ? $z : $z + $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castPeriod(\\DatePeriod $p, array $a, Stub $stub, bool $isNested, int $filter)\n    {\n        $dates = [];\n        foreach (clone $p as $i => $d) {\n            if (self::PERIOD_LIMIT === $i) {\n                $now = new \\DateTimeImmutable('now', new \\DateTimeZone('UTC'));\n                $dates[] = sprintf('%s more', ($end = $p->getEndDate())\n                    ? ceil(($end->format('U.u') - $d->format('U.u')) / ((int) $now->add($p->getDateInterval())->format('U.u') - (int) $now->format('U.u')))\n                    : $p->recurrences - $i\n                );\n                break;\n            }\n            $dates[] = sprintf('%s) %s', $i + 1, self::formatDateTime($d));\n        }\n\n        $period = sprintf(\n            'every %s, from %s%s %s',\n            self::formatInterval($p->getDateInterval()),\n            $p->include_start_date ? '[' : ']',\n            self::formatDateTime($p->getStartDate()),\n            ($end = $p->getEndDate()) ? 'to '.self::formatDateTime($end).(\\PHP_VERSION_ID >= 80200 && $p->include_end_date ? ']' : '[') : 'recurring '.$p->recurrences.' time/s'\n        );\n\n        $p = [Caster::PREFIX_VIRTUAL.'period' => new ConstStub($period, implode(\"\\n\", $dates))];\n\n        return $filter & Caster::EXCLUDE_VERBOSE ? $p : $p + $a;\n    }\n\n    private static function formatDateTime(\\DateTimeInterface $d, string $extra = ''): string\n    {\n        return $d->format('Y-m-d H:i:'.self::formatSeconds($d->format('s'), $d->format('u')).$extra);\n    }\n\n    private static function formatSeconds(string $s, string $us): string\n    {\n        return sprintf('%02d.%s', $s, 0 === ($len = \\strlen($t = rtrim($us, '0'))) ? '0' : ($len <= 3 ? str_pad($t, 3, '0') : $us));\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/DoctrineCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Doctrine\\Common\\Proxy\\Proxy as CommonProxy;\nuse Doctrine\\ORM\\PersistentCollection;\nuse Doctrine\\ORM\\Proxy\\Proxy as OrmProxy;\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Casts Doctrine related classes to array representation.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n *\n * @final\n */\nclass DoctrineCaster\n{\n    /**\n     * @return array\n     */\n    public static function castCommonProxy(CommonProxy $proxy, array $a, Stub $stub, bool $isNested)\n    {\n        foreach (['__cloner__', '__initializer__'] as $k) {\n            if (\\array_key_exists($k, $a)) {\n                unset($a[$k]);\n                ++$stub->cut;\n            }\n        }\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castOrmProxy(OrmProxy $proxy, array $a, Stub $stub, bool $isNested)\n    {\n        foreach (['_entityPersister', '_identifier'] as $k) {\n            if (\\array_key_exists($k = \"\\0Doctrine\\\\ORM\\\\Proxy\\\\Proxy\\0\".$k, $a)) {\n                unset($a[$k]);\n                ++$stub->cut;\n            }\n        }\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castPersistentCollection(PersistentCollection $coll, array $a, Stub $stub, bool $isNested)\n    {\n        foreach (['snapshot', 'association', 'typeClass'] as $k) {\n            if (\\array_key_exists($k = \"\\0Doctrine\\\\ORM\\\\PersistentCollection\\0\".$k, $a)) {\n                $a[$k] = new CutStub($a[$k]);\n            }\n        }\n\n        return $a;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/DOMCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Casts DOM related classes to array representation.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n *\n * @final\n */\nclass DOMCaster\n{\n    private const ERROR_CODES = [\n        \\DOM_PHP_ERR => 'DOM_PHP_ERR',\n        \\DOM_INDEX_SIZE_ERR => 'DOM_INDEX_SIZE_ERR',\n        \\DOMSTRING_SIZE_ERR => 'DOMSTRING_SIZE_ERR',\n        \\DOM_HIERARCHY_REQUEST_ERR => 'DOM_HIERARCHY_REQUEST_ERR',\n        \\DOM_WRONG_DOCUMENT_ERR => 'DOM_WRONG_DOCUMENT_ERR',\n        \\DOM_INVALID_CHARACTER_ERR => 'DOM_INVALID_CHARACTER_ERR',\n        \\DOM_NO_DATA_ALLOWED_ERR => 'DOM_NO_DATA_ALLOWED_ERR',\n        \\DOM_NO_MODIFICATION_ALLOWED_ERR => 'DOM_NO_MODIFICATION_ALLOWED_ERR',\n        \\DOM_NOT_FOUND_ERR => 'DOM_NOT_FOUND_ERR',\n        \\DOM_NOT_SUPPORTED_ERR => 'DOM_NOT_SUPPORTED_ERR',\n        \\DOM_INUSE_ATTRIBUTE_ERR => 'DOM_INUSE_ATTRIBUTE_ERR',\n        \\DOM_INVALID_STATE_ERR => 'DOM_INVALID_STATE_ERR',\n        \\DOM_SYNTAX_ERR => 'DOM_SYNTAX_ERR',\n        \\DOM_INVALID_MODIFICATION_ERR => 'DOM_INVALID_MODIFICATION_ERR',\n        \\DOM_NAMESPACE_ERR => 'DOM_NAMESPACE_ERR',\n        \\DOM_INVALID_ACCESS_ERR => 'DOM_INVALID_ACCESS_ERR',\n        \\DOM_VALIDATION_ERR => 'DOM_VALIDATION_ERR',\n    ];\n\n    private const NODE_TYPES = [\n        \\XML_ELEMENT_NODE => 'XML_ELEMENT_NODE',\n        \\XML_ATTRIBUTE_NODE => 'XML_ATTRIBUTE_NODE',\n        \\XML_TEXT_NODE => 'XML_TEXT_NODE',\n        \\XML_CDATA_SECTION_NODE => 'XML_CDATA_SECTION_NODE',\n        \\XML_ENTITY_REF_NODE => 'XML_ENTITY_REF_NODE',\n        \\XML_ENTITY_NODE => 'XML_ENTITY_NODE',\n        \\XML_PI_NODE => 'XML_PI_NODE',\n        \\XML_COMMENT_NODE => 'XML_COMMENT_NODE',\n        \\XML_DOCUMENT_NODE => 'XML_DOCUMENT_NODE',\n        \\XML_DOCUMENT_TYPE_NODE => 'XML_DOCUMENT_TYPE_NODE',\n        \\XML_DOCUMENT_FRAG_NODE => 'XML_DOCUMENT_FRAG_NODE',\n        \\XML_NOTATION_NODE => 'XML_NOTATION_NODE',\n        \\XML_HTML_DOCUMENT_NODE => 'XML_HTML_DOCUMENT_NODE',\n        \\XML_DTD_NODE => 'XML_DTD_NODE',\n        \\XML_ELEMENT_DECL_NODE => 'XML_ELEMENT_DECL_NODE',\n        \\XML_ATTRIBUTE_DECL_NODE => 'XML_ATTRIBUTE_DECL_NODE',\n        \\XML_ENTITY_DECL_NODE => 'XML_ENTITY_DECL_NODE',\n        \\XML_NAMESPACE_DECL_NODE => 'XML_NAMESPACE_DECL_NODE',\n    ];\n\n    /**\n     * @return array\n     */\n    public static function castException(\\DOMException $e, array $a, Stub $stub, bool $isNested)\n    {\n        $k = Caster::PREFIX_PROTECTED.'code';\n        if (isset($a[$k], self::ERROR_CODES[$a[$k]])) {\n            $a[$k] = new ConstStub(self::ERROR_CODES[$a[$k]], $a[$k]);\n        }\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castLength($dom, array $a, Stub $stub, bool $isNested)\n    {\n        $a += [\n            'length' => $dom->length,\n        ];\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castImplementation(\\DOMImplementation $dom, array $a, Stub $stub, bool $isNested)\n    {\n        $a += [\n            Caster::PREFIX_VIRTUAL.'Core' => '1.0',\n            Caster::PREFIX_VIRTUAL.'XML' => '2.0',\n        ];\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castNode(\\DOMNode $dom, array $a, Stub $stub, bool $isNested)\n    {\n        $a += [\n            'nodeName' => $dom->nodeName,\n            'nodeValue' => new CutStub($dom->nodeValue),\n            'nodeType' => new ConstStub(self::NODE_TYPES[$dom->nodeType], $dom->nodeType),\n            'parentNode' => new CutStub($dom->parentNode),\n            'childNodes' => $dom->childNodes,\n            'firstChild' => new CutStub($dom->firstChild),\n            'lastChild' => new CutStub($dom->lastChild),\n            'previousSibling' => new CutStub($dom->previousSibling),\n            'nextSibling' => new CutStub($dom->nextSibling),\n            'attributes' => $dom->attributes,\n            'ownerDocument' => new CutStub($dom->ownerDocument),\n            'namespaceURI' => $dom->namespaceURI,\n            'prefix' => $dom->prefix,\n            'localName' => $dom->localName,\n            'baseURI' => $dom->baseURI ? new LinkStub($dom->baseURI) : $dom->baseURI,\n            'textContent' => new CutStub($dom->textContent),\n        ];\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castNameSpaceNode(\\DOMNameSpaceNode $dom, array $a, Stub $stub, bool $isNested)\n    {\n        $a += [\n            'nodeName' => $dom->nodeName,\n            'nodeValue' => new CutStub($dom->nodeValue),\n            'nodeType' => new ConstStub(self::NODE_TYPES[$dom->nodeType], $dom->nodeType),\n            'prefix' => $dom->prefix,\n            'localName' => $dom->localName,\n            'namespaceURI' => $dom->namespaceURI,\n            'ownerDocument' => new CutStub($dom->ownerDocument),\n            'parentNode' => new CutStub($dom->parentNode),\n        ];\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castDocument(\\DOMDocument $dom, array $a, Stub $stub, bool $isNested, int $filter = 0)\n    {\n        $a += [\n            'doctype' => $dom->doctype,\n            'implementation' => $dom->implementation,\n            'documentElement' => new CutStub($dom->documentElement),\n            'actualEncoding' => $dom->actualEncoding,\n            'encoding' => $dom->encoding,\n            'xmlEncoding' => $dom->xmlEncoding,\n            'standalone' => $dom->standalone,\n            'xmlStandalone' => $dom->xmlStandalone,\n            'version' => $dom->version,\n            'xmlVersion' => $dom->xmlVersion,\n            'strictErrorChecking' => $dom->strictErrorChecking,\n            'documentURI' => $dom->documentURI ? new LinkStub($dom->documentURI) : $dom->documentURI,\n            'config' => $dom->config,\n            'formatOutput' => $dom->formatOutput,\n            'validateOnParse' => $dom->validateOnParse,\n            'resolveExternals' => $dom->resolveExternals,\n            'preserveWhiteSpace' => $dom->preserveWhiteSpace,\n            'recover' => $dom->recover,\n            'substituteEntities' => $dom->substituteEntities,\n        ];\n\n        if (!($filter & Caster::EXCLUDE_VERBOSE)) {\n            $formatOutput = $dom->formatOutput;\n            $dom->formatOutput = true;\n            $a += [Caster::PREFIX_VIRTUAL.'xml' => $dom->saveXML()];\n            $dom->formatOutput = $formatOutput;\n        }\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castCharacterData(\\DOMCharacterData $dom, array $a, Stub $stub, bool $isNested)\n    {\n        $a += [\n            'data' => $dom->data,\n            'length' => $dom->length,\n        ];\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castAttr(\\DOMAttr $dom, array $a, Stub $stub, bool $isNested)\n    {\n        $a += [\n            'name' => $dom->name,\n            'specified' => $dom->specified,\n            'value' => $dom->value,\n            'ownerElement' => $dom->ownerElement,\n            'schemaTypeInfo' => $dom->schemaTypeInfo,\n        ];\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castElement(\\DOMElement $dom, array $a, Stub $stub, bool $isNested)\n    {\n        $a += [\n            'tagName' => $dom->tagName,\n            'schemaTypeInfo' => $dom->schemaTypeInfo,\n        ];\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castText(\\DOMText $dom, array $a, Stub $stub, bool $isNested)\n    {\n        $a += [\n            'wholeText' => $dom->wholeText,\n        ];\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castDocumentType(\\DOMDocumentType $dom, array $a, Stub $stub, bool $isNested)\n    {\n        $a += [\n            'name' => $dom->name,\n            'entities' => $dom->entities,\n            'notations' => $dom->notations,\n            'publicId' => $dom->publicId,\n            'systemId' => $dom->systemId,\n            'internalSubset' => $dom->internalSubset,\n        ];\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castNotation(\\DOMNotation $dom, array $a, Stub $stub, bool $isNested)\n    {\n        $a += [\n            'publicId' => $dom->publicId,\n            'systemId' => $dom->systemId,\n        ];\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castEntity(\\DOMEntity $dom, array $a, Stub $stub, bool $isNested)\n    {\n        $a += [\n            'publicId' => $dom->publicId,\n            'systemId' => $dom->systemId,\n            'notationName' => $dom->notationName,\n            'actualEncoding' => $dom->actualEncoding,\n            'encoding' => $dom->encoding,\n            'version' => $dom->version,\n        ];\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castProcessingInstruction(\\DOMProcessingInstruction $dom, array $a, Stub $stub, bool $isNested)\n    {\n        $a += [\n            'target' => $dom->target,\n            'data' => $dom->data,\n        ];\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castXPath(\\DOMXPath $dom, array $a, Stub $stub, bool $isNested)\n    {\n        $a += [\n            'document' => $dom->document,\n        ];\n\n        return $a;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/DsCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Ds\\Collection;\nuse Ds\\Map;\nuse Ds\\Pair;\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Casts Ds extension classes to array representation.\n *\n * @author Jáchym Toušek <enumag@gmail.com>\n *\n * @final\n */\nclass DsCaster\n{\n    public static function castCollection(Collection $c, array $a, Stub $stub, bool $isNested): array\n    {\n        $a[Caster::PREFIX_VIRTUAL.'count'] = $c->count();\n        $a[Caster::PREFIX_VIRTUAL.'capacity'] = $c->capacity();\n\n        if (!$c instanceof Map) {\n            $a += $c->toArray();\n        }\n\n        return $a;\n    }\n\n    public static function castMap(Map $c, array $a, Stub $stub, bool $isNested): array\n    {\n        foreach ($c as $k => $v) {\n            $a[] = new DsPairStub($k, $v);\n        }\n\n        return $a;\n    }\n\n    public static function castPair(Pair $c, array $a, Stub $stub, bool $isNested): array\n    {\n        foreach ($c->toArray() as $k => $v) {\n            $a[Caster::PREFIX_VIRTUAL.$k] = $v;\n        }\n\n        return $a;\n    }\n\n    public static function castPairStub(DsPairStub $c, array $a, Stub $stub, bool $isNested): array\n    {\n        if ($isNested) {\n            $stub->class = Pair::class;\n            $stub->value = null;\n            $stub->handle = 0;\n\n            $a = $c->value;\n        }\n\n        return $a;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/DsPairStub.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass DsPairStub extends Stub\n{\n    public function __construct(string|int $key, mixed $value)\n    {\n        $this->value = [\n            Caster::PREFIX_VIRTUAL.'key' => $key,\n            Caster::PREFIX_VIRTUAL.'value' => $value,\n        ];\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/EnumStub.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Represents an enumeration of values.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass EnumStub extends Stub\n{\n    public $dumpKeys = true;\n\n    public function __construct(array $values, bool $dumpKeys = true)\n    {\n        $this->value = $values;\n        $this->dumpKeys = $dumpKeys;\n    }\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/ExceptionCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\ErrorHandler\\Exception\\FlattenException;\nuse Symfony\\Component\\ErrorHandler\\Exception\\SilencedErrorContext;\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\nuse Symfony\\Component\\VarDumper\\Exception\\ThrowingCasterException;\n\n/**\n * Casts common Exception classes to array representation.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n *\n * @final\n */\nclass ExceptionCaster\n{\n    public static int $srcContext = 1;\n    public static bool $traceArgs = true;\n    public static array $errorTypes = [\n        \\E_DEPRECATED => 'E_DEPRECATED',\n        \\E_USER_DEPRECATED => 'E_USER_DEPRECATED',\n        \\E_RECOVERABLE_ERROR => 'E_RECOVERABLE_ERROR',\n        \\E_ERROR => 'E_ERROR',\n        \\E_WARNING => 'E_WARNING',\n        \\E_PARSE => 'E_PARSE',\n        \\E_NOTICE => 'E_NOTICE',\n        \\E_CORE_ERROR => 'E_CORE_ERROR',\n        \\E_CORE_WARNING => 'E_CORE_WARNING',\n        \\E_COMPILE_ERROR => 'E_COMPILE_ERROR',\n        \\E_COMPILE_WARNING => 'E_COMPILE_WARNING',\n        \\E_USER_ERROR => 'E_USER_ERROR',\n        \\E_USER_WARNING => 'E_USER_WARNING',\n        \\E_USER_NOTICE => 'E_USER_NOTICE',\n        \\E_STRICT => 'E_STRICT',\n    ];\n\n    private static array $framesCache = [];\n\n    /**\n     * @return array\n     */\n    public static function castError(\\Error $e, array $a, Stub $stub, bool $isNested, int $filter = 0)\n    {\n        return self::filterExceptionArray($stub->class, $a, \"\\0Error\\0\", $filter);\n    }\n\n    /**\n     * @return array\n     */\n    public static function castException(\\Exception $e, array $a, Stub $stub, bool $isNested, int $filter = 0)\n    {\n        return self::filterExceptionArray($stub->class, $a, \"\\0Exception\\0\", $filter);\n    }\n\n    /**\n     * @return array\n     */\n    public static function castErrorException(\\ErrorException $e, array $a, Stub $stub, bool $isNested)\n    {\n        if (isset($a[$s = Caster::PREFIX_PROTECTED.'severity'], self::$errorTypes[$a[$s]])) {\n            $a[$s] = new ConstStub(self::$errorTypes[$a[$s]], $a[$s]);\n        }\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castThrowingCasterException(ThrowingCasterException $e, array $a, Stub $stub, bool $isNested)\n    {\n        $trace = Caster::PREFIX_VIRTUAL.'trace';\n        $prefix = Caster::PREFIX_PROTECTED;\n        $xPrefix = \"\\0Exception\\0\";\n\n        if (isset($a[$xPrefix.'previous'], $a[$trace]) && $a[$xPrefix.'previous'] instanceof \\Exception) {\n            $b = (array) $a[$xPrefix.'previous'];\n            $class = get_debug_type($a[$xPrefix.'previous']);\n            self::traceUnshift($b[$xPrefix.'trace'], $class, $b[$prefix.'file'], $b[$prefix.'line']);\n            $a[$trace] = new TraceStub($b[$xPrefix.'trace'], false, 0, -\\count($a[$trace]->value));\n        }\n\n        unset($a[$xPrefix.'previous'], $a[$prefix.'code'], $a[$prefix.'file'], $a[$prefix.'line']);\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castSilencedErrorContext(SilencedErrorContext $e, array $a, Stub $stub, bool $isNested)\n    {\n        $sPrefix = \"\\0\".SilencedErrorContext::class.\"\\0\";\n\n        if (!isset($a[$s = $sPrefix.'severity'])) {\n            return $a;\n        }\n\n        if (isset(self::$errorTypes[$a[$s]])) {\n            $a[$s] = new ConstStub(self::$errorTypes[$a[$s]], $a[$s]);\n        }\n\n        $trace = [[\n            'file' => $a[$sPrefix.'file'],\n            'line' => $a[$sPrefix.'line'],\n        ]];\n\n        if (isset($a[$sPrefix.'trace'])) {\n            $trace = array_merge($trace, $a[$sPrefix.'trace']);\n        }\n\n        unset($a[$sPrefix.'file'], $a[$sPrefix.'line'], $a[$sPrefix.'trace']);\n        $a[Caster::PREFIX_VIRTUAL.'trace'] = new TraceStub($trace, self::$traceArgs);\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castTraceStub(TraceStub $trace, array $a, Stub $stub, bool $isNested)\n    {\n        if (!$isNested) {\n            return $a;\n        }\n        $stub->class = '';\n        $stub->handle = 0;\n        $frames = $trace->value;\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        $a = [];\n        $j = \\count($frames);\n        if (0 > $i = $trace->sliceOffset) {\n            $i = max(0, $j + $i);\n        }\n        if (!isset($trace->value[$i])) {\n            return [];\n        }\n        $lastCall = isset($frames[$i]['function']) ? (isset($frames[$i]['class']) ? $frames[0]['class'].$frames[$i]['type'] : '').$frames[$i]['function'].'()' : '';\n        $frames[] = ['function' => ''];\n        $collapse = false;\n\n        for ($j += $trace->numberingOffset - $i++; isset($frames[$i]); ++$i, --$j) {\n            $f = $frames[$i];\n            $call = isset($f['function']) ? (isset($f['class']) ? $f['class'].$f['type'] : '').$f['function'] : '???';\n\n            $frame = new FrameStub(\n                [\n                    'object' => $f['object'] ?? null,\n                    'class' => $f['class'] ?? null,\n                    'type' => $f['type'] ?? null,\n                    'function' => $f['function'] ?? null,\n                ] + $frames[$i - 1],\n                false,\n                true\n            );\n            $f = self::castFrameStub($frame, [], $frame, true);\n            if (isset($f[$prefix.'src'])) {\n                foreach ($f[$prefix.'src']->value as $label => $frame) {\n                    if (str_starts_with($label, \"\\0~collapse=0\")) {\n                        if ($collapse) {\n                            $label = substr_replace($label, '1', 11, 1);\n                        } else {\n                            $collapse = true;\n                        }\n                    }\n                    $label = substr_replace($label, \"title=Stack level $j.&\", 2, 0);\n                }\n                $f = $frames[$i - 1];\n                if ($trace->keepArgs && !empty($f['args']) && $frame instanceof EnumStub) {\n                    $frame->value['arguments'] = new ArgsStub($f['args'], $f['function'] ?? null, $f['class'] ?? null);\n                }\n            } elseif ('???' !== $lastCall) {\n                $label = new ClassStub($lastCall);\n                if (isset($label->attr['ellipsis'])) {\n                    $label->attr['ellipsis'] += 2;\n                    $label = substr_replace($prefix, \"ellipsis-type=class&ellipsis={$label->attr['ellipsis']}&ellipsis-tail=1&title=Stack level $j.\", 2, 0).$label->value.'()';\n                } else {\n                    $label = substr_replace($prefix, \"title=Stack level $j.\", 2, 0).$label->value.'()';\n                }\n            } else {\n                $label = substr_replace($prefix, \"title=Stack level $j.\", 2, 0).$lastCall;\n            }\n            $a[substr_replace($label, sprintf('separator=%s&', $frame instanceof EnumStub ? ' ' : ':'), 2, 0)] = $frame;\n\n            $lastCall = $call;\n        }\n        if (null !== $trace->sliceLength) {\n            $a = \\array_slice($a, 0, $trace->sliceLength, true);\n        }\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castFrameStub(FrameStub $frame, array $a, Stub $stub, bool $isNested)\n    {\n        if (!$isNested) {\n            return $a;\n        }\n        $f = $frame->value;\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        if (isset($f['file'], $f['line'])) {\n            $cacheKey = $f;\n            unset($cacheKey['object'], $cacheKey['args']);\n            $cacheKey[] = self::$srcContext;\n            $cacheKey = implode('-', $cacheKey);\n\n            if (isset(self::$framesCache[$cacheKey])) {\n                $a[$prefix.'src'] = self::$framesCache[$cacheKey];\n            } else {\n                if (preg_match('/\\((\\d+)\\)(?:\\([\\da-f]{32}\\))? : (?:eval\\(\\)\\'d code|runtime-created function)$/', $f['file'], $match)) {\n                    $f['file'] = substr($f['file'], 0, -\\strlen($match[0]));\n                    $f['line'] = (int) $match[1];\n                }\n                $src = $f['line'];\n                $srcKey = $f['file'];\n                $ellipsis = new LinkStub($srcKey, 0);\n                $srcAttr = 'collapse='.(int) $ellipsis->inVendor;\n                $ellipsisTail = $ellipsis->attr['ellipsis-tail'] ?? 0;\n                $ellipsis = $ellipsis->attr['ellipsis'] ?? 0;\n\n                if (is_file($f['file']) && 0 <= self::$srcContext) {\n                    if (!empty($f['class']) && (is_subclass_of($f['class'], 'Twig\\Template') || is_subclass_of($f['class'], 'Twig_Template')) && method_exists($f['class'], 'getDebugInfo')) {\n                        $template = null;\n                        if (isset($f['object'])) {\n                            $template = $f['object'];\n                        } elseif ((new \\ReflectionClass($f['class']))->isInstantiable()) {\n                            $template = unserialize(sprintf('O:%d:\"%s\":0:{}', \\strlen($f['class']), $f['class']));\n                        }\n                        if (null !== $template) {\n                            $ellipsis = 0;\n                            $templateSrc = method_exists($template, 'getSourceContext') ? $template->getSourceContext()->getCode() : (method_exists($template, 'getSource') ? $template->getSource() : '');\n                            $templateInfo = $template->getDebugInfo();\n                            if (isset($templateInfo[$f['line']])) {\n                                if (!method_exists($template, 'getSourceContext') || !is_file($templatePath = $template->getSourceContext()->getPath())) {\n                                    $templatePath = null;\n                                }\n                                if ($templateSrc) {\n                                    $src = self::extractSource($templateSrc, $templateInfo[$f['line']], self::$srcContext, 'twig', $templatePath, $f);\n                                    $srcKey = ($templatePath ?: $template->getTemplateName()).':'.$templateInfo[$f['line']];\n                                }\n                            }\n                        }\n                    }\n                    if ($srcKey == $f['file']) {\n                        $src = self::extractSource(file_get_contents($f['file']), $f['line'], self::$srcContext, 'php', $f['file'], $f);\n                        $srcKey .= ':'.$f['line'];\n                        if ($ellipsis) {\n                            $ellipsis += 1 + \\strlen($f['line']);\n                        }\n                    }\n                    $srcAttr .= sprintf('&separator= &file=%s&line=%d', rawurlencode($f['file']), $f['line']);\n                } else {\n                    $srcAttr .= '&separator=:';\n                }\n                $srcAttr .= $ellipsis ? '&ellipsis-type=path&ellipsis='.$ellipsis.'&ellipsis-tail='.$ellipsisTail : '';\n                self::$framesCache[$cacheKey] = $a[$prefix.'src'] = new EnumStub([\"\\0~$srcAttr\\0$srcKey\" => $src]);\n            }\n        }\n\n        unset($a[$prefix.'args'], $a[$prefix.'line'], $a[$prefix.'file']);\n        if ($frame->inTraceStub) {\n            unset($a[$prefix.'class'], $a[$prefix.'type'], $a[$prefix.'function']);\n        }\n        foreach ($a as $k => $v) {\n            if (!$v) {\n                unset($a[$k]);\n            }\n        }\n        if ($frame->keepArgs && !empty($f['args'])) {\n            $a[$prefix.'arguments'] = new ArgsStub($f['args'], $f['function'], $f['class']);\n        }\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castFlattenException(FlattenException $e, array $a, Stub $stub, bool $isNested)\n    {\n        if ($isNested) {\n            $k = sprintf(Caster::PATTERN_PRIVATE, FlattenException::class, 'traceAsString');\n            $a[$k] = new CutStub($a[$k]);\n        }\n\n        return $a;\n    }\n\n    private static function filterExceptionArray(string $xClass, array $a, string $xPrefix, int $filter): array\n    {\n        if (isset($a[$xPrefix.'trace'])) {\n            $trace = $a[$xPrefix.'trace'];\n            unset($a[$xPrefix.'trace']); // Ensures the trace is always last\n        } else {\n            $trace = [];\n        }\n\n        if (!($filter & Caster::EXCLUDE_VERBOSE) && $trace) {\n            if (isset($a[Caster::PREFIX_PROTECTED.'file'], $a[Caster::PREFIX_PROTECTED.'line'])) {\n                self::traceUnshift($trace, $xClass, $a[Caster::PREFIX_PROTECTED.'file'], $a[Caster::PREFIX_PROTECTED.'line']);\n            }\n            $a[Caster::PREFIX_VIRTUAL.'trace'] = new TraceStub($trace, self::$traceArgs);\n        }\n        if (empty($a[$xPrefix.'previous'])) {\n            unset($a[$xPrefix.'previous']);\n        }\n        unset($a[$xPrefix.'string'], $a[Caster::PREFIX_DYNAMIC.'xdebug_message']);\n\n        if (isset($a[Caster::PREFIX_PROTECTED.'message']) && str_contains($a[Caster::PREFIX_PROTECTED.'message'], \"@anonymous\\0\")) {\n            $a[Caster::PREFIX_PROTECTED.'message'] = preg_replace_callback('/[a-zA-Z_\\x7f-\\xff][\\\\\\\\a-zA-Z0-9_\\x7f-\\xff]*+@anonymous\\x00.*?\\.php(?:0x?|:[0-9]++\\$)[0-9a-fA-F]++/', fn ($m) => class_exists($m[0], false) ? (get_parent_class($m[0]) ?: key(class_implements($m[0])) ?: 'class').'@anonymous' : $m[0], $a[Caster::PREFIX_PROTECTED.'message']);\n        }\n\n        if (isset($a[Caster::PREFIX_PROTECTED.'file'], $a[Caster::PREFIX_PROTECTED.'line'])) {\n            $a[Caster::PREFIX_PROTECTED.'file'] = new LinkStub($a[Caster::PREFIX_PROTECTED.'file'], $a[Caster::PREFIX_PROTECTED.'line']);\n        }\n\n        return $a;\n    }\n\n    private static function traceUnshift(array &$trace, ?string $class, string $file, int $line): void\n    {\n        if (isset($trace[0]['file'], $trace[0]['line']) && $trace[0]['file'] === $file && $trace[0]['line'] === $line) {\n            return;\n        }\n        array_unshift($trace, [\n            'function' => $class ? 'new '.$class : null,\n            'file' => $file,\n            'line' => $line,\n        ]);\n    }\n\n    private static function extractSource(string $srcLines, int $line, int $srcContext, string $lang, ?string $file, array $frame): EnumStub\n    {\n        $srcLines = explode(\"\\n\", $srcLines);\n        $src = [];\n\n        for ($i = $line - 1 - $srcContext; $i <= $line - 1 + $srcContext; ++$i) {\n            $src[] = ($srcLines[$i] ?? '').\"\\n\";\n        }\n\n        if ($frame['function'] ?? false) {\n            $stub = new CutStub(new \\stdClass());\n            $stub->class = (isset($frame['class']) ? $frame['class'].$frame['type'] : '').$frame['function'];\n            $stub->type = Stub::TYPE_OBJECT;\n            $stub->attr['cut_hash'] = true;\n            $stub->attr['file'] = $frame['file'];\n            $stub->attr['line'] = $frame['line'];\n\n            try {\n                $caller = isset($frame['class']) ? new \\ReflectionMethod($frame['class'], $frame['function']) : new \\ReflectionFunction($frame['function']);\n                $stub->class .= ReflectionCaster::getSignature(ReflectionCaster::castFunctionAbstract($caller, [], $stub, true, Caster::EXCLUDE_VERBOSE));\n\n                if ($f = $caller->getFileName()) {\n                    $stub->attr['file'] = $f;\n                    $stub->attr['line'] = $caller->getStartLine();\n                }\n            } catch (\\ReflectionException) {\n                // ignore fake class/function\n            }\n\n            $srcLines = [\"\\0~separator=\\0\" => $stub];\n        } else {\n            $stub = null;\n            $srcLines = [];\n        }\n\n        $ltrim = 0;\n        do {\n            $pad = null;\n            for ($i = $srcContext << 1; $i >= 0; --$i) {\n                if (isset($src[$i][$ltrim]) && \"\\r\" !== ($c = $src[$i][$ltrim]) && \"\\n\" !== $c) {\n                    $pad ??= $c;\n                    if ((' ' !== $c && \"\\t\" !== $c) || $pad !== $c) {\n                        break;\n                    }\n                }\n            }\n            ++$ltrim;\n        } while (0 > $i && null !== $pad);\n\n        --$ltrim;\n\n        foreach ($src as $i => $c) {\n            if ($ltrim) {\n                $c = isset($c[$ltrim]) && \"\\r\" !== $c[$ltrim] ? substr($c, $ltrim) : ltrim($c, \" \\t\");\n            }\n            $c = substr($c, 0, -1);\n            if ($i !== $srcContext) {\n                $c = new ConstStub('default', $c);\n            } else {\n                $c = new ConstStub($c, $stub ? 'in '.$stub->class : '');\n                if (null !== $file) {\n                    $c->attr['file'] = $file;\n                    $c->attr['line'] = $line;\n                }\n            }\n            $c->attr['lang'] = $lang;\n            $srcLines[sprintf(\"\\0~separator=› &%d\\0\", $i + $line - $srcContext)] = $c;\n        }\n\n        return new EnumStub($srcLines);\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/FFICaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse FFI\\CData;\nuse FFI\\CType;\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Casts FFI extension classes to array representation.\n *\n * @author Nesmeyanov Kirill <nesk@xakep.ru>\n */\nfinal class FFICaster\n{\n    /**\n     * In case of \"char*\" contains a string, the length of which depends on\n     * some other parameter, then during the generation of the string it is\n     * possible to go beyond the allowable memory area.\n     *\n     * This restriction serves to ensure that processing does not take\n     * up the entire allowable PHP memory limit.\n     */\n    private const MAX_STRING_LENGTH = 255;\n\n    public static function castCTypeOrCData(CData|CType $data, array $args, Stub $stub): array\n    {\n        if ($data instanceof CType) {\n            $type = $data;\n            $data = null;\n        } else {\n            $type = \\FFI::typeof($data);\n        }\n\n        $stub->class = sprintf('%s<%s> size %d align %d', ($data ?? $type)::class, $type->getName(), $type->getSize(), $type->getAlignment());\n\n        return match ($type->getKind()) {\n            CType::TYPE_FLOAT,\n            CType::TYPE_DOUBLE,\n            \\defined('\\FFI\\CType::TYPE_LONGDOUBLE') ? CType::TYPE_LONGDOUBLE : -1,\n            CType::TYPE_UINT8,\n            CType::TYPE_SINT8,\n            CType::TYPE_UINT16,\n            CType::TYPE_SINT16,\n            CType::TYPE_UINT32,\n            CType::TYPE_SINT32,\n            CType::TYPE_UINT64,\n            CType::TYPE_SINT64,\n            CType::TYPE_BOOL,\n            CType::TYPE_CHAR,\n            CType::TYPE_ENUM => null !== $data ? [Caster::PREFIX_VIRTUAL.'cdata' => $data->cdata] : [],\n            CType::TYPE_POINTER => self::castFFIPointer($stub, $type, $data),\n            CType::TYPE_STRUCT => self::castFFIStructLike($type, $data),\n            CType::TYPE_FUNC => self::castFFIFunction($stub, $type),\n            default => $args,\n        };\n    }\n\n    private static function castFFIFunction(Stub $stub, CType $type): array\n    {\n        $arguments = [];\n\n        for ($i = 0, $count = $type->getFuncParameterCount(); $i < $count; ++$i) {\n            $param = $type->getFuncParameterType($i);\n\n            $arguments[] = $param->getName();\n        }\n\n        $abi = match ($type->getFuncABI()) {\n            CType::ABI_DEFAULT,\n            CType::ABI_CDECL => '[cdecl]',\n            CType::ABI_FASTCALL => '[fastcall]',\n            CType::ABI_THISCALL => '[thiscall]',\n            CType::ABI_STDCALL => '[stdcall]',\n            CType::ABI_PASCAL => '[pascal]',\n            CType::ABI_REGISTER => '[register]',\n            CType::ABI_MS => '[ms]',\n            CType::ABI_SYSV => '[sysv]',\n            CType::ABI_VECTORCALL => '[vectorcall]',\n            default => '[unknown abi]'\n        };\n\n        $returnType = $type->getFuncReturnType();\n\n        $stub->class = $abi.' callable('.implode(', ', $arguments).'): '\n            .$returnType->getName();\n\n        return [Caster::PREFIX_VIRTUAL.'returnType' => $returnType];\n    }\n\n    private static function castFFIPointer(Stub $stub, CType $type, CData $data = null): array\n    {\n        $ptr = $type->getPointerType();\n\n        if (null === $data) {\n            return [Caster::PREFIX_VIRTUAL.'0' => $ptr];\n        }\n\n        return match ($ptr->getKind()) {\n            CType::TYPE_CHAR => [Caster::PREFIX_VIRTUAL.'cdata' => self::castFFIStringValue($data)],\n            CType::TYPE_FUNC => self::castFFIFunction($stub, $ptr),\n            default => [Caster::PREFIX_VIRTUAL.'cdata' => $data[0]],\n        };\n    }\n\n    private static function castFFIStringValue(CData $data): string|CutStub\n    {\n        $result = [];\n\n        for ($i = 0; $i < self::MAX_STRING_LENGTH; ++$i) {\n            $result[$i] = $data[$i];\n\n            if (\"\\0\" === $result[$i]) {\n                return implode('', $result);\n            }\n        }\n\n        $string = implode('', $result);\n        $stub = new CutStub($string);\n        $stub->cut = -1;\n        $stub->value = $string;\n\n        return $stub;\n    }\n\n    private static function castFFIStructLike(CType $type, CData $data = null): array\n    {\n        $isUnion = ($type->getAttributes() & CType::ATTR_UNION) === CType::ATTR_UNION;\n\n        $result = [];\n\n        foreach ($type->getStructFieldNames() as $name) {\n            $field = $type->getStructFieldType($name);\n\n            // Retrieving the value of a field from a union containing\n            // a pointer is not a safe operation, because may contain\n            // incorrect data.\n            $isUnsafe = $isUnion && CType::TYPE_POINTER === $field->getKind();\n\n            if ($isUnsafe) {\n                $result[Caster::PREFIX_VIRTUAL.$name.'?'] = $field;\n            } elseif (null === $data) {\n                $result[Caster::PREFIX_VIRTUAL.$name] = $field;\n            } else {\n                $fieldName = $data->{$name} instanceof CData ? '' : $field->getName().' ';\n                $result[Caster::PREFIX_VIRTUAL.$fieldName.$name] = $data->{$name};\n            }\n        }\n\n        return $result;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/FiberCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Casts Fiber related classes to array representation.\n *\n * @author Grégoire Pineau <lyrixx@lyrixx.info>\n */\nfinal class FiberCaster\n{\n    /**\n     * @return array\n     */\n    public static function castFiber(\\Fiber $fiber, array $a, Stub $stub, bool $isNested, int $filter = 0)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        if ($fiber->isTerminated()) {\n            $status = 'terminated';\n        } elseif ($fiber->isRunning()) {\n            $status = 'running';\n        } elseif ($fiber->isSuspended()) {\n            $status = 'suspended';\n        } elseif ($fiber->isStarted()) {\n            $status = 'started';\n        } else {\n            $status = 'not started';\n        }\n\n        $a[$prefix.'status'] = $status;\n\n        return $a;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/FrameStub.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\n/**\n * Represents a single backtrace frame as returned by debug_backtrace() or Exception->getTrace().\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass FrameStub extends EnumStub\n{\n    public $keepArgs;\n    public $inTraceStub;\n\n    public function __construct(array $frame, bool $keepArgs = true, bool $inTraceStub = false)\n    {\n        $this->value = $frame;\n        $this->keepArgs = $keepArgs;\n        $this->inTraceStub = $inTraceStub;\n    }\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/GmpCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Casts GMP objects to array representation.\n *\n * @author Hamza Amrouche <hamza.simperfit@gmail.com>\n * @author Nicolas Grekas <p@tchwork.com>\n *\n * @final\n */\nclass GmpCaster\n{\n    public static function castGmp(\\GMP $gmp, array $a, Stub $stub, bool $isNested, int $filter): array\n    {\n        $a[Caster::PREFIX_VIRTUAL.'value'] = new ConstStub(gmp_strval($gmp), gmp_strval($gmp));\n\n        return $a;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/ImagineCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Imagine\\Image\\ImageInterface;\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * @author Grégoire Pineau <lyrixx@lyrixx.info>\n */\nfinal class ImagineCaster\n{\n    public static function castImage(ImageInterface $c, array $a, Stub $stub, bool $isNested): array\n    {\n        $imgData = $c->get('png');\n        if (\\strlen($imgData) > 1 * 1000 * 1000) {\n            $a += [\n                Caster::PREFIX_VIRTUAL.'image' => new ConstStub($c->getSize()),\n            ];\n        } else {\n            $a += [\n                Caster::PREFIX_VIRTUAL.'image' => new ImgStub($imgData, 'image/png', $c->getSize()),\n            ];\n        }\n\n        return $a;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/ImgStub.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\n/**\n * @author Grégoire Pineau <lyrixx@lyrixx.info>\n */\nclass ImgStub extends ConstStub\n{\n    public function __construct(string $data, string $contentType, string $size = '')\n    {\n        $this->value = '';\n        $this->attr['img-data'] = $data;\n        $this->attr['img-size'] = $size;\n        $this->attr['content-type'] = $contentType;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/IntlCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * @author Nicolas Grekas <p@tchwork.com>\n * @author Jan Schädlich <jan.schaedlich@sensiolabs.de>\n *\n * @final\n */\nclass IntlCaster\n{\n    /**\n     * @return array\n     */\n    public static function castMessageFormatter(\\MessageFormatter $c, array $a, Stub $stub, bool $isNested)\n    {\n        $a += [\n            Caster::PREFIX_VIRTUAL.'locale' => $c->getLocale(),\n            Caster::PREFIX_VIRTUAL.'pattern' => $c->getPattern(),\n        ];\n\n        return self::castError($c, $a);\n    }\n\n    /**\n     * @return array\n     */\n    public static function castNumberFormatter(\\NumberFormatter $c, array $a, Stub $stub, bool $isNested, int $filter = 0)\n    {\n        $a += [\n            Caster::PREFIX_VIRTUAL.'locale' => $c->getLocale(),\n            Caster::PREFIX_VIRTUAL.'pattern' => $c->getPattern(),\n        ];\n\n        if ($filter & Caster::EXCLUDE_VERBOSE) {\n            $stub->cut += 3;\n\n            return self::castError($c, $a);\n        }\n\n        $a += [\n            Caster::PREFIX_VIRTUAL.'attributes' => new EnumStub(\n                [\n                    'PARSE_INT_ONLY' => $c->getAttribute(\\NumberFormatter::PARSE_INT_ONLY),\n                    'GROUPING_USED' => $c->getAttribute(\\NumberFormatter::GROUPING_USED),\n                    'DECIMAL_ALWAYS_SHOWN' => $c->getAttribute(\\NumberFormatter::DECIMAL_ALWAYS_SHOWN),\n                    'MAX_INTEGER_DIGITS' => $c->getAttribute(\\NumberFormatter::MAX_INTEGER_DIGITS),\n                    'MIN_INTEGER_DIGITS' => $c->getAttribute(\\NumberFormatter::MIN_INTEGER_DIGITS),\n                    'INTEGER_DIGITS' => $c->getAttribute(\\NumberFormatter::INTEGER_DIGITS),\n                    'MAX_FRACTION_DIGITS' => $c->getAttribute(\\NumberFormatter::MAX_FRACTION_DIGITS),\n                    'MIN_FRACTION_DIGITS' => $c->getAttribute(\\NumberFormatter::MIN_FRACTION_DIGITS),\n                    'FRACTION_DIGITS' => $c->getAttribute(\\NumberFormatter::FRACTION_DIGITS),\n                    'MULTIPLIER' => $c->getAttribute(\\NumberFormatter::MULTIPLIER),\n                    'GROUPING_SIZE' => $c->getAttribute(\\NumberFormatter::GROUPING_SIZE),\n                    'ROUNDING_MODE' => $c->getAttribute(\\NumberFormatter::ROUNDING_MODE),\n                    'ROUNDING_INCREMENT' => $c->getAttribute(\\NumberFormatter::ROUNDING_INCREMENT),\n                    'FORMAT_WIDTH' => $c->getAttribute(\\NumberFormatter::FORMAT_WIDTH),\n                    'PADDING_POSITION' => $c->getAttribute(\\NumberFormatter::PADDING_POSITION),\n                    'SECONDARY_GROUPING_SIZE' => $c->getAttribute(\\NumberFormatter::SECONDARY_GROUPING_SIZE),\n                    'SIGNIFICANT_DIGITS_USED' => $c->getAttribute(\\NumberFormatter::SIGNIFICANT_DIGITS_USED),\n                    'MIN_SIGNIFICANT_DIGITS' => $c->getAttribute(\\NumberFormatter::MIN_SIGNIFICANT_DIGITS),\n                    'MAX_SIGNIFICANT_DIGITS' => $c->getAttribute(\\NumberFormatter::MAX_SIGNIFICANT_DIGITS),\n                    'LENIENT_PARSE' => $c->getAttribute(\\NumberFormatter::LENIENT_PARSE),\n                ]\n            ),\n            Caster::PREFIX_VIRTUAL.'text_attributes' => new EnumStub(\n                [\n                    'POSITIVE_PREFIX' => $c->getTextAttribute(\\NumberFormatter::POSITIVE_PREFIX),\n                    'POSITIVE_SUFFIX' => $c->getTextAttribute(\\NumberFormatter::POSITIVE_SUFFIX),\n                    'NEGATIVE_PREFIX' => $c->getTextAttribute(\\NumberFormatter::NEGATIVE_PREFIX),\n                    'NEGATIVE_SUFFIX' => $c->getTextAttribute(\\NumberFormatter::NEGATIVE_SUFFIX),\n                    'PADDING_CHARACTER' => $c->getTextAttribute(\\NumberFormatter::PADDING_CHARACTER),\n                    'CURRENCY_CODE' => $c->getTextAttribute(\\NumberFormatter::CURRENCY_CODE),\n                    'DEFAULT_RULESET' => $c->getTextAttribute(\\NumberFormatter::DEFAULT_RULESET),\n                    'PUBLIC_RULESETS' => $c->getTextAttribute(\\NumberFormatter::PUBLIC_RULESETS),\n                ]\n            ),\n            Caster::PREFIX_VIRTUAL.'symbols' => new EnumStub(\n                [\n                    'DECIMAL_SEPARATOR_SYMBOL' => $c->getSymbol(\\NumberFormatter::DECIMAL_SEPARATOR_SYMBOL),\n                    'GROUPING_SEPARATOR_SYMBOL' => $c->getSymbol(\\NumberFormatter::GROUPING_SEPARATOR_SYMBOL),\n                    'PATTERN_SEPARATOR_SYMBOL' => $c->getSymbol(\\NumberFormatter::PATTERN_SEPARATOR_SYMBOL),\n                    'PERCENT_SYMBOL' => $c->getSymbol(\\NumberFormatter::PERCENT_SYMBOL),\n                    'ZERO_DIGIT_SYMBOL' => $c->getSymbol(\\NumberFormatter::ZERO_DIGIT_SYMBOL),\n                    'DIGIT_SYMBOL' => $c->getSymbol(\\NumberFormatter::DIGIT_SYMBOL),\n                    'MINUS_SIGN_SYMBOL' => $c->getSymbol(\\NumberFormatter::MINUS_SIGN_SYMBOL),\n                    'PLUS_SIGN_SYMBOL' => $c->getSymbol(\\NumberFormatter::PLUS_SIGN_SYMBOL),\n                    'CURRENCY_SYMBOL' => $c->getSymbol(\\NumberFormatter::CURRENCY_SYMBOL),\n                    'INTL_CURRENCY_SYMBOL' => $c->getSymbol(\\NumberFormatter::INTL_CURRENCY_SYMBOL),\n                    'MONETARY_SEPARATOR_SYMBOL' => $c->getSymbol(\\NumberFormatter::MONETARY_SEPARATOR_SYMBOL),\n                    'EXPONENTIAL_SYMBOL' => $c->getSymbol(\\NumberFormatter::EXPONENTIAL_SYMBOL),\n                    'PERMILL_SYMBOL' => $c->getSymbol(\\NumberFormatter::PERMILL_SYMBOL),\n                    'PAD_ESCAPE_SYMBOL' => $c->getSymbol(\\NumberFormatter::PAD_ESCAPE_SYMBOL),\n                    'INFINITY_SYMBOL' => $c->getSymbol(\\NumberFormatter::INFINITY_SYMBOL),\n                    'NAN_SYMBOL' => $c->getSymbol(\\NumberFormatter::NAN_SYMBOL),\n                    'SIGNIFICANT_DIGIT_SYMBOL' => $c->getSymbol(\\NumberFormatter::SIGNIFICANT_DIGIT_SYMBOL),\n                    'MONETARY_GROUPING_SEPARATOR_SYMBOL' => $c->getSymbol(\\NumberFormatter::MONETARY_GROUPING_SEPARATOR_SYMBOL),\n                ]\n            ),\n        ];\n\n        return self::castError($c, $a);\n    }\n\n    /**\n     * @return array\n     */\n    public static function castIntlTimeZone(\\IntlTimeZone $c, array $a, Stub $stub, bool $isNested)\n    {\n        $a += [\n            Caster::PREFIX_VIRTUAL.'display_name' => $c->getDisplayName(),\n            Caster::PREFIX_VIRTUAL.'id' => $c->getID(),\n            Caster::PREFIX_VIRTUAL.'raw_offset' => $c->getRawOffset(),\n        ];\n\n        if ($c->useDaylightTime()) {\n            $a += [\n                Caster::PREFIX_VIRTUAL.'dst_savings' => $c->getDSTSavings(),\n            ];\n        }\n\n        return self::castError($c, $a);\n    }\n\n    /**\n     * @return array\n     */\n    public static function castIntlCalendar(\\IntlCalendar $c, array $a, Stub $stub, bool $isNested, int $filter = 0)\n    {\n        $a += [\n            Caster::PREFIX_VIRTUAL.'type' => $c->getType(),\n            Caster::PREFIX_VIRTUAL.'first_day_of_week' => $c->getFirstDayOfWeek(),\n            Caster::PREFIX_VIRTUAL.'minimal_days_in_first_week' => $c->getMinimalDaysInFirstWeek(),\n            Caster::PREFIX_VIRTUAL.'repeated_wall_time_option' => $c->getRepeatedWallTimeOption(),\n            Caster::PREFIX_VIRTUAL.'skipped_wall_time_option' => $c->getSkippedWallTimeOption(),\n            Caster::PREFIX_VIRTUAL.'time' => $c->getTime(),\n            Caster::PREFIX_VIRTUAL.'in_daylight_time' => $c->inDaylightTime(),\n            Caster::PREFIX_VIRTUAL.'is_lenient' => $c->isLenient(),\n            Caster::PREFIX_VIRTUAL.'time_zone' => ($filter & Caster::EXCLUDE_VERBOSE) ? new CutStub($c->getTimeZone()) : $c->getTimeZone(),\n        ];\n\n        return self::castError($c, $a);\n    }\n\n    /**\n     * @return array\n     */\n    public static function castIntlDateFormatter(\\IntlDateFormatter $c, array $a, Stub $stub, bool $isNested, int $filter = 0)\n    {\n        $a += [\n            Caster::PREFIX_VIRTUAL.'locale' => $c->getLocale(),\n            Caster::PREFIX_VIRTUAL.'pattern' => $c->getPattern(),\n            Caster::PREFIX_VIRTUAL.'calendar' => $c->getCalendar(),\n            Caster::PREFIX_VIRTUAL.'time_zone_id' => $c->getTimeZoneId(),\n            Caster::PREFIX_VIRTUAL.'time_type' => $c->getTimeType(),\n            Caster::PREFIX_VIRTUAL.'date_type' => $c->getDateType(),\n            Caster::PREFIX_VIRTUAL.'calendar_object' => ($filter & Caster::EXCLUDE_VERBOSE) ? new CutStub($c->getCalendarObject()) : $c->getCalendarObject(),\n            Caster::PREFIX_VIRTUAL.'time_zone' => ($filter & Caster::EXCLUDE_VERBOSE) ? new CutStub($c->getTimeZone()) : $c->getTimeZone(),\n        ];\n\n        return self::castError($c, $a);\n    }\n\n    private static function castError(object $c, array $a): array\n    {\n        if ($errorCode = $c->getErrorCode()) {\n            $a += [\n                Caster::PREFIX_VIRTUAL.'error_code' => $errorCode,\n                Caster::PREFIX_VIRTUAL.'error_message' => $c->getErrorMessage(),\n            ];\n        }\n\n        return $a;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/LinkStub.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\n/**\n * Represents a file or a URL.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass LinkStub extends ConstStub\n{\n    public $inVendor = false;\n\n    private static array $vendorRoots;\n    private static array $composerRoots = [];\n\n    public function __construct(string $label, int $line = 0, string $href = null)\n    {\n        $this->value = $label;\n\n        if (!\\is_string($href ??= $label)) {\n            return;\n        }\n        if (str_starts_with($href, 'file://')) {\n            if ($href === $label) {\n                $label = substr($label, 7);\n            }\n            $href = substr($href, 7);\n        } elseif (str_contains($href, '://')) {\n            $this->attr['href'] = $href;\n\n            return;\n        }\n        if (!is_file($href)) {\n            return;\n        }\n        if ($line) {\n            $this->attr['line'] = $line;\n        }\n        if ($label !== $this->attr['file'] = realpath($href) ?: $href) {\n            return;\n        }\n        if ($composerRoot = $this->getComposerRoot($href, $this->inVendor)) {\n            $this->attr['ellipsis'] = \\strlen($href) - \\strlen($composerRoot) + 1;\n            $this->attr['ellipsis-type'] = 'path';\n            $this->attr['ellipsis-tail'] = 1 + ($this->inVendor ? 2 + \\strlen(implode('', \\array_slice(explode(\\DIRECTORY_SEPARATOR, substr($href, 1 - $this->attr['ellipsis'])), 0, 2))) : 0);\n        } elseif (3 < \\count($ellipsis = explode(\\DIRECTORY_SEPARATOR, $href))) {\n            $this->attr['ellipsis'] = 2 + \\strlen(implode('', \\array_slice($ellipsis, -2)));\n            $this->attr['ellipsis-type'] = 'path';\n            $this->attr['ellipsis-tail'] = 1;\n        }\n    }\n\n    private function getComposerRoot(string $file, bool &$inVendor): string|false\n    {\n        if (!isset(self::$vendorRoots)) {\n            self::$vendorRoots = [];\n\n            foreach (get_declared_classes() as $class) {\n                if ('C' === $class[0] && str_starts_with($class, 'ComposerAutoloaderInit')) {\n                    $r = new \\ReflectionClass($class);\n                    $v = \\dirname($r->getFileName(), 2);\n                    if (is_file($v.'/composer/installed.json')) {\n                        self::$vendorRoots[] = $v.\\DIRECTORY_SEPARATOR;\n                    }\n                }\n            }\n        }\n        $inVendor = false;\n\n        if (isset(self::$composerRoots[$dir = \\dirname($file)])) {\n            return self::$composerRoots[$dir];\n        }\n\n        foreach (self::$vendorRoots as $root) {\n            if ($inVendor = str_starts_with($file, $root)) {\n                return $root;\n            }\n        }\n\n        $parent = $dir;\n        while (!@is_file($parent.'/composer.json')) {\n            if (!@file_exists($parent)) {\n                // open_basedir restriction in effect\n                break;\n            }\n            if ($parent === \\dirname($parent)) {\n                return self::$composerRoots[$dir] = false;\n            }\n\n            $parent = \\dirname($parent);\n        }\n\n        return self::$composerRoots[$dir] = $parent.\\DIRECTORY_SEPARATOR;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/MemcachedCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * @author Jan Schädlich <jan.schaedlich@sensiolabs.de>\n *\n * @final\n */\nclass MemcachedCaster\n{\n    private static array $optionConstants;\n    private static array $defaultOptions;\n\n    /**\n     * @return array\n     */\n    public static function castMemcached(\\Memcached $c, array $a, Stub $stub, bool $isNested)\n    {\n        $a += [\n            Caster::PREFIX_VIRTUAL.'servers' => $c->getServerList(),\n            Caster::PREFIX_VIRTUAL.'options' => new EnumStub(\n                self::getNonDefaultOptions($c)\n            ),\n        ];\n\n        return $a;\n    }\n\n    private static function getNonDefaultOptions(\\Memcached $c): array\n    {\n        self::$defaultOptions ??= self::discoverDefaultOptions();\n        self::$optionConstants ??= self::getOptionConstants();\n\n        $nonDefaultOptions = [];\n        foreach (self::$optionConstants as $constantKey => $value) {\n            if (self::$defaultOptions[$constantKey] !== $option = $c->getOption($value)) {\n                $nonDefaultOptions[$constantKey] = $option;\n            }\n        }\n\n        return $nonDefaultOptions;\n    }\n\n    private static function discoverDefaultOptions(): array\n    {\n        $defaultMemcached = new \\Memcached();\n        $defaultMemcached->addServer('127.0.0.1', 11211);\n\n        $defaultOptions = [];\n        self::$optionConstants ??= self::getOptionConstants();\n\n        foreach (self::$optionConstants as $constantKey => $value) {\n            $defaultOptions[$constantKey] = $defaultMemcached->getOption($value);\n        }\n\n        return $defaultOptions;\n    }\n\n    private static function getOptionConstants(): array\n    {\n        $reflectedMemcached = new \\ReflectionClass(\\Memcached::class);\n\n        $optionConstants = [];\n        foreach ($reflectedMemcached->getConstants() as $constantKey => $value) {\n            if (str_starts_with($constantKey, 'OPT_')) {\n                $optionConstants[$constantKey] = $value;\n            }\n        }\n\n        return $optionConstants;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/MysqliCaster.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * @author Nicolas Grekas <p@tchwork.com>\n *\n * @internal\n */\nfinal class MysqliCaster\n{\n    public static function castMysqliDriver(\\mysqli_driver $c, array $a, Stub $stub, bool $isNested): array\n    {\n        foreach ($a as $k => $v) {\n            if (isset($c->$k)) {\n                $a[$k] = $c->$k;\n            }\n        }\n\n        return $a;\n    }\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/PdoCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Casts PDO related classes to array representation.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n *\n * @final\n */\nclass PdoCaster\n{\n    private const PDO_ATTRIBUTES = [\n        'CASE' => [\n            \\PDO::CASE_LOWER => 'LOWER',\n            \\PDO::CASE_NATURAL => 'NATURAL',\n            \\PDO::CASE_UPPER => 'UPPER',\n        ],\n        'ERRMODE' => [\n            \\PDO::ERRMODE_SILENT => 'SILENT',\n            \\PDO::ERRMODE_WARNING => 'WARNING',\n            \\PDO::ERRMODE_EXCEPTION => 'EXCEPTION',\n        ],\n        'TIMEOUT',\n        'PREFETCH',\n        'AUTOCOMMIT',\n        'PERSISTENT',\n        'DRIVER_NAME',\n        'SERVER_INFO',\n        'ORACLE_NULLS' => [\n            \\PDO::NULL_NATURAL => 'NATURAL',\n            \\PDO::NULL_EMPTY_STRING => 'EMPTY_STRING',\n            \\PDO::NULL_TO_STRING => 'TO_STRING',\n        ],\n        'CLIENT_VERSION',\n        'SERVER_VERSION',\n        'STATEMENT_CLASS',\n        'EMULATE_PREPARES',\n        'CONNECTION_STATUS',\n        'STRINGIFY_FETCHES',\n        'DEFAULT_FETCH_MODE' => [\n            \\PDO::FETCH_ASSOC => 'ASSOC',\n            \\PDO::FETCH_BOTH => 'BOTH',\n            \\PDO::FETCH_LAZY => 'LAZY',\n            \\PDO::FETCH_NUM => 'NUM',\n            \\PDO::FETCH_OBJ => 'OBJ',\n        ],\n    ];\n\n    /**\n     * @return array\n     */\n    public static function castPdo(\\PDO $c, array $a, Stub $stub, bool $isNested)\n    {\n        $attr = [];\n        $errmode = $c->getAttribute(\\PDO::ATTR_ERRMODE);\n        $c->setAttribute(\\PDO::ATTR_ERRMODE, \\PDO::ERRMODE_EXCEPTION);\n\n        foreach (self::PDO_ATTRIBUTES as $k => $v) {\n            if (!isset($k[0])) {\n                $k = $v;\n                $v = [];\n            }\n\n            try {\n                $attr[$k] = 'ERRMODE' === $k ? $errmode : $c->getAttribute(\\constant('PDO::ATTR_'.$k));\n                if ($v && isset($v[$attr[$k]])) {\n                    $attr[$k] = new ConstStub($v[$attr[$k]], $attr[$k]);\n                }\n            } catch (\\Exception) {\n            }\n        }\n        if (isset($attr[$k = 'STATEMENT_CLASS'][1])) {\n            if ($attr[$k][1]) {\n                $attr[$k][1] = new ArgsStub($attr[$k][1], '__construct', $attr[$k][0]);\n            }\n            $attr[$k][0] = new ClassStub($attr[$k][0]);\n        }\n\n        $prefix = Caster::PREFIX_VIRTUAL;\n        $a += [\n            $prefix.'inTransaction' => method_exists($c, 'inTransaction'),\n            $prefix.'errorInfo' => $c->errorInfo(),\n            $prefix.'attributes' => new EnumStub($attr),\n        ];\n\n        if ($a[$prefix.'inTransaction']) {\n            $a[$prefix.'inTransaction'] = $c->inTransaction();\n        } else {\n            unset($a[$prefix.'inTransaction']);\n        }\n\n        if (!isset($a[$prefix.'errorInfo'][1], $a[$prefix.'errorInfo'][2])) {\n            unset($a[$prefix.'errorInfo']);\n        }\n\n        $c->setAttribute(\\PDO::ATTR_ERRMODE, $errmode);\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castPdoStatement(\\PDOStatement $c, array $a, Stub $stub, bool $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n        $a[$prefix.'errorInfo'] = $c->errorInfo();\n\n        if (!isset($a[$prefix.'errorInfo'][1], $a[$prefix.'errorInfo'][2])) {\n            unset($a[$prefix.'errorInfo']);\n        }\n\n        return $a;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/PgSqlCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Casts pqsql resources to array representation.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n *\n * @final\n */\nclass PgSqlCaster\n{\n    private const PARAM_CODES = [\n        'server_encoding',\n        'client_encoding',\n        'is_superuser',\n        'session_authorization',\n        'DateStyle',\n        'TimeZone',\n        'IntervalStyle',\n        'integer_datetimes',\n        'application_name',\n        'standard_conforming_strings',\n    ];\n\n    private const TRANSACTION_STATUS = [\n        \\PGSQL_TRANSACTION_IDLE => 'PGSQL_TRANSACTION_IDLE',\n        \\PGSQL_TRANSACTION_ACTIVE => 'PGSQL_TRANSACTION_ACTIVE',\n        \\PGSQL_TRANSACTION_INTRANS => 'PGSQL_TRANSACTION_INTRANS',\n        \\PGSQL_TRANSACTION_INERROR => 'PGSQL_TRANSACTION_INERROR',\n        \\PGSQL_TRANSACTION_UNKNOWN => 'PGSQL_TRANSACTION_UNKNOWN',\n    ];\n\n    private const RESULT_STATUS = [\n        \\PGSQL_EMPTY_QUERY => 'PGSQL_EMPTY_QUERY',\n        \\PGSQL_COMMAND_OK => 'PGSQL_COMMAND_OK',\n        \\PGSQL_TUPLES_OK => 'PGSQL_TUPLES_OK',\n        \\PGSQL_COPY_OUT => 'PGSQL_COPY_OUT',\n        \\PGSQL_COPY_IN => 'PGSQL_COPY_IN',\n        \\PGSQL_BAD_RESPONSE => 'PGSQL_BAD_RESPONSE',\n        \\PGSQL_NONFATAL_ERROR => 'PGSQL_NONFATAL_ERROR',\n        \\PGSQL_FATAL_ERROR => 'PGSQL_FATAL_ERROR',\n    ];\n\n    private const DIAG_CODES = [\n        'severity' => \\PGSQL_DIAG_SEVERITY,\n        'sqlstate' => \\PGSQL_DIAG_SQLSTATE,\n        'message' => \\PGSQL_DIAG_MESSAGE_PRIMARY,\n        'detail' => \\PGSQL_DIAG_MESSAGE_DETAIL,\n        'hint' => \\PGSQL_DIAG_MESSAGE_HINT,\n        'statement position' => \\PGSQL_DIAG_STATEMENT_POSITION,\n        'internal position' => \\PGSQL_DIAG_INTERNAL_POSITION,\n        'internal query' => \\PGSQL_DIAG_INTERNAL_QUERY,\n        'context' => \\PGSQL_DIAG_CONTEXT,\n        'file' => \\PGSQL_DIAG_SOURCE_FILE,\n        'line' => \\PGSQL_DIAG_SOURCE_LINE,\n        'function' => \\PGSQL_DIAG_SOURCE_FUNCTION,\n    ];\n\n    /**\n     * @return array\n     */\n    public static function castLargeObject($lo, array $a, Stub $stub, bool $isNested)\n    {\n        $a['seek position'] = pg_lo_tell($lo);\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castLink($link, array $a, Stub $stub, bool $isNested)\n    {\n        $a['status'] = pg_connection_status($link);\n        $a['status'] = new ConstStub(\\PGSQL_CONNECTION_OK === $a['status'] ? 'PGSQL_CONNECTION_OK' : 'PGSQL_CONNECTION_BAD', $a['status']);\n        $a['busy'] = pg_connection_busy($link);\n\n        $a['transaction'] = pg_transaction_status($link);\n        if (isset(self::TRANSACTION_STATUS[$a['transaction']])) {\n            $a['transaction'] = new ConstStub(self::TRANSACTION_STATUS[$a['transaction']], $a['transaction']);\n        }\n\n        $a['pid'] = pg_get_pid($link);\n        $a['last error'] = pg_last_error($link);\n        $a['last notice'] = pg_last_notice($link);\n        $a['host'] = pg_host($link);\n        $a['port'] = pg_port($link);\n        $a['dbname'] = pg_dbname($link);\n        $a['options'] = pg_options($link);\n        $a['version'] = pg_version($link);\n\n        foreach (self::PARAM_CODES as $v) {\n            if (false !== $s = pg_parameter_status($link, $v)) {\n                $a['param'][$v] = $s;\n            }\n        }\n\n        $a['param']['client_encoding'] = pg_client_encoding($link);\n        $a['param'] = new EnumStub($a['param']);\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castResult($result, array $a, Stub $stub, bool $isNested)\n    {\n        $a['num rows'] = pg_num_rows($result);\n        $a['status'] = pg_result_status($result);\n        if (isset(self::RESULT_STATUS[$a['status']])) {\n            $a['status'] = new ConstStub(self::RESULT_STATUS[$a['status']], $a['status']);\n        }\n        $a['command-completion tag'] = pg_result_status($result, \\PGSQL_STATUS_STRING);\n\n        if (-1 === $a['num rows']) {\n            foreach (self::DIAG_CODES as $k => $v) {\n                $a['error'][$k] = pg_result_error_field($result, $v);\n            }\n        }\n\n        $a['affected rows'] = pg_affected_rows($result);\n        $a['last OID'] = pg_last_oid($result);\n\n        $fields = pg_num_fields($result);\n\n        for ($i = 0; $i < $fields; ++$i) {\n            $field = [\n                'name' => pg_field_name($result, $i),\n                'table' => sprintf('%s (OID: %s)', pg_field_table($result, $i), pg_field_table($result, $i, true)),\n                'type' => sprintf('%s (OID: %s)', pg_field_type($result, $i), pg_field_type_oid($result, $i)),\n                'nullable' => (bool) pg_field_is_null($result, $i),\n                'storage' => pg_field_size($result, $i).' bytes',\n                'display' => pg_field_prtlen($result, $i).' chars',\n            ];\n            if (' (OID: )' === $field['table']) {\n                $field['table'] = null;\n            }\n            if ('-1 bytes' === $field['storage']) {\n                $field['storage'] = 'variable size';\n            } elseif ('1 bytes' === $field['storage']) {\n                $field['storage'] = '1 byte';\n            }\n            if ('1 chars' === $field['display']) {\n                $field['display'] = '1 char';\n            }\n            $a['fields'][] = new EnumStub($field);\n        }\n\n        return $a;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/ProxyManagerCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse ProxyManager\\Proxy\\ProxyInterface;\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * @author Nicolas Grekas <p@tchwork.com>\n *\n * @final\n */\nclass ProxyManagerCaster\n{\n    /**\n     * @return array\n     */\n    public static function castProxy(ProxyInterface $c, array $a, Stub $stub, bool $isNested)\n    {\n        if ($parent = get_parent_class($c)) {\n            $stub->class .= ' - '.$parent;\n        }\n        $stub->class .= '@proxy';\n\n        return $a;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/RdKafkaCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse RdKafka\\Conf;\nuse RdKafka\\Exception as RdKafkaException;\nuse RdKafka\\KafkaConsumer;\nuse RdKafka\\Message;\nuse RdKafka\\Metadata\\Broker as BrokerMetadata;\nuse RdKafka\\Metadata\\Collection as CollectionMetadata;\nuse RdKafka\\Metadata\\Partition as PartitionMetadata;\nuse RdKafka\\Metadata\\Topic as TopicMetadata;\nuse RdKafka\\Topic;\nuse RdKafka\\TopicConf;\nuse RdKafka\\TopicPartition;\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Casts RdKafka related classes to array representation.\n *\n * @author Romain Neutron <imprec@gmail.com>\n */\nclass RdKafkaCaster\n{\n    /**\n     * @return array\n     */\n    public static function castKafkaConsumer(KafkaConsumer $c, array $a, Stub $stub, bool $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        try {\n            $assignment = $c->getAssignment();\n        } catch (RdKafkaException) {\n            $assignment = [];\n        }\n\n        $a += [\n            $prefix.'subscription' => $c->getSubscription(),\n            $prefix.'assignment' => $assignment,\n        ];\n\n        $a += self::extractMetadata($c);\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castTopic(Topic $c, array $a, Stub $stub, bool $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        $a += [\n            $prefix.'name' => $c->getName(),\n        ];\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castTopicPartition(TopicPartition $c, array $a)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        $a += [\n            $prefix.'offset' => $c->getOffset(),\n            $prefix.'partition' => $c->getPartition(),\n            $prefix.'topic' => $c->getTopic(),\n        ];\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castMessage(Message $c, array $a, Stub $stub, bool $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        $a += [\n            $prefix.'errstr' => $c->errstr(),\n        ];\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castConf(Conf $c, array $a, Stub $stub, bool $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        foreach ($c->dump() as $key => $value) {\n            $a[$prefix.$key] = $value;\n        }\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castTopicConf(TopicConf $c, array $a, Stub $stub, bool $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        foreach ($c->dump() as $key => $value) {\n            $a[$prefix.$key] = $value;\n        }\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castRdKafka(\\RdKafka $c, array $a, Stub $stub, bool $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        $a += [\n            $prefix.'out_q_len' => $c->getOutQLen(),\n        ];\n\n        $a += self::extractMetadata($c);\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castCollectionMetadata(CollectionMetadata $c, array $a, Stub $stub, bool $isNested)\n    {\n        $a += iterator_to_array($c);\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castTopicMetadata(TopicMetadata $c, array $a, Stub $stub, bool $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        $a += [\n            $prefix.'name' => $c->getTopic(),\n            $prefix.'partitions' => $c->getPartitions(),\n        ];\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castPartitionMetadata(PartitionMetadata $c, array $a, Stub $stub, bool $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        $a += [\n            $prefix.'id' => $c->getId(),\n            $prefix.'err' => $c->getErr(),\n            $prefix.'leader' => $c->getLeader(),\n        ];\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castBrokerMetadata(BrokerMetadata $c, array $a, Stub $stub, bool $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        $a += [\n            $prefix.'id' => $c->getId(),\n            $prefix.'host' => $c->getHost(),\n            $prefix.'port' => $c->getPort(),\n        ];\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    private static function extractMetadata(KafkaConsumer|\\RdKafka $c)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        try {\n            $m = $c->getMetadata(true, null, 500);\n        } catch (RdKafkaException) {\n            return [];\n        }\n\n        return [\n            $prefix.'orig_broker_id' => $m->getOrigBrokerId(),\n            $prefix.'orig_broker_name' => $m->getOrigBrokerName(),\n            $prefix.'brokers' => $m->getBrokers(),\n            $prefix.'topics' => $m->getTopics(),\n        ];\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/RedisCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Relay\\Relay;\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Casts Redis class from ext-redis to array representation.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n *\n * @final\n */\nclass RedisCaster\n{\n    private const SERIALIZERS = [\n        0 => 'NONE', // Redis::SERIALIZER_NONE\n        1 => 'PHP', // Redis::SERIALIZER_PHP\n        2 => 'IGBINARY', // Optional Redis::SERIALIZER_IGBINARY\n    ];\n\n    private const MODES = [\n        0 => 'ATOMIC', // Redis::ATOMIC\n        1 => 'MULTI', // Redis::MULTI\n        2 => 'PIPELINE', // Redis::PIPELINE\n    ];\n\n    private const COMPRESSION_MODES = [\n        0 => 'NONE', // Redis::COMPRESSION_NONE\n        1 => 'LZF',  // Redis::COMPRESSION_LZF\n    ];\n\n    private const FAILOVER_OPTIONS = [\n        \\RedisCluster::FAILOVER_NONE => 'NONE',\n        \\RedisCluster::FAILOVER_ERROR => 'ERROR',\n        \\RedisCluster::FAILOVER_DISTRIBUTE => 'DISTRIBUTE',\n        \\RedisCluster::FAILOVER_DISTRIBUTE_SLAVES => 'DISTRIBUTE_SLAVES',\n    ];\n\n    /**\n     * @return array\n     */\n    public static function castRedis(\\Redis|Relay $c, array $a, Stub $stub, bool $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        if (!$connected = $c->isConnected()) {\n            return $a + [\n                $prefix.'isConnected' => $connected,\n            ];\n        }\n\n        $mode = $c->getMode();\n\n        return $a + [\n            $prefix.'isConnected' => $connected,\n            $prefix.'host' => $c->getHost(),\n            $prefix.'port' => $c->getPort(),\n            $prefix.'auth' => $c->getAuth(),\n            $prefix.'mode' => isset(self::MODES[$mode]) ? new ConstStub(self::MODES[$mode], $mode) : $mode,\n            $prefix.'dbNum' => $c->getDbNum(),\n            $prefix.'timeout' => $c->getTimeout(),\n            $prefix.'lastError' => $c->getLastError(),\n            $prefix.'persistentId' => $c->getPersistentID(),\n            $prefix.'options' => self::getRedisOptions($c),\n        ];\n    }\n\n    /**\n     * @return array\n     */\n    public static function castRedisArray(\\RedisArray $c, array $a, Stub $stub, bool $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        return $a + [\n            $prefix.'hosts' => $c->_hosts(),\n            $prefix.'function' => ClassStub::wrapCallable($c->_function()),\n            $prefix.'lastError' => $c->getLastError(),\n            $prefix.'options' => self::getRedisOptions($c),\n        ];\n    }\n\n    /**\n     * @return array\n     */\n    public static function castRedisCluster(\\RedisCluster $c, array $a, Stub $stub, bool $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n        $failover = $c->getOption(\\RedisCluster::OPT_SLAVE_FAILOVER);\n\n        $a += [\n            $prefix.'_masters' => $c->_masters(),\n            $prefix.'_redir' => $c->_redir(),\n            $prefix.'mode' => new ConstStub($c->getMode() ? 'MULTI' : 'ATOMIC', $c->getMode()),\n            $prefix.'lastError' => $c->getLastError(),\n            $prefix.'options' => self::getRedisOptions($c, [\n                'SLAVE_FAILOVER' => isset(self::FAILOVER_OPTIONS[$failover]) ? new ConstStub(self::FAILOVER_OPTIONS[$failover], $failover) : $failover,\n            ]),\n        ];\n\n        return $a;\n    }\n\n    private static function getRedisOptions(\\Redis|Relay|\\RedisArray|\\RedisCluster $redis, array $options = []): EnumStub\n    {\n        $serializer = $redis->getOption(\\defined('Redis::OPT_SERIALIZER') ? \\Redis::OPT_SERIALIZER : 1);\n        if (\\is_array($serializer)) {\n            foreach ($serializer as &$v) {\n                if (isset(self::SERIALIZERS[$v])) {\n                    $v = new ConstStub(self::SERIALIZERS[$v], $v);\n                }\n            }\n        } elseif (isset(self::SERIALIZERS[$serializer])) {\n            $serializer = new ConstStub(self::SERIALIZERS[$serializer], $serializer);\n        }\n\n        $compression = \\defined('Redis::OPT_COMPRESSION') ? $redis->getOption(\\Redis::OPT_COMPRESSION) : 0;\n        if (\\is_array($compression)) {\n            foreach ($compression as &$v) {\n                if (isset(self::COMPRESSION_MODES[$v])) {\n                    $v = new ConstStub(self::COMPRESSION_MODES[$v], $v);\n                }\n            }\n        } elseif (isset(self::COMPRESSION_MODES[$compression])) {\n            $compression = new ConstStub(self::COMPRESSION_MODES[$compression], $compression);\n        }\n\n        $retry = \\defined('Redis::OPT_SCAN') ? $redis->getOption(\\Redis::OPT_SCAN) : 0;\n        if (\\is_array($retry)) {\n            foreach ($retry as &$v) {\n                $v = new ConstStub($v ? 'RETRY' : 'NORETRY', $v);\n            }\n        } else {\n            $retry = new ConstStub($retry ? 'RETRY' : 'NORETRY', $retry);\n        }\n\n        $options += [\n            'TCP_KEEPALIVE' => \\defined('Redis::OPT_TCP_KEEPALIVE') ? $redis->getOption(\\Redis::OPT_TCP_KEEPALIVE) : Relay::OPT_TCP_KEEPALIVE,\n            'READ_TIMEOUT' => $redis->getOption(\\defined('Redis::OPT_READ_TIMEOUT') ? \\Redis::OPT_READ_TIMEOUT : Relay::OPT_READ_TIMEOUT),\n            'COMPRESSION' => $compression,\n            'SERIALIZER' => $serializer,\n            'PREFIX' => $redis->getOption(\\defined('Redis::OPT_PREFIX') ? \\Redis::OPT_PREFIX : Relay::OPT_PREFIX),\n            'SCAN' => $retry,\n        ];\n\n        return new EnumStub($options);\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/ReflectionCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Casts Reflector related classes to array representation.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n *\n * @final\n */\nclass ReflectionCaster\n{\n    public const UNSET_CLOSURE_FILE_INFO = ['Closure' => __CLASS__.'::unsetClosureFileInfo'];\n\n    private const EXTRA_MAP = [\n        'docComment' => 'getDocComment',\n        'extension' => 'getExtensionName',\n        'isDisabled' => 'isDisabled',\n        'isDeprecated' => 'isDeprecated',\n        'isInternal' => 'isInternal',\n        'isUserDefined' => 'isUserDefined',\n        'isGenerator' => 'isGenerator',\n        'isVariadic' => 'isVariadic',\n    ];\n\n    /**\n     * @return array\n     */\n    public static function castClosure(\\Closure $c, array $a, Stub $stub, bool $isNested, int $filter = 0)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n        $c = new \\ReflectionFunction($c);\n\n        $a = static::castFunctionAbstract($c, $a, $stub, $isNested, $filter);\n\n        if (!str_contains($c->name, '{closure}')) {\n            $stub->class = isset($a[$prefix.'class']) ? $a[$prefix.'class']->value.'::'.$c->name : $c->name;\n            unset($a[$prefix.'class']);\n        }\n        unset($a[$prefix.'extra']);\n\n        $stub->class .= self::getSignature($a);\n\n        if ($f = $c->getFileName()) {\n            $stub->attr['file'] = $f;\n            $stub->attr['line'] = $c->getStartLine();\n        }\n\n        unset($a[$prefix.'parameters']);\n\n        if ($filter & Caster::EXCLUDE_VERBOSE) {\n            $stub->cut += ($c->getFileName() ? 2 : 0) + \\count($a);\n\n            return [];\n        }\n\n        if ($f) {\n            $a[$prefix.'file'] = new LinkStub($f, $c->getStartLine());\n            $a[$prefix.'line'] = $c->getStartLine().' to '.$c->getEndLine();\n        }\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function unsetClosureFileInfo(\\Closure $c, array $a)\n    {\n        unset($a[Caster::PREFIX_VIRTUAL.'file'], $a[Caster::PREFIX_VIRTUAL.'line']);\n\n        return $a;\n    }\n\n    public static function castGenerator(\\Generator $c, array $a, Stub $stub, bool $isNested): array\n    {\n        // Cannot create ReflectionGenerator based on a terminated Generator\n        try {\n            $reflectionGenerator = new \\ReflectionGenerator($c);\n        } catch (\\Exception) {\n            $a[Caster::PREFIX_VIRTUAL.'closed'] = true;\n\n            return $a;\n        }\n\n        return self::castReflectionGenerator($reflectionGenerator, $a, $stub, $isNested);\n    }\n\n    /**\n     * @return array\n     */\n    public static function castType(\\ReflectionType $c, array $a, Stub $stub, bool $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        if ($c instanceof \\ReflectionNamedType) {\n            $a += [\n                $prefix.'name' => $c instanceof \\ReflectionNamedType ? $c->getName() : (string) $c,\n                $prefix.'allowsNull' => $c->allowsNull(),\n                $prefix.'isBuiltin' => $c->isBuiltin(),\n            ];\n        } elseif ($c instanceof \\ReflectionUnionType || $c instanceof \\ReflectionIntersectionType) {\n            $a[$prefix.'allowsNull'] = $c->allowsNull();\n            self::addMap($a, $c, [\n                'types' => 'getTypes',\n            ]);\n        } else {\n            $a[$prefix.'allowsNull'] = $c->allowsNull();\n        }\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castAttribute(\\ReflectionAttribute $c, array $a, Stub $stub, bool $isNested)\n    {\n        self::addMap($a, $c, [\n            'name' => 'getName',\n            'arguments' => 'getArguments',\n        ]);\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castReflectionGenerator(\\ReflectionGenerator $c, array $a, Stub $stub, bool $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        if ($c->getThis()) {\n            $a[$prefix.'this'] = new CutStub($c->getThis());\n        }\n        $function = $c->getFunction();\n        $frame = [\n            'class' => $function->class ?? null,\n            'type' => isset($function->class) ? ($function->isStatic() ? '::' : '->') : null,\n            'function' => $function->name,\n            'file' => $c->getExecutingFile(),\n            'line' => $c->getExecutingLine(),\n        ];\n        if ($trace = $c->getTrace(\\DEBUG_BACKTRACE_IGNORE_ARGS)) {\n            $function = new \\ReflectionGenerator($c->getExecutingGenerator());\n            array_unshift($trace, [\n                'function' => 'yield',\n                'file' => $function->getExecutingFile(),\n                'line' => $function->getExecutingLine(),\n            ]);\n            $trace[] = $frame;\n            $a[$prefix.'trace'] = new TraceStub($trace, false, 0, -1, -1);\n        } else {\n            $function = new FrameStub($frame, false, true);\n            $function = ExceptionCaster::castFrameStub($function, [], $function, true);\n            $a[$prefix.'executing'] = $function[$prefix.'src'];\n        }\n\n        $a[Caster::PREFIX_VIRTUAL.'closed'] = false;\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castClass(\\ReflectionClass $c, array $a, Stub $stub, bool $isNested, int $filter = 0)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        if ($n = \\Reflection::getModifierNames($c->getModifiers())) {\n            $a[$prefix.'modifiers'] = implode(' ', $n);\n        }\n\n        self::addMap($a, $c, [\n            'extends' => 'getParentClass',\n            'implements' => 'getInterfaceNames',\n            'constants' => 'getReflectionConstants',\n        ]);\n\n        foreach ($c->getProperties() as $n) {\n            $a[$prefix.'properties'][$n->name] = $n;\n        }\n\n        foreach ($c->getMethods() as $n) {\n            $a[$prefix.'methods'][$n->name] = $n;\n        }\n\n        self::addAttributes($a, $c, $prefix);\n\n        if (!($filter & Caster::EXCLUDE_VERBOSE) && !$isNested) {\n            self::addExtra($a, $c);\n        }\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castFunctionAbstract(\\ReflectionFunctionAbstract $c, array $a, Stub $stub, bool $isNested, int $filter = 0)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        self::addMap($a, $c, [\n            'returnsReference' => 'returnsReference',\n            'returnType' => 'getReturnType',\n            'class' => \\PHP_VERSION_ID >= 80111 ? 'getClosureCalledClass' : 'getClosureScopeClass',\n            'this' => 'getClosureThis',\n        ]);\n\n        if (isset($a[$prefix.'returnType'])) {\n            $v = $a[$prefix.'returnType'];\n            $v = $v instanceof \\ReflectionNamedType ? $v->getName() : (string) $v;\n            $a[$prefix.'returnType'] = new ClassStub($a[$prefix.'returnType'] instanceof \\ReflectionNamedType && $a[$prefix.'returnType']->allowsNull() && 'mixed' !== $v ? '?'.$v : $v, [class_exists($v, false) || interface_exists($v, false) || trait_exists($v, false) ? $v : '', '']);\n        }\n        if (isset($a[$prefix.'class'])) {\n            $a[$prefix.'class'] = new ClassStub($a[$prefix.'class']);\n        }\n        if (isset($a[$prefix.'this'])) {\n            $a[$prefix.'this'] = new CutStub($a[$prefix.'this']);\n        }\n\n        foreach ($c->getParameters() as $v) {\n            $k = '$'.$v->name;\n            if ($v->isVariadic()) {\n                $k = '...'.$k;\n            }\n            if ($v->isPassedByReference()) {\n                $k = '&'.$k;\n            }\n            $a[$prefix.'parameters'][$k] = $v;\n        }\n        if (isset($a[$prefix.'parameters'])) {\n            $a[$prefix.'parameters'] = new EnumStub($a[$prefix.'parameters']);\n        }\n\n        self::addAttributes($a, $c, $prefix);\n\n        if (!($filter & Caster::EXCLUDE_VERBOSE) && $v = $c->getStaticVariables()) {\n            foreach ($v as $k => &$v) {\n                if (\\is_object($v)) {\n                    $a[$prefix.'use']['$'.$k] = new CutStub($v);\n                } else {\n                    $a[$prefix.'use']['$'.$k] = &$v;\n                }\n            }\n            unset($v);\n            $a[$prefix.'use'] = new EnumStub($a[$prefix.'use']);\n        }\n\n        if (!($filter & Caster::EXCLUDE_VERBOSE) && !$isNested) {\n            self::addExtra($a, $c);\n        }\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castClassConstant(\\ReflectionClassConstant $c, array $a, Stub $stub, bool $isNested)\n    {\n        $a[Caster::PREFIX_VIRTUAL.'modifiers'] = implode(' ', \\Reflection::getModifierNames($c->getModifiers()));\n        $a[Caster::PREFIX_VIRTUAL.'value'] = $c->getValue();\n\n        self::addAttributes($a, $c);\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castMethod(\\ReflectionMethod $c, array $a, Stub $stub, bool $isNested)\n    {\n        $a[Caster::PREFIX_VIRTUAL.'modifiers'] = implode(' ', \\Reflection::getModifierNames($c->getModifiers()));\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castParameter(\\ReflectionParameter $c, array $a, Stub $stub, bool $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        self::addMap($a, $c, [\n            'position' => 'getPosition',\n            'isVariadic' => 'isVariadic',\n            'byReference' => 'isPassedByReference',\n            'allowsNull' => 'allowsNull',\n        ]);\n\n        self::addAttributes($a, $c, $prefix);\n\n        if ($v = $c->getType()) {\n            $a[$prefix.'typeHint'] = $v instanceof \\ReflectionNamedType ? $v->getName() : (string) $v;\n        }\n\n        if (isset($a[$prefix.'typeHint'])) {\n            $v = $a[$prefix.'typeHint'];\n            $a[$prefix.'typeHint'] = new ClassStub($v, [class_exists($v, false) || interface_exists($v, false) || trait_exists($v, false) ? $v : '', '']);\n        } else {\n            unset($a[$prefix.'allowsNull']);\n        }\n\n        if ($c->isOptional()) {\n            try {\n                $a[$prefix.'default'] = $v = $c->getDefaultValue();\n                if ($c->isDefaultValueConstant() && !\\is_object($v)) {\n                    $a[$prefix.'default'] = new ConstStub($c->getDefaultValueConstantName(), $v);\n                }\n                if (null === $v) {\n                    unset($a[$prefix.'allowsNull']);\n                }\n            } catch (\\ReflectionException) {\n            }\n        }\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castProperty(\\ReflectionProperty $c, array $a, Stub $stub, bool $isNested)\n    {\n        $a[Caster::PREFIX_VIRTUAL.'modifiers'] = implode(' ', \\Reflection::getModifierNames($c->getModifiers()));\n\n        self::addAttributes($a, $c);\n        self::addExtra($a, $c);\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castReference(\\ReflectionReference $c, array $a, Stub $stub, bool $isNested)\n    {\n        $a[Caster::PREFIX_VIRTUAL.'id'] = $c->getId();\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castExtension(\\ReflectionExtension $c, array $a, Stub $stub, bool $isNested)\n    {\n        self::addMap($a, $c, [\n            'version' => 'getVersion',\n            'dependencies' => 'getDependencies',\n            'iniEntries' => 'getIniEntries',\n            'isPersistent' => 'isPersistent',\n            'isTemporary' => 'isTemporary',\n            'constants' => 'getConstants',\n            'functions' => 'getFunctions',\n            'classes' => 'getClasses',\n        ]);\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castZendExtension(\\ReflectionZendExtension $c, array $a, Stub $stub, bool $isNested)\n    {\n        self::addMap($a, $c, [\n            'version' => 'getVersion',\n            'author' => 'getAuthor',\n            'copyright' => 'getCopyright',\n            'url' => 'getURL',\n        ]);\n\n        return $a;\n    }\n\n    /**\n     * @return string\n     */\n    public static function getSignature(array $a)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n        $signature = '';\n\n        if (isset($a[$prefix.'parameters'])) {\n            foreach ($a[$prefix.'parameters']->value as $k => $param) {\n                $signature .= ', ';\n                if ($type = $param->getType()) {\n                    if (!$type instanceof \\ReflectionNamedType) {\n                        $signature .= $type.' ';\n                    } else {\n                        if (!$param->isOptional() && $param->allowsNull() && 'mixed' !== $type->getName()) {\n                            $signature .= '?';\n                        }\n                        $signature .= substr(strrchr('\\\\'.$type->getName(), '\\\\'), 1).' ';\n                    }\n                }\n                $signature .= $k;\n\n                if (!$param->isDefaultValueAvailable()) {\n                    continue;\n                }\n                $v = $param->getDefaultValue();\n                $signature .= ' = ';\n\n                if ($param->isDefaultValueConstant()) {\n                    $signature .= substr(strrchr('\\\\'.$param->getDefaultValueConstantName(), '\\\\'), 1);\n                } elseif (null === $v) {\n                    $signature .= 'null';\n                } elseif (\\is_array($v)) {\n                    $signature .= $v ? '[…'.\\count($v).']' : '[]';\n                } elseif (\\is_string($v)) {\n                    $signature .= 10 > \\strlen($v) && !str_contains($v, '\\\\') ? \"'{$v}'\" : \"'…\".\\strlen($v).\"'\";\n                } elseif (\\is_bool($v)) {\n                    $signature .= $v ? 'true' : 'false';\n                } elseif (\\is_object($v)) {\n                    $signature .= 'new '.substr(strrchr('\\\\'.get_debug_type($v), '\\\\'), 1);\n                } else {\n                    $signature .= $v;\n                }\n            }\n        }\n        $signature = (empty($a[$prefix.'returnsReference']) ? '' : '&').'('.substr($signature, 2).')';\n\n        if (isset($a[$prefix.'returnType'])) {\n            $signature .= ': '.substr(strrchr('\\\\'.$a[$prefix.'returnType'], '\\\\'), 1);\n        }\n\n        return $signature;\n    }\n\n    private static function addExtra(array &$a, \\Reflector $c): void\n    {\n        $x = isset($a[Caster::PREFIX_VIRTUAL.'extra']) ? $a[Caster::PREFIX_VIRTUAL.'extra']->value : [];\n\n        if (method_exists($c, 'getFileName') && $m = $c->getFileName()) {\n            $x['file'] = new LinkStub($m, $c->getStartLine());\n            $x['line'] = $c->getStartLine().' to '.$c->getEndLine();\n        }\n\n        self::addMap($x, $c, self::EXTRA_MAP, '');\n\n        if ($x) {\n            $a[Caster::PREFIX_VIRTUAL.'extra'] = new EnumStub($x);\n        }\n    }\n\n    private static function addMap(array &$a, object $c, array $map, string $prefix = Caster::PREFIX_VIRTUAL): void\n    {\n        foreach ($map as $k => $m) {\n            if ('isDisabled' === $k) {\n                continue;\n            }\n\n            if (method_exists($c, $m) && false !== ($m = $c->$m()) && null !== $m) {\n                $a[$prefix.$k] = $m instanceof \\Reflector ? $m->name : $m;\n            }\n        }\n    }\n\n    private static function addAttributes(array &$a, \\Reflector $c, string $prefix = Caster::PREFIX_VIRTUAL): void\n    {\n        foreach ($c->getAttributes() as $n) {\n            $a[$prefix.'attributes'][] = $n;\n        }\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/ResourceCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Casts common resource types to array representation.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n *\n * @final\n */\nclass ResourceCaster\n{\n    public static function castCurl(\\CurlHandle $h, array $a, Stub $stub, bool $isNested): array\n    {\n        return curl_getinfo($h);\n    }\n\n    /**\n     * @return array\n     */\n    public static function castDba($dba, array $a, Stub $stub, bool $isNested)\n    {\n        $list = dba_list();\n        $a['file'] = $list[(int) $dba];\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castProcess($process, array $a, Stub $stub, bool $isNested)\n    {\n        return proc_get_status($process);\n    }\n\n    public static function castStream($stream, array $a, Stub $stub, bool $isNested): array\n    {\n        $a = stream_get_meta_data($stream) + static::castStreamContext($stream, $a, $stub, $isNested);\n        if ($a['uri'] ?? false) {\n            $a['uri'] = new LinkStub($a['uri']);\n        }\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castStreamContext($stream, array $a, Stub $stub, bool $isNested)\n    {\n        return @stream_context_get_params($stream) ?: $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castGd($gd, array $a, Stub $stub, bool $isNested)\n    {\n        $a['size'] = imagesx($gd).'x'.imagesy($gd);\n        $a['trueColor'] = imageistruecolor($gd);\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castOpensslX509($h, array $a, Stub $stub, bool $isNested)\n    {\n        $stub->cut = -1;\n        $info = openssl_x509_parse($h, false);\n\n        $pin = openssl_pkey_get_public($h);\n        $pin = openssl_pkey_get_details($pin)['key'];\n        $pin = \\array_slice(explode(\"\\n\", $pin), 1, -2);\n        $pin = base64_decode(implode('', $pin));\n        $pin = base64_encode(hash('sha256', $pin, true));\n\n        $a += [\n            'subject' => new EnumStub(array_intersect_key($info['subject'], ['organizationName' => true, 'commonName' => true])),\n            'issuer' => new EnumStub(array_intersect_key($info['issuer'], ['organizationName' => true, 'commonName' => true])),\n            'expiry' => new ConstStub(date(\\DateTimeInterface::ISO8601, $info['validTo_time_t']), $info['validTo_time_t']),\n            'fingerprint' => new EnumStub([\n                'md5' => new ConstStub(wordwrap(strtoupper(openssl_x509_fingerprint($h, 'md5')), 2, ':', true)),\n                'sha1' => new ConstStub(wordwrap(strtoupper(openssl_x509_fingerprint($h, 'sha1')), 2, ':', true)),\n                'sha256' => new ConstStub(wordwrap(strtoupper(openssl_x509_fingerprint($h, 'sha256')), 2, ':', true)),\n                'pin-sha256' => new ConstStub($pin),\n            ]),\n        ];\n\n        return $a;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/ScalarStub.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Represents any arbitrary value.\n *\n * @author Alexandre Daubois <alex.daubois@gmail.com>\n */\nclass ScalarStub extends Stub\n{\n    public function __construct(mixed $value)\n    {\n        $this->value = $value;\n    }\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/SplCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Casts SPL related classes to array representation.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n *\n * @final\n */\nclass SplCaster\n{\n    private const SPL_FILE_OBJECT_FLAGS = [\n        \\SplFileObject::DROP_NEW_LINE => 'DROP_NEW_LINE',\n        \\SplFileObject::READ_AHEAD => 'READ_AHEAD',\n        \\SplFileObject::SKIP_EMPTY => 'SKIP_EMPTY',\n        \\SplFileObject::READ_CSV => 'READ_CSV',\n    ];\n\n    /**\n     * @return array\n     */\n    public static function castArrayObject(\\ArrayObject $c, array $a, Stub $stub, bool $isNested)\n    {\n        return self::castSplArray($c, $a, $stub, $isNested);\n    }\n\n    /**\n     * @return array\n     */\n    public static function castArrayIterator(\\ArrayIterator $c, array $a, Stub $stub, bool $isNested)\n    {\n        return self::castSplArray($c, $a, $stub, $isNested);\n    }\n\n    /**\n     * @return array\n     */\n    public static function castHeap(\\Iterator $c, array $a, Stub $stub, bool $isNested)\n    {\n        $a += [\n            Caster::PREFIX_VIRTUAL.'heap' => iterator_to_array(clone $c),\n        ];\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castDoublyLinkedList(\\SplDoublyLinkedList $c, array $a, Stub $stub, bool $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n        $mode = $c->getIteratorMode();\n        $c->setIteratorMode(\\SplDoublyLinkedList::IT_MODE_KEEP | $mode & ~\\SplDoublyLinkedList::IT_MODE_DELETE);\n\n        $a += [\n            $prefix.'mode' => new ConstStub((($mode & \\SplDoublyLinkedList::IT_MODE_LIFO) ? 'IT_MODE_LIFO' : 'IT_MODE_FIFO').' | '.(($mode & \\SplDoublyLinkedList::IT_MODE_DELETE) ? 'IT_MODE_DELETE' : 'IT_MODE_KEEP'), $mode),\n            $prefix.'dllist' => iterator_to_array($c),\n        ];\n        $c->setIteratorMode($mode);\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castFileInfo(\\SplFileInfo $c, array $a, Stub $stub, bool $isNested)\n    {\n        static $map = [\n            'path' => 'getPath',\n            'filename' => 'getFilename',\n            'basename' => 'getBasename',\n            'pathname' => 'getPathname',\n            'extension' => 'getExtension',\n            'realPath' => 'getRealPath',\n            'aTime' => 'getATime',\n            'mTime' => 'getMTime',\n            'cTime' => 'getCTime',\n            'inode' => 'getInode',\n            'size' => 'getSize',\n            'perms' => 'getPerms',\n            'owner' => 'getOwner',\n            'group' => 'getGroup',\n            'type' => 'getType',\n            'writable' => 'isWritable',\n            'readable' => 'isReadable',\n            'executable' => 'isExecutable',\n            'file' => 'isFile',\n            'dir' => 'isDir',\n            'link' => 'isLink',\n            'linkTarget' => 'getLinkTarget',\n        ];\n\n        $prefix = Caster::PREFIX_VIRTUAL;\n        unset($a[\"\\0SplFileInfo\\0fileName\"]);\n        unset($a[\"\\0SplFileInfo\\0pathName\"]);\n\n        try {\n            $c->isReadable();\n        } catch (\\RuntimeException $e) {\n            if ('Object not initialized' !== $e->getMessage()) {\n                throw $e;\n            }\n\n            $a[$prefix.'⚠'] = 'The parent constructor was not called: the object is in an invalid state';\n\n            return $a;\n        } catch (\\Error $e) {\n            if ('Object not initialized' !== $e->getMessage()) {\n                throw $e;\n            }\n\n            $a[$prefix.'⚠'] = 'The parent constructor was not called: the object is in an invalid state';\n\n            return $a;\n        }\n\n        foreach ($map as $key => $accessor) {\n            try {\n                $a[$prefix.$key] = $c->$accessor();\n            } catch (\\Exception) {\n            }\n        }\n\n        if ($a[$prefix.'realPath'] ?? false) {\n            $a[$prefix.'realPath'] = new LinkStub($a[$prefix.'realPath']);\n        }\n\n        if (isset($a[$prefix.'perms'])) {\n            $a[$prefix.'perms'] = new ConstStub(sprintf('0%o', $a[$prefix.'perms']), $a[$prefix.'perms']);\n        }\n\n        static $mapDate = ['aTime', 'mTime', 'cTime'];\n        foreach ($mapDate as $key) {\n            if (isset($a[$prefix.$key])) {\n                $a[$prefix.$key] = new ConstStub(date('Y-m-d H:i:s', $a[$prefix.$key]), $a[$prefix.$key]);\n            }\n        }\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castFileObject(\\SplFileObject $c, array $a, Stub $stub, bool $isNested)\n    {\n        static $map = [\n            'csvControl' => 'getCsvControl',\n            'flags' => 'getFlags',\n            'maxLineLen' => 'getMaxLineLen',\n            'fstat' => 'fstat',\n            'eof' => 'eof',\n            'key' => 'key',\n        ];\n\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        foreach ($map as $key => $accessor) {\n            try {\n                $a[$prefix.$key] = $c->$accessor();\n            } catch (\\Exception) {\n            }\n        }\n\n        if (isset($a[$prefix.'flags'])) {\n            $flagsArray = [];\n            foreach (self::SPL_FILE_OBJECT_FLAGS as $value => $name) {\n                if ($a[$prefix.'flags'] & $value) {\n                    $flagsArray[] = $name;\n                }\n            }\n            $a[$prefix.'flags'] = new ConstStub(implode('|', $flagsArray), $a[$prefix.'flags']);\n        }\n\n        if (isset($a[$prefix.'fstat'])) {\n            $a[$prefix.'fstat'] = new CutArrayStub($a[$prefix.'fstat'], ['dev', 'ino', 'nlink', 'rdev', 'blksize', 'blocks']);\n        }\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castObjectStorage(\\SplObjectStorage $c, array $a, Stub $stub, bool $isNested)\n    {\n        $storage = [];\n        unset($a[Caster::PREFIX_DYNAMIC.\"\\0gcdata\"]); // Don't hit https://bugs.php.net/65967\n        unset($a[\"\\0SplObjectStorage\\0storage\"]);\n\n        $clone = clone $c;\n        foreach ($clone as $obj) {\n            $storage[] = new EnumStub([\n                'object' => $obj,\n                'info' => $clone->getInfo(),\n             ]);\n        }\n\n        $a += [\n            Caster::PREFIX_VIRTUAL.'storage' => $storage,\n        ];\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castOuterIterator(\\OuterIterator $c, array $a, Stub $stub, bool $isNested)\n    {\n        $a[Caster::PREFIX_VIRTUAL.'innerIterator'] = $c->getInnerIterator();\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castWeakReference(\\WeakReference $c, array $a, Stub $stub, bool $isNested)\n    {\n        $a[Caster::PREFIX_VIRTUAL.'object'] = $c->get();\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castWeakMap(\\WeakMap $c, array $a, Stub $stub, bool $isNested)\n    {\n        $map = [];\n\n        foreach (clone $c as $obj => $data) {\n            $map[] = new EnumStub([\n                'object' => $obj,\n                'data' => $data,\n             ]);\n        }\n\n        $a += [\n            Caster::PREFIX_VIRTUAL.'map' => $map,\n        ];\n\n        return $a;\n    }\n\n    private static function castSplArray(\\ArrayObject|\\ArrayIterator $c, array $a, Stub $stub, bool $isNested): array\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n        $flags = $c->getFlags();\n\n        if (!($flags & \\ArrayObject::STD_PROP_LIST)) {\n            $c->setFlags(\\ArrayObject::STD_PROP_LIST);\n            $a = Caster::castObject($c, $c::class, method_exists($c, '__debugInfo'), $stub->class);\n            $c->setFlags($flags);\n        }\n        $a += [\n            $prefix.'flag::STD_PROP_LIST' => (bool) ($flags & \\ArrayObject::STD_PROP_LIST),\n            $prefix.'flag::ARRAY_AS_PROPS' => (bool) ($flags & \\ArrayObject::ARRAY_AS_PROPS),\n        ];\n        if ($c instanceof \\ArrayObject) {\n            $a[$prefix.'iteratorClass'] = new ClassStub($c->getIteratorClass());\n        }\n\n        return $a;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/StubCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Casts a caster's Stub.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n *\n * @final\n */\nclass StubCaster\n{\n    /**\n     * @return array\n     */\n    public static function castStub(Stub $c, array $a, Stub $stub, bool $isNested)\n    {\n        if ($isNested) {\n            $stub->type = $c->type;\n            $stub->class = $c->class;\n            $stub->value = $c->value;\n            $stub->handle = $c->handle;\n            $stub->cut = $c->cut;\n            $stub->attr = $c->attr;\n\n            if (Stub::TYPE_REF === $c->type && !$c->class && \\is_string($c->value) && !preg_match('//u', $c->value)) {\n                $stub->type = Stub::TYPE_STRING;\n                $stub->class = Stub::STRING_BINARY;\n            }\n\n            $a = [];\n        }\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castCutArray(CutArrayStub $c, array $a, Stub $stub, bool $isNested)\n    {\n        return $isNested ? $c->preservedSubset : $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function cutInternals($obj, array $a, Stub $stub, bool $isNested)\n    {\n        if ($isNested) {\n            $stub->cut += \\count($a);\n\n            return [];\n        }\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castEnum(EnumStub $c, array $a, Stub $stub, bool $isNested)\n    {\n        if ($isNested) {\n            $stub->class = $c->dumpKeys ? '' : null;\n            $stub->handle = 0;\n            $stub->value = null;\n            $stub->cut = $c->cut;\n            $stub->attr = $c->attr;\n\n            $a = [];\n\n            if ($c->value) {\n                foreach (array_keys($c->value) as $k) {\n                    $keys[] = !isset($k[0]) || \"\\0\" !== $k[0] ? Caster::PREFIX_VIRTUAL.$k : $k;\n                }\n                // Preserve references with array_combine()\n                $a = array_combine($keys, $c->value);\n            }\n        }\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castScalar(ScalarStub $scalarStub, array $a, Stub $stub)\n    {\n        $stub->type = Stub::TYPE_SCALAR;\n        $stub->attr['value'] = $scalarStub->value;\n\n        return $a;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/SymfonyCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\Uid\\Ulid;\nuse Symfony\\Component\\Uid\\Uuid;\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\nuse Symfony\\Component\\VarExporter\\Internal\\LazyObjectState;\n\n/**\n * @final\n */\nclass SymfonyCaster\n{\n    private const REQUEST_GETTERS = [\n        'pathInfo' => 'getPathInfo',\n        'requestUri' => 'getRequestUri',\n        'baseUrl' => 'getBaseUrl',\n        'basePath' => 'getBasePath',\n        'method' => 'getMethod',\n        'format' => 'getRequestFormat',\n    ];\n\n    /**\n     * @return array\n     */\n    public static function castRequest(Request $request, array $a, Stub $stub, bool $isNested)\n    {\n        $clone = null;\n\n        foreach (self::REQUEST_GETTERS as $prop => $getter) {\n            $key = Caster::PREFIX_PROTECTED.$prop;\n            if (\\array_key_exists($key, $a) && null === $a[$key]) {\n                $clone ??= clone $request;\n                $a[Caster::PREFIX_VIRTUAL.$prop] = $clone->{$getter}();\n            }\n        }\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castHttpClient($client, array $a, Stub $stub, bool $isNested)\n    {\n        $multiKey = sprintf(\"\\0%s\\0multi\", $client::class);\n        if (isset($a[$multiKey])) {\n            $a[$multiKey] = new CutStub($a[$multiKey]);\n        }\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castHttpClientResponse($response, array $a, Stub $stub, bool $isNested)\n    {\n        $stub->cut += \\count($a);\n        $a = [];\n\n        foreach ($response->getInfo() as $k => $v) {\n            $a[Caster::PREFIX_VIRTUAL.$k] = $v;\n        }\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castLazyObjectState($state, array $a, Stub $stub, bool $isNested)\n    {\n        if (!$isNested) {\n            return $a;\n        }\n\n        $stub->cut += \\count($a) - 1;\n\n        $instance = $a['realInstance'] ?? null;\n\n        $a = ['status' => new ConstStub(match ($a['status']) {\n            LazyObjectState::STATUS_INITIALIZED_FULL => 'INITIALIZED_FULL',\n            LazyObjectState::STATUS_INITIALIZED_PARTIAL => 'INITIALIZED_PARTIAL',\n            LazyObjectState::STATUS_UNINITIALIZED_FULL => 'UNINITIALIZED_FULL',\n            LazyObjectState::STATUS_UNINITIALIZED_PARTIAL => 'UNINITIALIZED_PARTIAL',\n        }, $a['status'])];\n\n        if ($instance) {\n            $a['realInstance'] = $instance;\n            --$stub->cut;\n        }\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castUuid(Uuid $uuid, array $a, Stub $stub, bool $isNested)\n    {\n        $a[Caster::PREFIX_VIRTUAL.'toBase58'] = $uuid->toBase58();\n        $a[Caster::PREFIX_VIRTUAL.'toBase32'] = $uuid->toBase32();\n\n        // symfony/uid >= 5.3\n        if (method_exists($uuid, 'getDateTime')) {\n            $a[Caster::PREFIX_VIRTUAL.'time'] = $uuid->getDateTime()->format('Y-m-d H:i:s.u \\U\\T\\C');\n        }\n\n        return $a;\n    }\n\n    /**\n     * @return array\n     */\n    public static function castUlid(Ulid $ulid, array $a, Stub $stub, bool $isNested)\n    {\n        $a[Caster::PREFIX_VIRTUAL.'toBase58'] = $ulid->toBase58();\n        $a[Caster::PREFIX_VIRTUAL.'toRfc4122'] = $ulid->toRfc4122();\n\n        // symfony/uid >= 5.3\n        if (method_exists($ulid, 'getDateTime')) {\n            $a[Caster::PREFIX_VIRTUAL.'time'] = $ulid->getDateTime()->format('Y-m-d H:i:s.v \\U\\T\\C');\n        }\n\n        return $a;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/TraceStub.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Represents a backtrace as returned by debug_backtrace() or Exception->getTrace().\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass TraceStub extends Stub\n{\n    public $keepArgs;\n    public $sliceOffset;\n    public $sliceLength;\n    public $numberingOffset;\n\n    public function __construct(array $trace, bool $keepArgs = true, int $sliceOffset = 0, int $sliceLength = null, int $numberingOffset = 0)\n    {\n        $this->value = $trace;\n        $this->keepArgs = $keepArgs;\n        $this->sliceOffset = $sliceOffset;\n        $this->sliceLength = $sliceLength;\n        $this->numberingOffset = $numberingOffset;\n    }\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/UuidCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Ramsey\\Uuid\\UuidInterface;\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * @author Grégoire Pineau <lyrixx@lyrixx.info>\n */\nfinal class UuidCaster\n{\n    public static function castRamseyUuid(UuidInterface $c, array $a, Stub $stub, bool $isNested): array\n    {\n        $a += [\n            Caster::PREFIX_VIRTUAL.'uuid' => (string) $c,\n        ];\n\n        return $a;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/XmlReaderCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Casts XmlReader class to array representation.\n *\n * @author Baptiste Clavié <clavie.b@gmail.com>\n *\n * @final\n */\nclass XmlReaderCaster\n{\n    private const NODE_TYPES = [\n        \\XMLReader::NONE => 'NONE',\n        \\XMLReader::ELEMENT => 'ELEMENT',\n        \\XMLReader::ATTRIBUTE => 'ATTRIBUTE',\n        \\XMLReader::TEXT => 'TEXT',\n        \\XMLReader::CDATA => 'CDATA',\n        \\XMLReader::ENTITY_REF => 'ENTITY_REF',\n        \\XMLReader::ENTITY => 'ENTITY',\n        \\XMLReader::PI => 'PI (Processing Instruction)',\n        \\XMLReader::COMMENT => 'COMMENT',\n        \\XMLReader::DOC => 'DOC',\n        \\XMLReader::DOC_TYPE => 'DOC_TYPE',\n        \\XMLReader::DOC_FRAGMENT => 'DOC_FRAGMENT',\n        \\XMLReader::NOTATION => 'NOTATION',\n        \\XMLReader::WHITESPACE => 'WHITESPACE',\n        \\XMLReader::SIGNIFICANT_WHITESPACE => 'SIGNIFICANT_WHITESPACE',\n        \\XMLReader::END_ELEMENT => 'END_ELEMENT',\n        \\XMLReader::END_ENTITY => 'END_ENTITY',\n        \\XMLReader::XML_DECLARATION => 'XML_DECLARATION',\n    ];\n\n    /**\n     * @return array\n     */\n    public static function castXmlReader(\\XMLReader $reader, array $a, Stub $stub, bool $isNested)\n    {\n        try {\n            $properties = [\n                'LOADDTD' => @$reader->getParserProperty(\\XMLReader::LOADDTD),\n                'DEFAULTATTRS' => @$reader->getParserProperty(\\XMLReader::DEFAULTATTRS),\n                'VALIDATE' => @$reader->getParserProperty(\\XMLReader::VALIDATE),\n                'SUBST_ENTITIES' => @$reader->getParserProperty(\\XMLReader::SUBST_ENTITIES),\n            ];\n        } catch (\\Error) {\n            $properties = [\n                'LOADDTD' => false,\n                'DEFAULTATTRS' => false,\n                'VALIDATE' => false,\n                'SUBST_ENTITIES' => false,\n            ];\n        }\n\n        $props = Caster::PREFIX_VIRTUAL.'parserProperties';\n        $info = [\n            'localName' => $reader->localName,\n            'prefix' => $reader->prefix,\n            'nodeType' => new ConstStub(self::NODE_TYPES[$reader->nodeType], $reader->nodeType),\n            'depth' => $reader->depth,\n            'isDefault' => $reader->isDefault,\n            'isEmptyElement' => \\XMLReader::NONE === $reader->nodeType ? null : $reader->isEmptyElement,\n            'xmlLang' => $reader->xmlLang,\n            'attributeCount' => $reader->attributeCount,\n            'value' => $reader->value,\n            'namespaceURI' => $reader->namespaceURI,\n            'baseURI' => $reader->baseURI ? new LinkStub($reader->baseURI) : $reader->baseURI,\n            $props => $properties,\n        ];\n\n        if ($info[$props] = Caster::filter($info[$props], Caster::EXCLUDE_EMPTY, [], $count)) {\n            $info[$props] = new EnumStub($info[$props]);\n            $info[$props]->cut = $count;\n        }\n\n        $info = Caster::filter($info, Caster::EXCLUDE_EMPTY, [], $count);\n        // +2 because hasValue and hasAttributes are always filtered\n        $stub->cut += $count + 2;\n\n        return $a + $info;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/XmlResourceCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Casts XML resources to array representation.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n *\n * @final\n */\nclass XmlResourceCaster\n{\n    private const XML_ERRORS = [\n        \\XML_ERROR_NONE => 'XML_ERROR_NONE',\n        \\XML_ERROR_NO_MEMORY => 'XML_ERROR_NO_MEMORY',\n        \\XML_ERROR_SYNTAX => 'XML_ERROR_SYNTAX',\n        \\XML_ERROR_NO_ELEMENTS => 'XML_ERROR_NO_ELEMENTS',\n        \\XML_ERROR_INVALID_TOKEN => 'XML_ERROR_INVALID_TOKEN',\n        \\XML_ERROR_UNCLOSED_TOKEN => 'XML_ERROR_UNCLOSED_TOKEN',\n        \\XML_ERROR_PARTIAL_CHAR => 'XML_ERROR_PARTIAL_CHAR',\n        \\XML_ERROR_TAG_MISMATCH => 'XML_ERROR_TAG_MISMATCH',\n        \\XML_ERROR_DUPLICATE_ATTRIBUTE => 'XML_ERROR_DUPLICATE_ATTRIBUTE',\n        \\XML_ERROR_JUNK_AFTER_DOC_ELEMENT => 'XML_ERROR_JUNK_AFTER_DOC_ELEMENT',\n        \\XML_ERROR_PARAM_ENTITY_REF => 'XML_ERROR_PARAM_ENTITY_REF',\n        \\XML_ERROR_UNDEFINED_ENTITY => 'XML_ERROR_UNDEFINED_ENTITY',\n        \\XML_ERROR_RECURSIVE_ENTITY_REF => 'XML_ERROR_RECURSIVE_ENTITY_REF',\n        \\XML_ERROR_ASYNC_ENTITY => 'XML_ERROR_ASYNC_ENTITY',\n        \\XML_ERROR_BAD_CHAR_REF => 'XML_ERROR_BAD_CHAR_REF',\n        \\XML_ERROR_BINARY_ENTITY_REF => 'XML_ERROR_BINARY_ENTITY_REF',\n        \\XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF => 'XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF',\n        \\XML_ERROR_MISPLACED_XML_PI => 'XML_ERROR_MISPLACED_XML_PI',\n        \\XML_ERROR_UNKNOWN_ENCODING => 'XML_ERROR_UNKNOWN_ENCODING',\n        \\XML_ERROR_INCORRECT_ENCODING => 'XML_ERROR_INCORRECT_ENCODING',\n        \\XML_ERROR_UNCLOSED_CDATA_SECTION => 'XML_ERROR_UNCLOSED_CDATA_SECTION',\n        \\XML_ERROR_EXTERNAL_ENTITY_HANDLING => 'XML_ERROR_EXTERNAL_ENTITY_HANDLING',\n    ];\n\n    /**\n     * @return array\n     */\n    public static function castXml($h, array $a, Stub $stub, bool $isNested)\n    {\n        $a['current_byte_index'] = xml_get_current_byte_index($h);\n        $a['current_column_number'] = xml_get_current_column_number($h);\n        $a['current_line_number'] = xml_get_current_line_number($h);\n        $a['error_code'] = xml_get_error_code($h);\n\n        if (isset(self::XML_ERRORS[$a['error_code']])) {\n            $a['error_code'] = new ConstStub(self::XML_ERRORS[$a['error_code']], $a['error_code']);\n        }\n\n        return $a;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/CHANGELOG.md',
    "CHANGELOG\n=========\n\n6.3\n---\n\n * Add caster for `WeakMap`\n * Add support of named arguments to `dd()` and `dump()` to display the argument name\n * Add support for `Relay\\Relay`\n * Add display of invisible characters\n\n6.2\n---\n\n * Add support for `FFI\\CData` and `FFI\\CType`\n * Deprecate calling `VarDumper::setHandler()` without arguments\n\n5.4\n---\n\n * Add ability to style integer and double values independently\n * Add casters for Symfony's UUIDs and ULIDs\n * Add support for `Fiber`\n\n5.2.0\n-----\n\n * added support for PHPUnit `--colors` option\n * added `VAR_DUMPER_FORMAT=server` env var value support\n * prevent replacing the handler when the `VAR_DUMPER_FORMAT` env var is set\n\n5.1.0\n-----\n\n * added `RdKafka` support\n\n4.4.0\n-----\n\n * added `VarDumperTestTrait::setUpVarDumper()` and `VarDumperTestTrait::tearDownVarDumper()`\n   to configure casters & flags to use in tests\n * added `ImagineCaster` and infrastructure to dump images\n * added the stamps of a message after it is dispatched in `TraceableMessageBus` and `MessengerDataCollector` collected data\n * added `UuidCaster`\n * made all casters final\n * added support for the `NO_COLOR` env var (https://no-color.org/)\n\n4.3.0\n-----\n\n * added `DsCaster` to support dumping the contents of data structures from the Ds extension\n\n4.2.0\n-----\n\n * support selecting the format to use by setting the environment variable `VAR_DUMPER_FORMAT` to `html` or `cli`\n\n4.1.0\n-----\n\n * added a `ServerDumper` to send serialized Data clones to a server\n * added a `ServerDumpCommand` and `DumpServer` to run a server collecting\n   and displaying dumps on a single place with multiple formats support\n * added `CliDescriptor` and `HtmlDescriptor` descriptors for `server:dump` CLI and HTML formats support\n\n4.0.0\n-----\n\n * support for passing `\\ReflectionClass` instances to the `Caster::castObject()`\n   method has been dropped, pass class names as strings instead\n * the `Data::getRawData()` method has been removed\n * the `VarDumperTestTrait::assertDumpEquals()` method expects a 3rd `$filter = 0`\n   argument and moves `$message = ''` argument at 4th position.\n * the `VarDumperTestTrait::assertDumpMatchesFormat()` method expects a 3rd `$filter = 0`\n   argument and moves `$message = ''` argument at 4th position.\n\n3.4.0\n-----\n\n * added `AbstractCloner::setMinDepth()` function to ensure minimum tree depth\n * deprecated `MongoCaster`\n\n2.7.0\n-----\n\n * deprecated `Cloner\\Data::getLimitedClone()`. Use `withMaxDepth`, `withMaxItemsPerDepth` or `withRefHandles` instead.\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Cloner/AbstractCloner.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Cloner;\n\nuse Symfony\\Component\\VarDumper\\Caster\\Caster;\nuse Symfony\\Component\\VarDumper\\Exception\\ThrowingCasterException;\n\n/**\n * AbstractCloner implements a generic caster mechanism for objects and resources.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nabstract class AbstractCloner implements ClonerInterface\n{\n    public static $defaultCasters = [\n        '__PHP_Incomplete_Class' => ['Symfony\\Component\\VarDumper\\Caster\\Caster', 'castPhpIncompleteClass'],\n\n        'Symfony\\Component\\VarDumper\\Caster\\CutStub' => ['Symfony\\Component\\VarDumper\\Caster\\StubCaster', 'castStub'],\n        'Symfony\\Component\\VarDumper\\Caster\\CutArrayStub' => ['Symfony\\Component\\VarDumper\\Caster\\StubCaster', 'castCutArray'],\n        'Symfony\\Component\\VarDumper\\Caster\\ConstStub' => ['Symfony\\Component\\VarDumper\\Caster\\StubCaster', 'castStub'],\n        'Symfony\\Component\\VarDumper\\Caster\\EnumStub' => ['Symfony\\Component\\VarDumper\\Caster\\StubCaster', 'castEnum'],\n        'Symfony\\Component\\VarDumper\\Caster\\ScalarStub' => ['Symfony\\Component\\VarDumper\\Caster\\StubCaster', 'castScalar'],\n\n        'Fiber' => ['Symfony\\Component\\VarDumper\\Caster\\FiberCaster', 'castFiber'],\n\n        'Closure' => ['Symfony\\Component\\VarDumper\\Caster\\ReflectionCaster', 'castClosure'],\n        'Generator' => ['Symfony\\Component\\VarDumper\\Caster\\ReflectionCaster', 'castGenerator'],\n        'ReflectionType' => ['Symfony\\Component\\VarDumper\\Caster\\ReflectionCaster', 'castType'],\n        'ReflectionAttribute' => ['Symfony\\Component\\VarDumper\\Caster\\ReflectionCaster', 'castAttribute'],\n        'ReflectionGenerator' => ['Symfony\\Component\\VarDumper\\Caster\\ReflectionCaster', 'castReflectionGenerator'],\n        'ReflectionClass' => ['Symfony\\Component\\VarDumper\\Caster\\ReflectionCaster', 'castClass'],\n        'ReflectionClassConstant' => ['Symfony\\Component\\VarDumper\\Caster\\ReflectionCaster', 'castClassConstant'],\n        'ReflectionFunctionAbstract' => ['Symfony\\Component\\VarDumper\\Caster\\ReflectionCaster', 'castFunctionAbstract'],\n        'ReflectionMethod' => ['Symfony\\Component\\VarDumper\\Caster\\ReflectionCaster', 'castMethod'],\n        'ReflectionParameter' => ['Symfony\\Component\\VarDumper\\Caster\\ReflectionCaster', 'castParameter'],\n        'ReflectionProperty' => ['Symfony\\Component\\VarDumper\\Caster\\ReflectionCaster', 'castProperty'],\n        'ReflectionReference' => ['Symfony\\Component\\VarDumper\\Caster\\ReflectionCaster', 'castReference'],\n        'ReflectionExtension' => ['Symfony\\Component\\VarDumper\\Caster\\ReflectionCaster', 'castExtension'],\n        'ReflectionZendExtension' => ['Symfony\\Component\\VarDumper\\Caster\\ReflectionCaster', 'castZendExtension'],\n\n        'Doctrine\\Common\\Persistence\\ObjectManager' => ['Symfony\\Component\\VarDumper\\Caster\\StubCaster', 'cutInternals'],\n        'Doctrine\\Common\\Proxy\\Proxy' => ['Symfony\\Component\\VarDumper\\Caster\\DoctrineCaster', 'castCommonProxy'],\n        'Doctrine\\ORM\\Proxy\\Proxy' => ['Symfony\\Component\\VarDumper\\Caster\\DoctrineCaster', 'castOrmProxy'],\n        'Doctrine\\ORM\\PersistentCollection' => ['Symfony\\Component\\VarDumper\\Caster\\DoctrineCaster', 'castPersistentCollection'],\n        'Doctrine\\Persistence\\ObjectManager' => ['Symfony\\Component\\VarDumper\\Caster\\StubCaster', 'cutInternals'],\n\n        'DOMException' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castException'],\n        'DOMStringList' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castLength'],\n        'DOMNameList' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castLength'],\n        'DOMImplementation' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castImplementation'],\n        'DOMImplementationList' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castLength'],\n        'DOMNode' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castNode'],\n        'DOMNameSpaceNode' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castNameSpaceNode'],\n        'DOMDocument' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castDocument'],\n        'DOMNodeList' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castLength'],\n        'DOMNamedNodeMap' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castLength'],\n        'DOMCharacterData' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castCharacterData'],\n        'DOMAttr' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castAttr'],\n        'DOMElement' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castElement'],\n        'DOMText' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castText'],\n        'DOMDocumentType' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castDocumentType'],\n        'DOMNotation' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castNotation'],\n        'DOMEntity' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castEntity'],\n        'DOMProcessingInstruction' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castProcessingInstruction'],\n        'DOMXPath' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castXPath'],\n\n        'XMLReader' => ['Symfony\\Component\\VarDumper\\Caster\\XmlReaderCaster', 'castXmlReader'],\n\n        'ErrorException' => ['Symfony\\Component\\VarDumper\\Caster\\ExceptionCaster', 'castErrorException'],\n        'Exception' => ['Symfony\\Component\\VarDumper\\Caster\\ExceptionCaster', 'castException'],\n        'Error' => ['Symfony\\Component\\VarDumper\\Caster\\ExceptionCaster', 'castError'],\n        'Symfony\\Bridge\\Monolog\\Logger' => ['Symfony\\Component\\VarDumper\\Caster\\StubCaster', 'cutInternals'],\n        'Symfony\\Component\\DependencyInjection\\ContainerInterface' => ['Symfony\\Component\\VarDumper\\Caster\\StubCaster', 'cutInternals'],\n        'Symfony\\Component\\EventDispatcher\\EventDispatcherInterface' => ['Symfony\\Component\\VarDumper\\Caster\\StubCaster', 'cutInternals'],\n        'Symfony\\Component\\HttpClient\\AmpHttpClient' => ['Symfony\\Component\\VarDumper\\Caster\\SymfonyCaster', 'castHttpClient'],\n        'Symfony\\Component\\HttpClient\\CurlHttpClient' => ['Symfony\\Component\\VarDumper\\Caster\\SymfonyCaster', 'castHttpClient'],\n        'Symfony\\Component\\HttpClient\\NativeHttpClient' => ['Symfony\\Component\\VarDumper\\Caster\\SymfonyCaster', 'castHttpClient'],\n        'Symfony\\Component\\HttpClient\\Response\\AmpResponse' => ['Symfony\\Component\\VarDumper\\Caster\\SymfonyCaster', 'castHttpClientResponse'],\n        'Symfony\\Component\\HttpClient\\Response\\CurlResponse' => ['Symfony\\Component\\VarDumper\\Caster\\SymfonyCaster', 'castHttpClientResponse'],\n        'Symfony\\Component\\HttpClient\\Response\\NativeResponse' => ['Symfony\\Component\\VarDumper\\Caster\\SymfonyCaster', 'castHttpClientResponse'],\n        'Symfony\\Component\\HttpFoundation\\Request' => ['Symfony\\Component\\VarDumper\\Caster\\SymfonyCaster', 'castRequest'],\n        'Symfony\\Component\\Uid\\Ulid' => ['Symfony\\Component\\VarDumper\\Caster\\SymfonyCaster', 'castUlid'],\n        'Symfony\\Component\\Uid\\Uuid' => ['Symfony\\Component\\VarDumper\\Caster\\SymfonyCaster', 'castUuid'],\n        'Symfony\\Component\\VarExporter\\Internal\\LazyObjectState' => ['Symfony\\Component\\VarDumper\\Caster\\SymfonyCaster', 'castLazyObjectState'],\n        'Symfony\\Component\\VarDumper\\Exception\\ThrowingCasterException' => ['Symfony\\Component\\VarDumper\\Caster\\ExceptionCaster', 'castThrowingCasterException'],\n        'Symfony\\Component\\VarDumper\\Caster\\TraceStub' => ['Symfony\\Component\\VarDumper\\Caster\\ExceptionCaster', 'castTraceStub'],\n        'Symfony\\Component\\VarDumper\\Caster\\FrameStub' => ['Symfony\\Component\\VarDumper\\Caster\\ExceptionCaster', 'castFrameStub'],\n        'Symfony\\Component\\VarDumper\\Cloner\\AbstractCloner' => ['Symfony\\Component\\VarDumper\\Caster\\StubCaster', 'cutInternals'],\n        'Symfony\\Component\\ErrorHandler\\Exception\\FlattenException' => ['Symfony\\Component\\VarDumper\\Caster\\ExceptionCaster', 'castFlattenException'],\n        'Symfony\\Component\\ErrorHandler\\Exception\\SilencedErrorContext' => ['Symfony\\Component\\VarDumper\\Caster\\ExceptionCaster', 'castSilencedErrorContext'],\n\n        'Imagine\\Image\\ImageInterface' => ['Symfony\\Component\\VarDumper\\Caster\\ImagineCaster', 'castImage'],\n\n        'Ramsey\\Uuid\\UuidInterface' => ['Symfony\\Component\\VarDumper\\Caster\\UuidCaster', 'castRamseyUuid'],\n\n        'ProxyManager\\Proxy\\ProxyInterface' => ['Symfony\\Component\\VarDumper\\Caster\\ProxyManagerCaster', 'castProxy'],\n        'PHPUnit_Framework_MockObject_MockObject' => ['Symfony\\Component\\VarDumper\\Caster\\StubCaster', 'cutInternals'],\n        'PHPUnit\\Framework\\MockObject\\MockObject' => ['Symfony\\Component\\VarDumper\\Caster\\StubCaster', 'cutInternals'],\n        'PHPUnit\\Framework\\MockObject\\Stub' => ['Symfony\\Component\\VarDumper\\Caster\\StubCaster', 'cutInternals'],\n        'Prophecy\\Prophecy\\ProphecySubjectInterface' => ['Symfony\\Component\\VarDumper\\Caster\\StubCaster', 'cutInternals'],\n        'Mockery\\MockInterface' => ['Symfony\\Component\\VarDumper\\Caster\\StubCaster', 'cutInternals'],\n\n        'PDO' => ['Symfony\\Component\\VarDumper\\Caster\\PdoCaster', 'castPdo'],\n        'PDOStatement' => ['Symfony\\Component\\VarDumper\\Caster\\PdoCaster', 'castPdoStatement'],\n\n        'AMQPConnection' => ['Symfony\\Component\\VarDumper\\Caster\\AmqpCaster', 'castConnection'],\n        'AMQPChannel' => ['Symfony\\Component\\VarDumper\\Caster\\AmqpCaster', 'castChannel'],\n        'AMQPQueue' => ['Symfony\\Component\\VarDumper\\Caster\\AmqpCaster', 'castQueue'],\n        'AMQPExchange' => ['Symfony\\Component\\VarDumper\\Caster\\AmqpCaster', 'castExchange'],\n        'AMQPEnvelope' => ['Symfony\\Component\\VarDumper\\Caster\\AmqpCaster', 'castEnvelope'],\n\n        'ArrayObject' => ['Symfony\\Component\\VarDumper\\Caster\\SplCaster', 'castArrayObject'],\n        'ArrayIterator' => ['Symfony\\Component\\VarDumper\\Caster\\SplCaster', 'castArrayIterator'],\n        'SplDoublyLinkedList' => ['Symfony\\Component\\VarDumper\\Caster\\SplCaster', 'castDoublyLinkedList'],\n        'SplFileInfo' => ['Symfony\\Component\\VarDumper\\Caster\\SplCaster', 'castFileInfo'],\n        'SplFileObject' => ['Symfony\\Component\\VarDumper\\Caster\\SplCaster', 'castFileObject'],\n        'SplHeap' => ['Symfony\\Component\\VarDumper\\Caster\\SplCaster', 'castHeap'],\n        'SplObjectStorage' => ['Symfony\\Component\\VarDumper\\Caster\\SplCaster', 'castObjectStorage'],\n        'SplPriorityQueue' => ['Symfony\\Component\\VarDumper\\Caster\\SplCaster', 'castHeap'],\n        'OuterIterator' => ['Symfony\\Component\\VarDumper\\Caster\\SplCaster', 'castOuterIterator'],\n        'WeakMap' => ['Symfony\\Component\\VarDumper\\Caster\\SplCaster', 'castWeakMap'],\n        'WeakReference' => ['Symfony\\Component\\VarDumper\\Caster\\SplCaster', 'castWeakReference'],\n\n        'Redis' => ['Symfony\\Component\\VarDumper\\Caster\\RedisCaster', 'castRedis'],\n        'Relay\\Relay' => ['Symfony\\Component\\VarDumper\\Caster\\RedisCaster', 'castRedis'],\n        'RedisArray' => ['Symfony\\Component\\VarDumper\\Caster\\RedisCaster', 'castRedisArray'],\n        'RedisCluster' => ['Symfony\\Component\\VarDumper\\Caster\\RedisCaster', 'castRedisCluster'],\n\n        'DateTimeInterface' => ['Symfony\\Component\\VarDumper\\Caster\\DateCaster', 'castDateTime'],\n        'DateInterval' => ['Symfony\\Component\\VarDumper\\Caster\\DateCaster', 'castInterval'],\n        'DateTimeZone' => ['Symfony\\Component\\VarDumper\\Caster\\DateCaster', 'castTimeZone'],\n        'DatePeriod' => ['Symfony\\Component\\VarDumper\\Caster\\DateCaster', 'castPeriod'],\n\n        'GMP' => ['Symfony\\Component\\VarDumper\\Caster\\GmpCaster', 'castGmp'],\n\n        'MessageFormatter' => ['Symfony\\Component\\VarDumper\\Caster\\IntlCaster', 'castMessageFormatter'],\n        'NumberFormatter' => ['Symfony\\Component\\VarDumper\\Caster\\IntlCaster', 'castNumberFormatter'],\n        'IntlTimeZone' => ['Symfony\\Component\\VarDumper\\Caster\\IntlCaster', 'castIntlTimeZone'],\n        'IntlCalendar' => ['Symfony\\Component\\VarDumper\\Caster\\IntlCaster', 'castIntlCalendar'],\n        'IntlDateFormatter' => ['Symfony\\Component\\VarDumper\\Caster\\IntlCaster', 'castIntlDateFormatter'],\n\n        'Memcached' => ['Symfony\\Component\\VarDumper\\Caster\\MemcachedCaster', 'castMemcached'],\n\n        'Ds\\Collection' => ['Symfony\\Component\\VarDumper\\Caster\\DsCaster', 'castCollection'],\n        'Ds\\Map' => ['Symfony\\Component\\VarDumper\\Caster\\DsCaster', 'castMap'],\n        'Ds\\Pair' => ['Symfony\\Component\\VarDumper\\Caster\\DsCaster', 'castPair'],\n        'Symfony\\Component\\VarDumper\\Caster\\DsPairStub' => ['Symfony\\Component\\VarDumper\\Caster\\DsCaster', 'castPairStub'],\n\n        'mysqli_driver' => ['Symfony\\Component\\VarDumper\\Caster\\MysqliCaster', 'castMysqliDriver'],\n\n        'CurlHandle' => ['Symfony\\Component\\VarDumper\\Caster\\ResourceCaster', 'castCurl'],\n\n        ':dba' => ['Symfony\\Component\\VarDumper\\Caster\\ResourceCaster', 'castDba'],\n        ':dba persistent' => ['Symfony\\Component\\VarDumper\\Caster\\ResourceCaster', 'castDba'],\n\n        'GdImage' => ['Symfony\\Component\\VarDumper\\Caster\\ResourceCaster', 'castGd'],\n        ':gd' => ['Symfony\\Component\\VarDumper\\Caster\\ResourceCaster', 'castGd'],\n\n        ':pgsql large object' => ['Symfony\\Component\\VarDumper\\Caster\\PgSqlCaster', 'castLargeObject'],\n        ':pgsql link' => ['Symfony\\Component\\VarDumper\\Caster\\PgSqlCaster', 'castLink'],\n        ':pgsql link persistent' => ['Symfony\\Component\\VarDumper\\Caster\\PgSqlCaster', 'castLink'],\n        ':pgsql result' => ['Symfony\\Component\\VarDumper\\Caster\\PgSqlCaster', 'castResult'],\n        ':process' => ['Symfony\\Component\\VarDumper\\Caster\\ResourceCaster', 'castProcess'],\n        ':stream' => ['Symfony\\Component\\VarDumper\\Caster\\ResourceCaster', 'castStream'],\n\n        'OpenSSLCertificate' => ['Symfony\\Component\\VarDumper\\Caster\\ResourceCaster', 'castOpensslX509'],\n        ':OpenSSL X.509' => ['Symfony\\Component\\VarDumper\\Caster\\ResourceCaster', 'castOpensslX509'],\n\n        ':persistent stream' => ['Symfony\\Component\\VarDumper\\Caster\\ResourceCaster', 'castStream'],\n        ':stream-context' => ['Symfony\\Component\\VarDumper\\Caster\\ResourceCaster', 'castStreamContext'],\n\n        'XmlParser' => ['Symfony\\Component\\VarDumper\\Caster\\XmlResourceCaster', 'castXml'],\n        ':xml' => ['Symfony\\Component\\VarDumper\\Caster\\XmlResourceCaster', 'castXml'],\n\n        'RdKafka' => ['Symfony\\Component\\VarDumper\\Caster\\RdKafkaCaster', 'castRdKafka'],\n        'RdKafka\\Conf' => ['Symfony\\Component\\VarDumper\\Caster\\RdKafkaCaster', 'castConf'],\n        'RdKafka\\KafkaConsumer' => ['Symfony\\Component\\VarDumper\\Caster\\RdKafkaCaster', 'castKafkaConsumer'],\n        'RdKafka\\Metadata\\Broker' => ['Symfony\\Component\\VarDumper\\Caster\\RdKafkaCaster', 'castBrokerMetadata'],\n        'RdKafka\\Metadata\\Collection' => ['Symfony\\Component\\VarDumper\\Caster\\RdKafkaCaster', 'castCollectionMetadata'],\n        'RdKafka\\Metadata\\Partition' => ['Symfony\\Component\\VarDumper\\Caster\\RdKafkaCaster', 'castPartitionMetadata'],\n        'RdKafka\\Metadata\\Topic' => ['Symfony\\Component\\VarDumper\\Caster\\RdKafkaCaster', 'castTopicMetadata'],\n        'RdKafka\\Message' => ['Symfony\\Component\\VarDumper\\Caster\\RdKafkaCaster', 'castMessage'],\n        'RdKafka\\Topic' => ['Symfony\\Component\\VarDumper\\Caster\\RdKafkaCaster', 'castTopic'],\n        'RdKafka\\TopicPartition' => ['Symfony\\Component\\VarDumper\\Caster\\RdKafkaCaster', 'castTopicPartition'],\n        'RdKafka\\TopicConf' => ['Symfony\\Component\\VarDumper\\Caster\\RdKafkaCaster', 'castTopicConf'],\n\n        'FFI\\CData' => ['Symfony\\Component\\VarDumper\\Caster\\FFICaster', 'castCTypeOrCData'],\n        'FFI\\CType' => ['Symfony\\Component\\VarDumper\\Caster\\FFICaster', 'castCTypeOrCData'],\n    ];\n\n    protected $maxItems = 2500;\n    protected $maxString = -1;\n    protected $minDepth = 1;\n\n    /**\n     * @var array<string, list<callable>>\n     */\n    private array $casters = [];\n\n    /**\n     * @var callable|null\n     */\n    private $prevErrorHandler;\n\n    private array $classInfo = [];\n    private int $filter = 0;\n\n    /**\n     * @param callable[]|null $casters A map of casters\n     *\n     * @see addCasters\n     */\n    public function __construct(array $casters = null)\n    {\n        $this->addCasters($casters ?? static::$defaultCasters);\n    }\n\n    /**\n     * Adds casters for resources and objects.\n     *\n     * Maps resources or objects types to a callback.\n     * Types are in the key, with a callable caster for value.\n     * Resource types are to be prefixed with a `:`,\n     * see e.g. static::$defaultCasters.\n     *\n     * @param callable[] $casters A map of casters\n     *\n     * @return void\n     */\n    public function addCasters(array $casters)\n    {\n        foreach ($casters as $type => $callback) {\n            $this->casters[$type][] = $callback;\n        }\n    }\n\n    /**\n     * Sets the maximum number of items to clone past the minimum depth in nested structures.\n     *\n     * @return void\n     */\n    public function setMaxItems(int $maxItems)\n    {\n        $this->maxItems = $maxItems;\n    }\n\n    /**\n     * Sets the maximum cloned length for strings.\n     *\n     * @return void\n     */\n    public function setMaxString(int $maxString)\n    {\n        $this->maxString = $maxString;\n    }\n\n    /**\n     * Sets the minimum tree depth where we are guaranteed to clone all the items.  After this\n     * depth is reached, only setMaxItems items will be cloned.\n     *\n     * @return void\n     */\n    public function setMinDepth(int $minDepth)\n    {\n        $this->minDepth = $minDepth;\n    }\n\n    /**\n     * Clones a PHP variable.\n     *\n     * @param int $filter A bit field of Caster::EXCLUDE_* constants\n     */\n    public function cloneVar(mixed $var, int $filter = 0): Data\n    {\n        $this->prevErrorHandler = set_error_handler(function ($type, $msg, $file, $line, $context = []) {\n            if (\\E_RECOVERABLE_ERROR === $type || \\E_USER_ERROR === $type) {\n                // Cloner never dies\n                throw new \\ErrorException($msg, 0, $type, $file, $line);\n            }\n\n            if ($this->prevErrorHandler) {\n                return ($this->prevErrorHandler)($type, $msg, $file, $line, $context);\n            }\n\n            return false;\n        });\n        $this->filter = $filter;\n\n        if ($gc = gc_enabled()) {\n            gc_disable();\n        }\n        try {\n            return new Data($this->doClone($var));\n        } finally {\n            if ($gc) {\n                gc_enable();\n            }\n            restore_error_handler();\n            $this->prevErrorHandler = null;\n        }\n    }\n\n    /**\n     * Effectively clones the PHP variable.\n     */\n    abstract protected function doClone(mixed $var): array;\n\n    /**\n     * Casts an object to an array representation.\n     *\n     * @param bool $isNested True if the object is nested in the dumped structure\n     */\n    protected function castObject(Stub $stub, bool $isNested): array\n    {\n        $obj = $stub->value;\n        $class = $stub->class;\n\n        if (str_contains($class, \"@anonymous\\0\")) {\n            $stub->class = get_debug_type($obj);\n        }\n        if (isset($this->classInfo[$class])) {\n            [$i, $parents, $hasDebugInfo, $fileInfo] = $this->classInfo[$class];\n        } else {\n            $i = 2;\n            $parents = [$class];\n            $hasDebugInfo = method_exists($class, '__debugInfo');\n\n            foreach (class_parents($class) as $p) {\n                $parents[] = $p;\n                ++$i;\n            }\n            foreach (class_implements($class) as $p) {\n                $parents[] = $p;\n                ++$i;\n            }\n            $parents[] = '*';\n\n            $r = new \\ReflectionClass($class);\n            $fileInfo = $r->isInternal() || $r->isSubclassOf(Stub::class) ? [] : [\n                'file' => $r->getFileName(),\n                'line' => $r->getStartLine(),\n            ];\n\n            $this->classInfo[$class] = [$i, $parents, $hasDebugInfo, $fileInfo];\n        }\n\n        $stub->attr += $fileInfo;\n        $a = Caster::castObject($obj, $class, $hasDebugInfo, $stub->class);\n\n        try {\n            while ($i--) {\n                if (!empty($this->casters[$p = $parents[$i]])) {\n                    foreach ($this->casters[$p] as $callback) {\n                        $a = $callback($obj, $a, $stub, $isNested, $this->filter);\n                    }\n                }\n            }\n        } catch (\\Exception $e) {\n            $a = [(Stub::TYPE_OBJECT === $stub->type ? Caster::PREFIX_VIRTUAL : '').'⚠' => new ThrowingCasterException($e)] + $a;\n        }\n\n        return $a;\n    }\n\n    /**\n     * Casts a resource to an array representation.\n     *\n     * @param bool $isNested True if the object is nested in the dumped structure\n     */\n    protected function castResource(Stub $stub, bool $isNested): array\n    {\n        $a = [];\n        $res = $stub->value;\n        $type = $stub->class;\n\n        try {\n            if (!empty($this->casters[':'.$type])) {\n                foreach ($this->casters[':'.$type] as $callback) {\n                    $a = $callback($res, $a, $stub, $isNested, $this->filter);\n                }\n            }\n        } catch (\\Exception $e) {\n            $a = [(Stub::TYPE_OBJECT === $stub->type ? Caster::PREFIX_VIRTUAL : '').'⚠' => new ThrowingCasterException($e)] + $a;\n        }\n\n        return $a;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Cloner/ClonerInterface.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Cloner;\n\n/**\n * @author Nicolas Grekas <p@tchwork.com>\n */\ninterface ClonerInterface\n{\n    /**\n     * Clones a PHP variable.\n     */\n    public function cloneVar(mixed $var): Data;\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Cloner/Cursor.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Cloner;\n\n/**\n * Represents the current state of a dumper while dumping.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass Cursor\n{\n    public const HASH_INDEXED = Stub::ARRAY_INDEXED;\n    public const HASH_ASSOC = Stub::ARRAY_ASSOC;\n    public const HASH_OBJECT = Stub::TYPE_OBJECT;\n    public const HASH_RESOURCE = Stub::TYPE_RESOURCE;\n\n    public $depth = 0;\n    public $refIndex = 0;\n    public $softRefTo = 0;\n    public $softRefCount = 0;\n    public $softRefHandle = 0;\n    public $hardRefTo = 0;\n    public $hardRefCount = 0;\n    public $hardRefHandle = 0;\n    public $hashType;\n    public $hashKey;\n    public $hashKeyIsBinary;\n    public $hashIndex = 0;\n    public $hashLength = 0;\n    public $hashCut = 0;\n    public $stop = false;\n    public $attr = [];\n    public $skipChildren = false;\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Cloner/Data.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Cloner;\n\nuse Symfony\\Component\\VarDumper\\Caster\\Caster;\nuse Symfony\\Component\\VarDumper\\Dumper\\ContextProvider\\SourceContextProvider;\n\n/**\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass Data implements \\ArrayAccess, \\Countable, \\IteratorAggregate\n{\n    private array $data;\n    private int $position = 0;\n    private int|string $key = 0;\n    private int $maxDepth = 20;\n    private int $maxItemsPerDepth = -1;\n    private int $useRefHandles = -1;\n    private array $context = [];\n\n    /**\n     * @param array $data An array as returned by ClonerInterface::cloneVar()\n     */\n    public function __construct(array $data)\n    {\n        $this->data = $data;\n    }\n\n    public function getType(): ?string\n    {\n        $item = $this->data[$this->position][$this->key];\n\n        if ($item instanceof Stub && Stub::TYPE_REF === $item->type && !$item->position) {\n            $item = $item->value;\n        }\n        if (!$item instanceof Stub) {\n            return \\gettype($item);\n        }\n        if (Stub::TYPE_STRING === $item->type) {\n            return 'string';\n        }\n        if (Stub::TYPE_ARRAY === $item->type) {\n            return 'array';\n        }\n        if (Stub::TYPE_OBJECT === $item->type) {\n            return $item->class;\n        }\n        if (Stub::TYPE_RESOURCE === $item->type) {\n            return $item->class.' resource';\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns a native representation of the original value.\n     *\n     * @param array|bool $recursive Whether values should be resolved recursively or not\n     *\n     * @return string|int|float|bool|array|Data[]|null\n     */\n    public function getValue(array|bool $recursive = false): string|int|float|bool|array|null\n    {\n        $item = $this->data[$this->position][$this->key];\n\n        if ($item instanceof Stub && Stub::TYPE_REF === $item->type && !$item->position) {\n            $item = $item->value;\n        }\n        if (!($item = $this->getStub($item)) instanceof Stub) {\n            return $item;\n        }\n        if (Stub::TYPE_STRING === $item->type) {\n            return $item->value;\n        }\n\n        $children = $item->position ? $this->data[$item->position] : [];\n\n        foreach ($children as $k => $v) {\n            if ($recursive && !($v = $this->getStub($v)) instanceof Stub) {\n                continue;\n            }\n            $children[$k] = clone $this;\n            $children[$k]->key = $k;\n            $children[$k]->position = $item->position;\n\n            if ($recursive) {\n                if (Stub::TYPE_REF === $v->type && ($v = $this->getStub($v->value)) instanceof Stub) {\n                    $recursive = (array) $recursive;\n                    if (isset($recursive[$v->position])) {\n                        continue;\n                    }\n                    $recursive[$v->position] = true;\n                }\n                $children[$k] = $children[$k]->getValue($recursive);\n            }\n        }\n\n        return $children;\n    }\n\n    public function count(): int\n    {\n        return \\count($this->getValue());\n    }\n\n    public function getIterator(): \\Traversable\n    {\n        if (!\\is_array($value = $this->getValue())) {\n            throw new \\LogicException(sprintf('\"%s\" object holds non-iterable type \"%s\".', self::class, get_debug_type($value)));\n        }\n\n        yield from $value;\n    }\n\n    public function __get(string $key)\n    {\n        if (null !== $data = $this->seek($key)) {\n            $item = $this->getStub($data->data[$data->position][$data->key]);\n\n            return $item instanceof Stub || [] === $item ? $data : $item;\n        }\n\n        return null;\n    }\n\n    public function __isset(string $key): bool\n    {\n        return null !== $this->seek($key);\n    }\n\n    public function offsetExists(mixed $key): bool\n    {\n        return $this->__isset($key);\n    }\n\n    public function offsetGet(mixed $key): mixed\n    {\n        return $this->__get($key);\n    }\n\n    public function offsetSet(mixed $key, mixed $value): void\n    {\n        throw new \\BadMethodCallException(self::class.' objects are immutable.');\n    }\n\n    public function offsetUnset(mixed $key): void\n    {\n        throw new \\BadMethodCallException(self::class.' objects are immutable.');\n    }\n\n    public function __toString(): string\n    {\n        $value = $this->getValue();\n\n        if (!\\is_array($value)) {\n            return (string) $value;\n        }\n\n        return sprintf('%s (count=%d)', $this->getType(), \\count($value));\n    }\n\n    /**\n     * Returns a depth limited clone of $this.\n     */\n    public function withMaxDepth(int $maxDepth): static\n    {\n        $data = clone $this;\n        $data->maxDepth = $maxDepth;\n\n        return $data;\n    }\n\n    /**\n     * Limits the number of elements per depth level.\n     */\n    public function withMaxItemsPerDepth(int $maxItemsPerDepth): static\n    {\n        $data = clone $this;\n        $data->maxItemsPerDepth = $maxItemsPerDepth;\n\n        return $data;\n    }\n\n    /**\n     * Enables/disables objects' identifiers tracking.\n     *\n     * @param bool $useRefHandles False to hide global ref. handles\n     */\n    public function withRefHandles(bool $useRefHandles): static\n    {\n        $data = clone $this;\n        $data->useRefHandles = $useRefHandles ? -1 : 0;\n\n        return $data;\n    }\n\n    public function withContext(array $context): static\n    {\n        $data = clone $this;\n        $data->context = $context;\n\n        return $data;\n    }\n\n    public function getContext(): array\n    {\n        return $this->context;\n    }\n\n    /**\n     * Seeks to a specific key in nested data structures.\n     */\n    public function seek(string|int $key): ?static\n    {\n        $item = $this->data[$this->position][$this->key];\n\n        if ($item instanceof Stub && Stub::TYPE_REF === $item->type && !$item->position) {\n            $item = $item->value;\n        }\n        if (!($item = $this->getStub($item)) instanceof Stub || !$item->position) {\n            return null;\n        }\n        $keys = [$key];\n\n        switch ($item->type) {\n            case Stub::TYPE_OBJECT:\n                $keys[] = Caster::PREFIX_DYNAMIC.$key;\n                $keys[] = Caster::PREFIX_PROTECTED.$key;\n                $keys[] = Caster::PREFIX_VIRTUAL.$key;\n                $keys[] = \"\\0$item->class\\0$key\";\n                // no break\n            case Stub::TYPE_ARRAY:\n            case Stub::TYPE_RESOURCE:\n                break;\n            default:\n                return null;\n        }\n\n        $data = null;\n        $children = $this->data[$item->position];\n\n        foreach ($keys as $key) {\n            if (isset($children[$key]) || \\array_key_exists($key, $children)) {\n                $data = clone $this;\n                $data->key = $key;\n                $data->position = $item->position;\n                break;\n            }\n        }\n\n        return $data;\n    }\n\n    /**\n     * Dumps data with a DumperInterface dumper.\n     *\n     * @return void\n     */\n    public function dump(DumperInterface $dumper)\n    {\n        $refs = [0];\n        $cursor = new Cursor();\n        $cursor->hashType = -1;\n        $cursor->attr = $this->context[SourceContextProvider::class] ?? [];\n        $label = $this->context['label'] ?? '';\n\n        if ($cursor->attr || '' !== $label) {\n            $dumper->dumpScalar($cursor, 'label', $label);\n        }\n        $cursor->hashType = 0;\n        $this->dumpItem($dumper, $cursor, $refs, $this->data[$this->position][$this->key]);\n    }\n\n    /**\n     * Depth-first dumping of items.\n     *\n     * @param mixed $item A Stub object or the original value being dumped\n     */\n    private function dumpItem(DumperInterface $dumper, Cursor $cursor, array &$refs, mixed $item): void\n    {\n        $cursor->refIndex = 0;\n        $cursor->softRefTo = $cursor->softRefHandle = $cursor->softRefCount = 0;\n        $cursor->hardRefTo = $cursor->hardRefHandle = $cursor->hardRefCount = 0;\n        $firstSeen = true;\n\n        if (!$item instanceof Stub) {\n            $cursor->attr = [];\n            $type = \\gettype($item);\n            if ($item && 'array' === $type) {\n                $item = $this->getStub($item);\n            }\n        } elseif (Stub::TYPE_REF === $item->type) {\n            if ($item->handle) {\n                if (!isset($refs[$r = $item->handle - (\\PHP_INT_MAX >> 1)])) {\n                    $cursor->refIndex = $refs[$r] = $cursor->refIndex ?: ++$refs[0];\n                } else {\n                    $firstSeen = false;\n                }\n                $cursor->hardRefTo = $refs[$r];\n                $cursor->hardRefHandle = $this->useRefHandles & $item->handle;\n                $cursor->hardRefCount = 0 < $item->handle ? $item->refCount : 0;\n            }\n            $cursor->attr = $item->attr;\n            $type = $item->class ?: \\gettype($item->value);\n            $item = $this->getStub($item->value);\n        }\n        if ($item instanceof Stub) {\n            if ($item->refCount) {\n                if (!isset($refs[$r = $item->handle])) {\n                    $cursor->refIndex = $refs[$r] = $cursor->refIndex ?: ++$refs[0];\n                } else {\n                    $firstSeen = false;\n                }\n                $cursor->softRefTo = $refs[$r];\n            }\n            $cursor->softRefHandle = $this->useRefHandles & $item->handle;\n            $cursor->softRefCount = $item->refCount;\n            $cursor->attr = $item->attr;\n            $cut = $item->cut;\n\n            if ($item->position && $firstSeen) {\n                $children = $this->data[$item->position];\n\n                if ($cursor->stop) {\n                    if ($cut >= 0) {\n                        $cut += \\count($children);\n                    }\n                    $children = [];\n                }\n            } else {\n                $children = [];\n            }\n            switch ($item->type) {\n                case Stub::TYPE_STRING:\n                    $dumper->dumpString($cursor, $item->value, Stub::STRING_BINARY === $item->class, $cut);\n                    break;\n\n                case Stub::TYPE_ARRAY:\n                    $item = clone $item;\n                    $item->type = $item->class;\n                    $item->class = $item->value;\n                    // no break\n                case Stub::TYPE_OBJECT:\n                case Stub::TYPE_RESOURCE:\n                    $withChildren = $children && $cursor->depth !== $this->maxDepth && $this->maxItemsPerDepth;\n                    $dumper->enterHash($cursor, $item->type, $item->class, $withChildren);\n                    if ($withChildren) {\n                        if ($cursor->skipChildren) {\n                            $withChildren = false;\n                            $cut = -1;\n                        } else {\n                            $cut = $this->dumpChildren($dumper, $cursor, $refs, $children, $cut, $item->type, null !== $item->class);\n                        }\n                    } elseif ($children && 0 <= $cut) {\n                        $cut += \\count($children);\n                    }\n                    $cursor->skipChildren = false;\n                    $dumper->leaveHash($cursor, $item->type, $item->class, $withChildren, $cut);\n                    break;\n\n                case Stub::TYPE_SCALAR:\n                    $dumper->dumpScalar($cursor, 'default', $item->attr['value']);\n                    break;\n\n                default:\n                    throw new \\RuntimeException(sprintf('Unexpected Stub type: \"%s\".', $item->type));\n            }\n        } elseif ('array' === $type) {\n            $dumper->enterHash($cursor, Cursor::HASH_INDEXED, 0, false);\n            $dumper->leaveHash($cursor, Cursor::HASH_INDEXED, 0, false, 0);\n        } elseif ('string' === $type) {\n            $dumper->dumpString($cursor, $item, false, 0);\n        } else {\n            $dumper->dumpScalar($cursor, $type, $item);\n        }\n    }\n\n    /**\n     * Dumps children of hash structures.\n     *\n     * @return int The final number of removed items\n     */\n    private function dumpChildren(DumperInterface $dumper, Cursor $parentCursor, array &$refs, array $children, int $hashCut, int $hashType, bool $dumpKeys): int\n    {\n        $cursor = clone $parentCursor;\n        ++$cursor->depth;\n        $cursor->hashType = $hashType;\n        $cursor->hashIndex = 0;\n        $cursor->hashLength = \\count($children);\n        $cursor->hashCut = $hashCut;\n        foreach ($children as $key => $child) {\n            $cursor->hashKeyIsBinary = isset($key[0]) && !preg_match('//u', $key);\n            $cursor->hashKey = $dumpKeys ? $key : null;\n            $this->dumpItem($dumper, $cursor, $refs, $child);\n            if (++$cursor->hashIndex === $this->maxItemsPerDepth || $cursor->stop) {\n                $parentCursor->stop = true;\n\n                return $hashCut >= 0 ? $hashCut + $cursor->hashLength - $cursor->hashIndex : $hashCut;\n            }\n        }\n\n        return $hashCut;\n    }\n\n    private function getStub(mixed $item): mixed\n    {\n        if (!$item || !\\is_array($item)) {\n            return $item;\n        }\n\n        $stub = new Stub();\n        $stub->type = Stub::TYPE_ARRAY;\n        foreach ($item as $stub->class => $stub->position) {\n        }\n        if (isset($item[0])) {\n            $stub->cut = $item[0];\n        }\n        $stub->value = $stub->cut + ($stub->position ? \\count($this->data[$stub->position]) : 0);\n\n        return $stub;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Cloner/DumperInterface.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Cloner;\n\n/**\n * DumperInterface used by Data objects.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\ninterface DumperInterface\n{\n    /**\n     * Dumps a scalar value.\n     *\n     * @return void\n     */\n    public function dumpScalar(Cursor $cursor, string $type, string|int|float|bool|null $value);\n\n    /**\n     * Dumps a string.\n     *\n     * @param string $str The string being dumped\n     * @param bool   $bin Whether $str is UTF-8 or binary encoded\n     * @param int    $cut The number of characters $str has been cut by\n     *\n     * @return void\n     */\n    public function dumpString(Cursor $cursor, string $str, bool $bin, int $cut);\n\n    /**\n     * Dumps while entering an hash.\n     *\n     * @param int             $type     A Cursor::HASH_* const for the type of hash\n     * @param string|int|null $class    The object class, resource type or array count\n     * @param bool            $hasChild When the dump of the hash has child item\n     *\n     * @return void\n     */\n    public function enterHash(Cursor $cursor, int $type, string|int|null $class, bool $hasChild);\n\n    /**\n     * Dumps while leaving an hash.\n     *\n     * @param int             $type     A Cursor::HASH_* const for the type of hash\n     * @param string|int|null $class    The object class, resource type or array count\n     * @param bool            $hasChild When the dump of the hash has child item\n     * @param int             $cut      The number of items the hash has been cut by\n     *\n     * @return void\n     */\n    public function leaveHash(Cursor $cursor, int $type, string|int|null $class, bool $hasChild, int $cut);\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Cloner/Stub.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Cloner;\n\n/**\n * Represents the main properties of a PHP variable.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass Stub\n{\n    public const TYPE_REF = 1;\n    public const TYPE_STRING = 2;\n    public const TYPE_ARRAY = 3;\n    public const TYPE_OBJECT = 4;\n    public const TYPE_RESOURCE = 5;\n    public const TYPE_SCALAR = 6;\n\n    public const STRING_BINARY = 1;\n    public const STRING_UTF8 = 2;\n\n    public const ARRAY_ASSOC = 1;\n    public const ARRAY_INDEXED = 2;\n\n    public $type = self::TYPE_REF;\n    public $class = '';\n    public $value;\n    public $cut = 0;\n    public $handle = 0;\n    public $refCount = 0;\n    public $position = 0;\n    public $attr = [];\n\n    private static array $defaultProperties = [];\n\n    /**\n     * @internal\n     */\n    public function __sleep(): array\n    {\n        $properties = [];\n\n        if (!isset(self::$defaultProperties[$c = static::class])) {\n            self::$defaultProperties[$c] = get_class_vars($c);\n\n            foreach ((new \\ReflectionClass($c))->getStaticProperties() as $k => $v) {\n                unset(self::$defaultProperties[$c][$k]);\n            }\n        }\n\n        foreach (self::$defaultProperties[$c] as $k => $v) {\n            if ($this->$k !== $v) {\n                $properties[] = $k;\n            }\n        }\n\n        return $properties;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Cloner/VarCloner.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Cloner;\n\n/**\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass VarCloner extends AbstractCloner\n{\n    private static array $arrayCache = [];\n\n    protected function doClone(mixed $var): array\n    {\n        $len = 1;                       // Length of $queue\n        $pos = 0;                       // Number of cloned items past the minimum depth\n        $refsCounter = 0;               // Hard references counter\n        $queue = [[$var]];              // This breadth-first queue is the return value\n        $hardRefs = [];                 // Map of original zval ids to stub objects\n        $objRefs = [];                  // Map of original object handles to their stub object counterpart\n        $objects = [];                  // Keep a ref to objects to ensure their handle cannot be reused while cloning\n        $resRefs = [];                  // Map of original resource handles to their stub object counterpart\n        $values = [];                   // Map of stub objects' ids to original values\n        $maxItems = $this->maxItems;\n        $maxString = $this->maxString;\n        $minDepth = $this->minDepth;\n        $currentDepth = 0;              // Current tree depth\n        $currentDepthFinalIndex = 0;    // Final $queue index for current tree depth\n        $minimumDepthReached = 0 === $minDepth; // Becomes true when minimum tree depth has been reached\n        $cookie = (object) [];          // Unique object used to detect hard references\n        $a = null;                      // Array cast for nested structures\n        $stub = null;                   // Stub capturing the main properties of an original item value\n                                        // or null if the original value is used directly\n\n        $arrayStub = new Stub();\n        $arrayStub->type = Stub::TYPE_ARRAY;\n        $fromObjCast = false;\n\n        for ($i = 0; $i < $len; ++$i) {\n            // Detect when we move on to the next tree depth\n            if ($i > $currentDepthFinalIndex) {\n                ++$currentDepth;\n                $currentDepthFinalIndex = $len - 1;\n                if ($currentDepth >= $minDepth) {\n                    $minimumDepthReached = true;\n                }\n            }\n\n            $refs = $vals = $queue[$i];\n            foreach ($vals as $k => $v) {\n                // $v is the original value or a stub object in case of hard references\n\n                $zvalRef = ($r = \\ReflectionReference::fromArrayElement($vals, $k)) ? $r->getId() : null;\n\n                if ($zvalRef) {\n                    $vals[$k] = &$stub;         // Break hard references to make $queue completely\n                    unset($stub);               // independent from the original structure\n                    if (null !== $vals[$k] = $hardRefs[$zvalRef] ?? null) {\n                        $v = $vals[$k];\n                        if ($v->value instanceof Stub && (Stub::TYPE_OBJECT === $v->value->type || Stub::TYPE_RESOURCE === $v->value->type)) {\n                            ++$v->value->refCount;\n                        }\n                        ++$v->refCount;\n                        continue;\n                    }\n                    $vals[$k] = new Stub();\n                    $vals[$k]->value = $v;\n                    $vals[$k]->handle = ++$refsCounter;\n                    $hardRefs[$zvalRef] = $vals[$k];\n                }\n                // Create $stub when the original value $v cannot be used directly\n                // If $v is a nested structure, put that structure in array $a\n                switch (true) {\n                    case null === $v:\n                    case \\is_bool($v):\n                    case \\is_int($v):\n                    case \\is_float($v):\n                        continue 2;\n                    case \\is_string($v):\n                        if ('' === $v) {\n                            continue 2;\n                        }\n                        if (!preg_match('//u', $v)) {\n                            $stub = new Stub();\n                            $stub->type = Stub::TYPE_STRING;\n                            $stub->class = Stub::STRING_BINARY;\n                            if (0 <= $maxString && 0 < $cut = \\strlen($v) - $maxString) {\n                                $stub->cut = $cut;\n                                $stub->value = substr($v, 0, -$cut);\n                            } else {\n                                $stub->value = $v;\n                            }\n                        } elseif (0 <= $maxString && isset($v[1 + ($maxString >> 2)]) && 0 < $cut = mb_strlen($v, 'UTF-8') - $maxString) {\n                            $stub = new Stub();\n                            $stub->type = Stub::TYPE_STRING;\n                            $stub->class = Stub::STRING_UTF8;\n                            $stub->cut = $cut;\n                            $stub->value = mb_substr($v, 0, $maxString, 'UTF-8');\n                        } else {\n                            continue 2;\n                        }\n                        $a = null;\n                        break;\n\n                    case \\is_array($v):\n                        if (!$v) {\n                            continue 2;\n                        }\n                        $stub = $arrayStub;\n\n                        $stub->class = array_is_list($v) ? Stub::ARRAY_INDEXED : Stub::ARRAY_ASSOC;\n                        $a = $v;\n                        break;\n\n                    case \\is_object($v):\n                        if (empty($objRefs[$h = spl_object_id($v)])) {\n                            $stub = new Stub();\n                            $stub->type = Stub::TYPE_OBJECT;\n                            $stub->class = $v::class;\n                            $stub->value = $v;\n                            $stub->handle = $h;\n                            $a = $this->castObject($stub, 0 < $i);\n                            if ($v !== $stub->value) {\n                                if (Stub::TYPE_OBJECT !== $stub->type || null === $stub->value) {\n                                    break;\n                                }\n                                $stub->handle = $h = spl_object_id($stub->value);\n                            }\n                            $stub->value = null;\n                            if (0 <= $maxItems && $maxItems <= $pos && $minimumDepthReached) {\n                                $stub->cut = \\count($a);\n                                $a = null;\n                            }\n                        }\n                        if (empty($objRefs[$h])) {\n                            $objRefs[$h] = $stub;\n                            $objects[] = $v;\n                        } else {\n                            $stub = $objRefs[$h];\n                            ++$stub->refCount;\n                            $a = null;\n                        }\n                        break;\n\n                    default: // resource\n                        if (empty($resRefs[$h = (int) $v])) {\n                            $stub = new Stub();\n                            $stub->type = Stub::TYPE_RESOURCE;\n                            if ('Unknown' === $stub->class = @get_resource_type($v)) {\n                                $stub->class = 'Closed';\n                            }\n                            $stub->value = $v;\n                            $stub->handle = $h;\n                            $a = $this->castResource($stub, 0 < $i);\n                            $stub->value = null;\n                            if (0 <= $maxItems && $maxItems <= $pos && $minimumDepthReached) {\n                                $stub->cut = \\count($a);\n                                $a = null;\n                            }\n                        }\n                        if (empty($resRefs[$h])) {\n                            $resRefs[$h] = $stub;\n                        } else {\n                            $stub = $resRefs[$h];\n                            ++$stub->refCount;\n                            $a = null;\n                        }\n                        break;\n                }\n\n                if ($a) {\n                    if (!$minimumDepthReached || 0 > $maxItems) {\n                        $queue[$len] = $a;\n                        $stub->position = $len++;\n                    } elseif ($pos < $maxItems) {\n                        if ($maxItems < $pos += \\count($a)) {\n                            $a = \\array_slice($a, 0, $maxItems - $pos, true);\n                            if ($stub->cut >= 0) {\n                                $stub->cut += $pos - $maxItems;\n                            }\n                        }\n                        $queue[$len] = $a;\n                        $stub->position = $len++;\n                    } elseif ($stub->cut >= 0) {\n                        $stub->cut += \\count($a);\n                        $stub->position = 0;\n                    }\n                }\n\n                if ($arrayStub === $stub) {\n                    if ($arrayStub->cut) {\n                        $stub = [$arrayStub->cut, $arrayStub->class => $arrayStub->position];\n                        $arrayStub->cut = 0;\n                    } elseif (isset(self::$arrayCache[$arrayStub->class][$arrayStub->position])) {\n                        $stub = self::$arrayCache[$arrayStub->class][$arrayStub->position];\n                    } else {\n                        self::$arrayCache[$arrayStub->class][$arrayStub->position] = $stub = [$arrayStub->class => $arrayStub->position];\n                    }\n                }\n\n                if (!$zvalRef) {\n                    $vals[$k] = $stub;\n                } else {\n                    $hardRefs[$zvalRef]->value = $stub;\n                }\n            }\n\n            if ($fromObjCast) {\n                $fromObjCast = false;\n                $refs = $vals;\n                $vals = [];\n                $j = -1;\n                foreach ($queue[$i] as $k => $v) {\n                    foreach ([$k => true] as $gk => $gv) {\n                    }\n                    if ($gk !== $k) {\n                        $vals = (object) $vals;\n                        $vals->{$k} = $refs[++$j];\n                        $vals = (array) $vals;\n                    } else {\n                        $vals[$k] = $refs[++$j];\n                    }\n                }\n            }\n\n            $queue[$i] = $vals;\n        }\n\n        foreach ($values as $h => $v) {\n            $hardRefs[$h] = $v;\n        }\n\n        return $queue;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Command/Descriptor/CliDescriptor.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Command\\Descriptor;\n\nuse Symfony\\Component\\Console\\Input\\ArrayInput;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\nuse Symfony\\Component\\Console\\Style\\SymfonyStyle;\nuse Symfony\\Component\\VarDumper\\Cloner\\Data;\nuse Symfony\\Component\\VarDumper\\Dumper\\CliDumper;\n\n/**\n * Describe collected data clones for cli output.\n *\n * @author Maxime Steinhausser <maxime.steinhausser@gmail.com>\n *\n * @final\n */\nclass CliDescriptor implements DumpDescriptorInterface\n{\n    private CliDumper $dumper;\n    private mixed $lastIdentifier = null;\n\n    public function __construct(CliDumper $dumper)\n    {\n        $this->dumper = $dumper;\n    }\n\n    public function describe(OutputInterface $output, Data $data, array $context, int $clientId): void\n    {\n        $io = $output instanceof SymfonyStyle ? $output : new SymfonyStyle(new ArrayInput([]), $output);\n        $this->dumper->setColors($output->isDecorated());\n\n        $rows = [['date', date('r', (int) $context['timestamp'])]];\n        $lastIdentifier = $this->lastIdentifier;\n        $this->lastIdentifier = $clientId;\n\n        $section = \"Received from client #$clientId\";\n        if (isset($context['request'])) {\n            $request = $context['request'];\n            $this->lastIdentifier = $request['identifier'];\n            $section = sprintf('%s %s', $request['method'], $request['uri']);\n            if ($controller = $request['controller']) {\n                $rows[] = ['controller', rtrim($this->dumper->dump($controller, true), \"\\n\")];\n            }\n        } elseif (isset($context['cli'])) {\n            $this->lastIdentifier = $context['cli']['identifier'];\n            $section = '$ '.$context['cli']['command_line'];\n        }\n\n        if ($this->lastIdentifier !== $lastIdentifier) {\n            $io->section($section);\n        }\n\n        if (isset($context['source'])) {\n            $source = $context['source'];\n            $sourceInfo = sprintf('%s on line %d', $source['name'], $source['line']);\n            if ($fileLink = $source['file_link'] ?? null) {\n                $sourceInfo = sprintf('<href=%s>%s</>', $fileLink, $sourceInfo);\n            }\n            $rows[] = ['source', $sourceInfo];\n            $file = $source['file_relative'] ?? $source['file'];\n            $rows[] = ['file', $file];\n        }\n\n        $io->table([], $rows);\n\n        $this->dumper->dump($data);\n        $io->newLine();\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Command/Descriptor/DumpDescriptorInterface.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Command\\Descriptor;\n\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\nuse Symfony\\Component\\VarDumper\\Cloner\\Data;\n\n/**\n * @author Maxime Steinhausser <maxime.steinhausser@gmail.com>\n */\ninterface DumpDescriptorInterface\n{\n    public function describe(OutputInterface $output, Data $data, array $context, int $clientId): void;\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Command/Descriptor/HtmlDescriptor.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Command\\Descriptor;\n\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\nuse Symfony\\Component\\VarDumper\\Cloner\\Data;\nuse Symfony\\Component\\VarDumper\\Dumper\\HtmlDumper;\n\n/**\n * Describe collected data clones for html output.\n *\n * @author Maxime Steinhausser <maxime.steinhausser@gmail.com>\n *\n * @final\n */\nclass HtmlDescriptor implements DumpDescriptorInterface\n{\n    private HtmlDumper $dumper;\n    private bool $initialized = false;\n\n    public function __construct(HtmlDumper $dumper)\n    {\n        $this->dumper = $dumper;\n    }\n\n    public function describe(OutputInterface $output, Data $data, array $context, int $clientId): void\n    {\n        if (!$this->initialized) {\n            $styles = file_get_contents(__DIR__.'/../../Resources/css/htmlDescriptor.css');\n            $scripts = file_get_contents(__DIR__.'/../../Resources/js/htmlDescriptor.js');\n            $output->writeln(\"<style>$styles</style><script>$scripts</script>\");\n            $this->initialized = true;\n        }\n\n        $title = '-';\n        if (isset($context['request'])) {\n            $request = $context['request'];\n            $controller = \"<span class='dumped-tag'>{$this->dumper->dump($request['controller'], true, ['maxDepth' => 0])}</span>\";\n            $title = sprintf('<code>%s</code> <a href=\"%s\">%s</a>', $request['method'], $uri = $request['uri'], $uri);\n            $dedupIdentifier = $request['identifier'];\n        } elseif (isset($context['cli'])) {\n            $title = '<code>$ </code>'.$context['cli']['command_line'];\n            $dedupIdentifier = $context['cli']['identifier'];\n        } else {\n            $dedupIdentifier = uniqid('', true);\n        }\n\n        $sourceDescription = '';\n        if (isset($context['source'])) {\n            $source = $context['source'];\n            $projectDir = $source['project_dir'] ?? null;\n            $sourceDescription = sprintf('%s on line %d', $source['name'], $source['line']);\n            if (isset($source['file_link'])) {\n                $sourceDescription = sprintf('<a href=\"%s\">%s</a>', $source['file_link'], $sourceDescription);\n            }\n        }\n\n        $isoDate = $this->extractDate($context, 'c');\n        $tags = array_filter([\n            'controller' => $controller ?? null,\n            'project dir' => $projectDir ?? null,\n        ]);\n\n        $output->writeln(<<<HTML\n<article data-dedup-id=\"$dedupIdentifier\">\n    <header>\n        <div class=\"row\">\n            <h2 class=\"col\">$title</h2>\n            <time class=\"col text-small\" title=\"$isoDate\" datetime=\"$isoDate\">\n                {$this->extractDate($context)}\n            </time>\n        </div>\n        {$this->renderTags($tags)}\n    </header>\n    <section class=\"body\">\n        <p class=\"text-small\">\n            $sourceDescription\n        </p>\n        {$this->dumper->dump($data, true)}\n    </section>\n</article>\nHTML\n        );\n    }\n\n    private function extractDate(array $context, string $format = 'r'): string\n    {\n        return date($format, (int) $context['timestamp']);\n    }\n\n    private function renderTags(array $tags): string\n    {\n        if (!$tags) {\n            return '';\n        }\n\n        $renderedTags = '';\n        foreach ($tags as $key => $value) {\n            $renderedTags .= sprintf('<li><span class=\"badge\">%s</span>%s</li>', $key, $value);\n        }\n\n        return <<<HTML\n<div class=\"row\">\n    <ul class=\"tags\">\n        $renderedTags\n    </ul>\n</div>\nHTML;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Command/ServerDumpCommand.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Command;\n\nuse Symfony\\Component\\Console\\Attribute\\AsCommand;\nuse Symfony\\Component\\Console\\Command\\Command;\nuse Symfony\\Component\\Console\\Completion\\CompletionInput;\nuse Symfony\\Component\\Console\\Completion\\CompletionSuggestions;\nuse Symfony\\Component\\Console\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Input\\InputOption;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\nuse Symfony\\Component\\Console\\Style\\SymfonyStyle;\nuse Symfony\\Component\\VarDumper\\Cloner\\Data;\nuse Symfony\\Component\\VarDumper\\Command\\Descriptor\\CliDescriptor;\nuse Symfony\\Component\\VarDumper\\Command\\Descriptor\\DumpDescriptorInterface;\nuse Symfony\\Component\\VarDumper\\Command\\Descriptor\\HtmlDescriptor;\nuse Symfony\\Component\\VarDumper\\Dumper\\CliDumper;\nuse Symfony\\Component\\VarDumper\\Dumper\\HtmlDumper;\nuse Symfony\\Component\\VarDumper\\Server\\DumpServer;\n\n/**\n * Starts a dump server to collect and output dumps on a single place with multiple formats support.\n *\n * @author Maxime Steinhausser <maxime.steinhausser@gmail.com>\n *\n * @final\n */\n#[AsCommand(name: 'server:dump', description: 'Start a dump server that collects and displays dumps in a single place')]\nclass ServerDumpCommand extends Command\n{\n    private DumpServer $server;\n\n    /** @var DumpDescriptorInterface[] */\n    private array $descriptors;\n\n    public function __construct(DumpServer $server, array $descriptors = [])\n    {\n        $this->server = $server;\n        $this->descriptors = $descriptors + [\n            'cli' => new CliDescriptor(new CliDumper()),\n            'html' => new HtmlDescriptor(new HtmlDumper()),\n        ];\n\n        parent::__construct();\n    }\n\n    protected function configure(): void\n    {\n        $this\n            ->addOption('format', null, InputOption::VALUE_REQUIRED, sprintf('The output format (%s)', implode(', ', $this->getAvailableFormats())), 'cli')\n            ->setHelp(<<<'EOF'\n<info>%command.name%</info> starts a dump server that collects and displays\ndumps in a single place for debugging you application:\n\n  <info>php %command.full_name%</info>\n\nYou can consult dumped data in HTML format in your browser by providing the <comment>--format=html</comment> option\nand redirecting the output to a file:\n\n  <info>php %command.full_name% --format=\"html\" > dump.html</info>\n\nEOF\n            )\n        ;\n    }\n\n    protected function execute(InputInterface $input, OutputInterface $output): int\n    {\n        $io = new SymfonyStyle($input, $output);\n        $format = $input->getOption('format');\n\n        if (!$descriptor = $this->descriptors[$format] ?? null) {\n            throw new InvalidArgumentException(sprintf('Unsupported format \"%s\".', $format));\n        }\n\n        $errorIo = $io->getErrorStyle();\n        $errorIo->title('Symfony Var Dumper Server');\n\n        $this->server->start();\n\n        $errorIo->success(sprintf('Server listening on %s', $this->server->getHost()));\n        $errorIo->comment('Quit the server with CONTROL-C.');\n\n        $this->server->listen(function (Data $data, array $context, int $clientId) use ($descriptor, $io) {\n            $descriptor->describe($io, $data, $context, $clientId);\n        });\n\n        return 0;\n    }\n\n    public function complete(CompletionInput $input, CompletionSuggestions $suggestions): void\n    {\n        if ($input->mustSuggestOptionValuesFor('format')) {\n            $suggestions->suggestValues($this->getAvailableFormats());\n        }\n    }\n\n    private function getAvailableFormats(): array\n    {\n        return array_keys($this->descriptors);\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/composer.json',
    '{\n    "name": "symfony/var-dumper",\n    "type": "library",\n    "description": "Provides mechanisms for walking through any arbitrary PHP variable",\n    "keywords": ["dump", "debug"],\n    "homepage": "https://symfony.com",\n    "license": "MIT",\n    "authors": [\n        {\n            "name": "Nicolas Grekas",\n            "email": "p@tchwork.com"\n        },\n        {\n            "name": "Symfony Community",\n            "homepage": "https://symfony.com/contributors"\n        }\n    ],\n    "require": {\n        "php": ">=8.1",\n        "symfony/polyfill-mbstring": "~1.0"\n    },\n    "require-dev": {\n        "ext-iconv": "*",\n        "symfony/console": "^5.4|^6.0",\n        "symfony/process": "^5.4|^6.0",\n        "symfony/uid": "^5.4|^6.0",\n        "twig/twig": "^2.13|^3.0.4"\n    },\n    "conflict": {\n        "symfony/console": "<5.4"\n    },\n    "autoload": {\n        "files": [ "Resources/functions/dump.php" ],\n        "psr-4": { "Symfony\\\\Component\\\\VarDumper\\\\": "" },\n        "exclude-from-classmap": [\n            "/Tests/"\n        ]\n    },\n    "bin": [\n        "Resources/bin/var-dump-server"\n    ],\n    "minimum-stability": "dev"\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Dumper/AbstractDumper.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Dumper;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Data;\nuse Symfony\\Component\\VarDumper\\Cloner\\DumperInterface;\n\n/**\n * Abstract mechanism for dumping a Data object.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nabstract class AbstractDumper implements DataDumperInterface, DumperInterface\n{\n    public const DUMP_LIGHT_ARRAY = 1;\n    public const DUMP_STRING_LENGTH = 2;\n    public const DUMP_COMMA_SEPARATOR = 4;\n    public const DUMP_TRAILING_COMMA = 8;\n\n    public static $defaultOutput = 'php://output';\n\n    protected $line = '';\n    protected $lineDumper;\n    protected $outputStream;\n    protected $decimalPoint = '.';\n    protected $indentPad = '  ';\n    protected $flags;\n\n    private string $charset = '';\n\n    /**\n     * @param callable|resource|string|null $output  A line dumper callable, an opened stream or an output path, defaults to static::$defaultOutput\n     * @param string|null                   $charset The default character encoding to use for non-UTF8 strings\n     * @param int                           $flags   A bit field of static::DUMP_* constants to fine tune dumps representation\n     */\n    public function __construct($output = null, string $charset = null, int $flags = 0)\n    {\n        $this->flags = $flags;\n        $this->setCharset($charset ?: \\ini_get('php.output_encoding') ?: \\ini_get('default_charset') ?: 'UTF-8');\n        $this->setOutput($output ?: static::$defaultOutput);\n        if (!$output && \\is_string(static::$defaultOutput)) {\n            static::$defaultOutput = $this->outputStream;\n        }\n    }\n\n    /**\n     * Sets the output destination of the dumps.\n     *\n     * @param callable|resource|string $output A line dumper callable, an opened stream or an output path\n     *\n     * @return callable|resource|string The previous output destination\n     */\n    public function setOutput($output)\n    {\n        $prev = $this->outputStream ?? $this->lineDumper;\n\n        if (\\is_callable($output)) {\n            $this->outputStream = null;\n            $this->lineDumper = $output;\n        } else {\n            if (\\is_string($output)) {\n                $output = fopen($output, 'w');\n            }\n            $this->outputStream = $output;\n            $this->lineDumper = $this->echoLine(...);\n        }\n\n        return $prev;\n    }\n\n    /**\n     * Sets the default character encoding to use for non-UTF8 strings.\n     *\n     * @return string The previous charset\n     */\n    public function setCharset(string $charset): string\n    {\n        $prev = $this->charset;\n\n        $charset = strtoupper($charset);\n        $charset = null === $charset || 'UTF-8' === $charset || 'UTF8' === $charset ? 'CP1252' : $charset;\n\n        $this->charset = $charset;\n\n        return $prev;\n    }\n\n    /**\n     * Sets the indentation pad string.\n     *\n     * @param string $pad A string that will be prepended to dumped lines, repeated by nesting level\n     *\n     * @return string The previous indent pad\n     */\n    public function setIndentPad(string $pad): string\n    {\n        $prev = $this->indentPad;\n        $this->indentPad = $pad;\n\n        return $prev;\n    }\n\n    /**\n     * Dumps a Data object.\n     *\n     * @param callable|resource|string|true|null $output A line dumper callable, an opened stream, an output path or true to return the dump\n     *\n     * @return string|null The dump as string when $output is true\n     */\n    public function dump(Data $data, $output = null): ?string\n    {\n        if ($locale = $this->flags & (self::DUMP_COMMA_SEPARATOR | self::DUMP_TRAILING_COMMA) ? setlocale(\\LC_NUMERIC, 0) : null) {\n            setlocale(\\LC_NUMERIC, 'C');\n        }\n\n        if ($returnDump = true === $output) {\n            $output = fopen('php://memory', 'r+');\n        }\n        if ($output) {\n            $prevOutput = $this->setOutput($output);\n        }\n        try {\n            $data->dump($this);\n            $this->dumpLine(-1);\n\n            if ($returnDump) {\n                $result = stream_get_contents($output, -1, 0);\n                fclose($output);\n\n                return $result;\n            }\n        } finally {\n            if ($output) {\n                $this->setOutput($prevOutput);\n            }\n            if ($locale) {\n                setlocale(\\LC_NUMERIC, $locale);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Dumps the current line.\n     *\n     * @param int $depth The recursive depth in the dumped structure for the line being dumped,\n     *                   or -1 to signal the end-of-dump to the line dumper callable\n     *\n     * @return void\n     */\n    protected function dumpLine(int $depth)\n    {\n        ($this->lineDumper)($this->line, $depth, $this->indentPad);\n        $this->line = '';\n    }\n\n    /**\n     * Generic line dumper callback.\n     *\n     * @return void\n     */\n    protected function echoLine(string $line, int $depth, string $indentPad)\n    {\n        if (-1 !== $depth) {\n            fwrite($this->outputStream, str_repeat($indentPad, $depth).$line.\"\\n\");\n        }\n    }\n\n    /**\n     * Converts a non-UTF-8 string to UTF-8.\n     */\n    protected function utf8Encode(?string $s): ?string\n    {\n        if (null === $s || preg_match('//u', $s)) {\n            return $s;\n        }\n\n        if (!\\function_exists('iconv')) {\n            throw new \\RuntimeException('Unable to convert a non-UTF-8 string to UTF-8: required function iconv() does not exist. You should install ext-iconv or symfony/polyfill-iconv.');\n        }\n\n        if (false !== $c = @iconv($this->charset, 'UTF-8', $s)) {\n            return $c;\n        }\n        if ('CP1252' !== $this->charset && false !== $c = @iconv('CP1252', 'UTF-8', $s)) {\n            return $c;\n        }\n\n        return iconv('CP850', 'UTF-8', $s);\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Dumper/CliDumper.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Dumper;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Cursor;\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * CliDumper dumps variables for command line output.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass CliDumper extends AbstractDumper\n{\n    public static $defaultColors;\n    public static $defaultOutput = 'php://stdout';\n\n    protected $colors;\n    protected $maxStringWidth = 0;\n    protected $styles = [\n        // See http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n        'default' => '0;38;5;208',\n        'num' => '1;38;5;38',\n        'const' => '1;38;5;208',\n        'str' => '1;38;5;113',\n        'note' => '38;5;38',\n        'ref' => '38;5;247',\n        'public' => '',\n        'protected' => '',\n        'private' => '',\n        'meta' => '38;5;170',\n        'key' => '38;5;113',\n        'index' => '38;5;38',\n    ];\n\n    protected static $controlCharsRx = '/[\\x00-\\x1F\\x7F]+/';\n    protected static $controlCharsMap = [\n        \"\\t\" => '\\t',\n        \"\\n\" => '\\n',\n        \"\\v\" => '\\v',\n        \"\\f\" => '\\f',\n        \"\\r\" => '\\r',\n        \"\\033\" => '\\e',\n    ];\n    protected static $unicodeCharsRx = \"/[\\u{00A0}\\u{00AD}\\u{034F}\\u{061C}\\u{115F}\\u{1160}\\u{17B4}\\u{17B5}\\u{180E}\\u{2000}-\\u{200F}\\u{202F}\\u{205F}\\u{2060}-\\u{2064}\\u{206A}-\\u{206F}\\u{3000}\\u{2800}\\u{3164}\\u{FEFF}\\u{FFA0}\\u{1D159}\\u{1D173}-\\u{1D17A}]/u\";\n\n    protected $collapseNextHash = false;\n    protected $expandNextHash = false;\n\n    private array $displayOptions = [\n        'fileLinkFormat' => null,\n    ];\n\n    private bool $handlesHrefGracefully;\n\n    public function __construct($output = null, string $charset = null, int $flags = 0)\n    {\n        parent::__construct($output, $charset, $flags);\n\n        if ('\\\\' === \\DIRECTORY_SEPARATOR && !$this->isWindowsTrueColor()) {\n            // Use only the base 16 xterm colors when using ANSICON or standard Windows 10 CLI\n            $this->setStyles([\n                'default' => '31',\n                'num' => '1;34',\n                'const' => '1;31',\n                'str' => '1;32',\n                'note' => '34',\n                'ref' => '1;30',\n                'meta' => '35',\n                'key' => '32',\n                'index' => '34',\n            ]);\n        }\n\n        $this->displayOptions['fileLinkFormat'] = \\ini_get('xdebug.file_link_format') ?: get_cfg_var('xdebug.file_link_format') ?: 'file://%f#L%l';\n    }\n\n    /**\n     * Enables/disables colored output.\n     *\n     * @return void\n     */\n    public function setColors(bool $colors)\n    {\n        $this->colors = $colors;\n    }\n\n    /**\n     * Sets the maximum number of characters per line for dumped strings.\n     *\n     * @return void\n     */\n    public function setMaxStringWidth(int $maxStringWidth)\n    {\n        $this->maxStringWidth = $maxStringWidth;\n    }\n\n    /**\n     * Configures styles.\n     *\n     * @param array $styles A map of style names to style definitions\n     *\n     * @return void\n     */\n    public function setStyles(array $styles)\n    {\n        $this->styles = $styles + $this->styles;\n    }\n\n    /**\n     * Configures display options.\n     *\n     * @param array $displayOptions A map of display options to customize the behavior\n     *\n     * @return void\n     */\n    public function setDisplayOptions(array $displayOptions)\n    {\n        $this->displayOptions = $displayOptions + $this->displayOptions;\n    }\n\n    /**\n     * @return void\n     */\n    public function dumpScalar(Cursor $cursor, string $type, string|int|float|bool|null $value)\n    {\n        $this->dumpKey($cursor);\n\n        $style = 'const';\n        $attr = $cursor->attr;\n\n        switch ($type) {\n            case 'default':\n                $style = 'default';\n                break;\n\n            case 'label':\n                $this->styles += ['label' => $this->styles['default']];\n                $style = 'label';\n                break;\n\n            case 'integer':\n                $style = 'num';\n\n                if (isset($this->styles['integer'])) {\n                    $style = 'integer';\n                }\n\n                break;\n\n            case 'double':\n                $style = 'num';\n\n                if (isset($this->styles['float'])) {\n                    $style = 'float';\n                }\n\n                $value = match (true) {\n                    \\INF === $value => 'INF',\n                    -\\INF === $value => '-INF',\n                    is_nan($value) => 'NAN',\n                    default => !str_contains($value = (string) $value, $this->decimalPoint) ? $value .= $this->decimalPoint.'0' : $value,\n                };\n                break;\n\n            case 'NULL':\n                $value = 'null';\n                break;\n\n            case 'boolean':\n                $value = $value ? 'true' : 'false';\n                break;\n\n            default:\n                $attr += ['value' => $this->utf8Encode($value)];\n                $value = $this->utf8Encode($type);\n                break;\n        }\n\n        $this->line .= $this->style($style, $value, $attr);\n\n        $this->endValue($cursor);\n    }\n\n    /**\n     * @return void\n     */\n    public function dumpString(Cursor $cursor, string $str, bool $bin, int $cut)\n    {\n        $this->dumpKey($cursor);\n        $attr = $cursor->attr;\n\n        if ($bin) {\n            $str = $this->utf8Encode($str);\n        }\n        if ('' === $str) {\n            $this->line .= '\"\"';\n            if ($cut) {\n                $this->line .= '…'.$cut;\n            }\n            $this->endValue($cursor);\n        } else {\n            $attr += [\n                'length' => 0 <= $cut ? mb_strlen($str, 'UTF-8') + $cut : 0,\n                'binary' => $bin,\n            ];\n            $str = $bin && str_contains($str, \"\\0\") ? [$str] : explode(\"\\n\", $str);\n            if (isset($str[1]) && !isset($str[2]) && !isset($str[1][0])) {\n                unset($str[1]);\n                $str[0] .= \"\\n\";\n            }\n            $m = \\count($str) - 1;\n            $i = $lineCut = 0;\n\n            if (self::DUMP_STRING_LENGTH & $this->flags) {\n                $this->line .= '('.$attr['length'].') ';\n            }\n            if ($bin) {\n                $this->line .= 'b';\n            }\n\n            if ($m) {\n                $this->line .= '\"\"\"';\n                $this->dumpLine($cursor->depth);\n            } else {\n                $this->line .= '\"';\n            }\n\n            foreach ($str as $str) {\n                if ($i < $m) {\n                    $str .= \"\\n\";\n                }\n                if (0 < $this->maxStringWidth && $this->maxStringWidth < $len = mb_strlen($str, 'UTF-8')) {\n                    $str = mb_substr($str, 0, $this->maxStringWidth, 'UTF-8');\n                    $lineCut = $len - $this->maxStringWidth;\n                }\n                if ($m && 0 < $cursor->depth) {\n                    $this->line .= $this->indentPad;\n                }\n                if ('' !== $str) {\n                    $this->line .= $this->style('str', $str, $attr);\n                }\n                if ($i++ == $m) {\n                    if ($m) {\n                        if ('' !== $str) {\n                            $this->dumpLine($cursor->depth);\n                            if (0 < $cursor->depth) {\n                                $this->line .= $this->indentPad;\n                            }\n                        }\n                        $this->line .= '\"\"\"';\n                    } else {\n                        $this->line .= '\"';\n                    }\n                    if ($cut < 0) {\n                        $this->line .= '…';\n                        $lineCut = 0;\n                    } elseif ($cut) {\n                        $lineCut += $cut;\n                    }\n                }\n                if ($lineCut) {\n                    $this->line .= '…'.$lineCut;\n                    $lineCut = 0;\n                }\n\n                if ($i > $m) {\n                    $this->endValue($cursor);\n                } else {\n                    $this->dumpLine($cursor->depth);\n                }\n            }\n        }\n    }\n\n    /**\n     * @return void\n     */\n    public function enterHash(Cursor $cursor, int $type, string|int|null $class, bool $hasChild)\n    {\n        $this->colors ??= $this->supportsColors();\n\n        $this->dumpKey($cursor);\n        $attr = $cursor->attr;\n\n        if ($this->collapseNextHash) {\n            $cursor->skipChildren = true;\n            $this->collapseNextHash = $hasChild = false;\n        }\n\n        $class = $this->utf8Encode($class);\n        if (Cursor::HASH_OBJECT === $type) {\n            $prefix = $class && 'stdClass' !== $class ? $this->style('note', $class, $attr).(empty($attr['cut_hash']) ? ' {' : '') : '{';\n        } elseif (Cursor::HASH_RESOURCE === $type) {\n            $prefix = $this->style('note', $class.' resource', $attr).($hasChild ? ' {' : ' ');\n        } else {\n            $prefix = $class && !(self::DUMP_LIGHT_ARRAY & $this->flags) ? $this->style('note', 'array:'.$class).' [' : '[';\n        }\n\n        if (($cursor->softRefCount || 0 < $cursor->softRefHandle) && empty($attr['cut_hash'])) {\n            $prefix .= $this->style('ref', (Cursor::HASH_RESOURCE === $type ? '@' : '#').(0 < $cursor->softRefHandle ? $cursor->softRefHandle : $cursor->softRefTo), ['count' => $cursor->softRefCount]);\n        } elseif ($cursor->hardRefTo && !$cursor->refIndex && $class) {\n            $prefix .= $this->style('ref', '&'.$cursor->hardRefTo, ['count' => $cursor->hardRefCount]);\n        } elseif (!$hasChild && Cursor::HASH_RESOURCE === $type) {\n            $prefix = substr($prefix, 0, -1);\n        }\n\n        $this->line .= $prefix;\n\n        if ($hasChild) {\n            $this->dumpLine($cursor->depth);\n        }\n    }\n\n    /**\n     * @return void\n     */\n    public function leaveHash(Cursor $cursor, int $type, string|int|null $class, bool $hasChild, int $cut)\n    {\n        if (empty($cursor->attr['cut_hash'])) {\n            $this->dumpEllipsis($cursor, $hasChild, $cut);\n            $this->line .= Cursor::HASH_OBJECT === $type ? '}' : (Cursor::HASH_RESOURCE !== $type ? ']' : ($hasChild ? '}' : ''));\n        }\n\n        $this->endValue($cursor);\n    }\n\n    /**\n     * Dumps an ellipsis for cut children.\n     *\n     * @param bool $hasChild When the dump of the hash has child item\n     * @param int  $cut      The number of items the hash has been cut by\n     *\n     * @return void\n     */\n    protected function dumpEllipsis(Cursor $cursor, bool $hasChild, int $cut)\n    {\n        if ($cut) {\n            $this->line .= ' …';\n            if (0 < $cut) {\n                $this->line .= $cut;\n            }\n            if ($hasChild) {\n                $this->dumpLine($cursor->depth + 1);\n            }\n        }\n    }\n\n    /**\n     * Dumps a key in a hash structure.\n     *\n     * @return void\n     */\n    protected function dumpKey(Cursor $cursor)\n    {\n        if (null !== $key = $cursor->hashKey) {\n            if ($cursor->hashKeyIsBinary) {\n                $key = $this->utf8Encode($key);\n            }\n            $attr = ['binary' => $cursor->hashKeyIsBinary];\n            $bin = $cursor->hashKeyIsBinary ? 'b' : '';\n            $style = 'key';\n            switch ($cursor->hashType) {\n                default:\n                case Cursor::HASH_INDEXED:\n                    if (self::DUMP_LIGHT_ARRAY & $this->flags) {\n                        break;\n                    }\n                    $style = 'index';\n                    // no break\n                case Cursor::HASH_ASSOC:\n                    if (\\is_int($key)) {\n                        $this->line .= $this->style($style, $key).' => ';\n                    } else {\n                        $this->line .= $bin.'\"'.$this->style($style, $key).'\" => ';\n                    }\n                    break;\n\n                case Cursor::HASH_RESOURCE:\n                    $key = \"\\0~\\0\".$key;\n                    // no break\n                case Cursor::HASH_OBJECT:\n                    if (!isset($key[0]) || \"\\0\" !== $key[0]) {\n                        $this->line .= '+'.$bin.$this->style('public', $key).': ';\n                    } elseif (0 < strpos($key, \"\\0\", 1)) {\n                        $key = explode(\"\\0\", substr($key, 1), 2);\n\n                        switch ($key[0][0]) {\n                            case '+': // User inserted keys\n                                $attr['dynamic'] = true;\n                                $this->line .= '+'.$bin.'\"'.$this->style('public', $key[1], $attr).'\": ';\n                                break 2;\n                            case '~':\n                                $style = 'meta';\n                                if (isset($key[0][1])) {\n                                    parse_str(substr($key[0], 1), $attr);\n                                    $attr += ['binary' => $cursor->hashKeyIsBinary];\n                                }\n                                break;\n                            case '*':\n                                $style = 'protected';\n                                $bin = '#'.$bin;\n                                break;\n                            default:\n                                $attr['class'] = $key[0];\n                                $style = 'private';\n                                $bin = '-'.$bin;\n                                break;\n                        }\n\n                        if (isset($attr['collapse'])) {\n                            if ($attr['collapse']) {\n                                $this->collapseNextHash = true;\n                            } else {\n                                $this->expandNextHash = true;\n                            }\n                        }\n\n                        $this->line .= $bin.$this->style($style, $key[1], $attr).($attr['separator'] ?? ': ');\n                    } else {\n                        // This case should not happen\n                        $this->line .= '-'.$bin.'\"'.$this->style('private', $key, ['class' => '']).'\": ';\n                    }\n                    break;\n            }\n\n            if ($cursor->hardRefTo) {\n                $this->line .= $this->style('ref', '&'.($cursor->hardRefCount ? $cursor->hardRefTo : ''), ['count' => $cursor->hardRefCount]).' ';\n            }\n        }\n    }\n\n    /**\n     * Decorates a value with some style.\n     *\n     * @param string $style The type of style being applied\n     * @param string $value The value being styled\n     * @param array  $attr  Optional context information\n     */\n    protected function style(string $style, string $value, array $attr = []): string\n    {\n        $this->colors ??= $this->supportsColors();\n\n        $this->handlesHrefGracefully ??= 'JetBrains-JediTerm' !== getenv('TERMINAL_EMULATOR')\n            && (!getenv('KONSOLE_VERSION') || (int) getenv('KONSOLE_VERSION') > 201100)\n            && !isset($_SERVER['IDEA_INITIAL_DIRECTORY']);\n\n        if (isset($attr['ellipsis'], $attr['ellipsis-type'])) {\n            $prefix = substr($value, 0, -$attr['ellipsis']);\n            if ('cli' === \\PHP_SAPI && 'path' === $attr['ellipsis-type'] && isset($_SERVER[$pwd = '\\\\' === \\DIRECTORY_SEPARATOR ? 'CD' : 'PWD']) && str_starts_with($prefix, $_SERVER[$pwd])) {\n                $prefix = '.'.substr($prefix, \\strlen($_SERVER[$pwd]));\n            }\n            if (!empty($attr['ellipsis-tail'])) {\n                $prefix .= substr($value, -$attr['ellipsis'], $attr['ellipsis-tail']);\n                $value = substr($value, -$attr['ellipsis'] + $attr['ellipsis-tail']);\n            } else {\n                $value = substr($value, -$attr['ellipsis']);\n            }\n\n            $value = $this->style('default', $prefix).$this->style($style, $value);\n\n            goto href;\n        }\n\n        $map = static::$controlCharsMap;\n        $startCchr = $this->colors ? \"\\033[m\\033[{$this->styles['default']}m\" : '';\n        $endCchr = $this->colors ? \"\\033[m\\033[{$this->styles[$style]}m\" : '';\n        $value = preg_replace_callback(static::$controlCharsRx, function ($c) use ($map, $startCchr, $endCchr) {\n            $s = $startCchr;\n            $c = $c[$i = 0];\n            do {\n                $s .= $map[$c[$i]] ?? sprintf('\\x%02X', \\ord($c[$i]));\n            } while (isset($c[++$i]));\n\n            return $s.$endCchr;\n        }, $value, -1, $cchrCount);\n\n        if (!($attr['binary'] ?? false)) {\n            $value = preg_replace_callback(static::$unicodeCharsRx, function ($c) use (&$cchrCount, $startCchr, $endCchr) {\n                ++$cchrCount;\n\n                return $startCchr.'\\u{'.strtoupper(dechex(mb_ord($c[0]))).'}'.$endCchr;\n            }, $value);\n        }\n\n        if ($this->colors && '' !== $value) {\n            if ($cchrCount && \"\\033\" === $value[0]) {\n                $value = substr($value, \\strlen($startCchr));\n            } else {\n                $value = \"\\033[{$this->styles[$style]}m\".$value;\n            }\n            if ($cchrCount && str_ends_with($value, $endCchr)) {\n                $value = substr($value, 0, -\\strlen($endCchr));\n            } else {\n                $value .= \"\\033[{$this->styles['default']}m\";\n            }\n        }\n\n        href:\n        if ($this->colors && $this->handlesHrefGracefully) {\n            if (isset($attr['file']) && $href = $this->getSourceLink($attr['file'], $attr['line'] ?? 0)) {\n                if ('note' === $style) {\n                    $value .= \"\\033]8;;{$href}\\033\\\\^\\033]8;;\\033\\\\\";\n                } else {\n                    $attr['href'] = $href;\n                }\n            }\n            if (isset($attr['href'])) {\n                if ('label' === $style) {\n                    $value .= '^';\n                }\n                $value = \"\\033]8;;{$attr['href']}\\033\\\\{$value}\\033]8;;\\033\\\\\";\n            }\n        }\n\n        if ('label' === $style && '' !== $value) {\n            $value .= ' ';\n        }\n\n        return $value;\n    }\n\n    protected function supportsColors(): bool\n    {\n        if ($this->outputStream !== static::$defaultOutput) {\n            return $this->hasColorSupport($this->outputStream);\n        }\n        if (null !== static::$defaultColors) {\n            return static::$defaultColors;\n        }\n        if (isset($_SERVER['argv'][1])) {\n            $colors = $_SERVER['argv'];\n            $i = \\count($colors);\n            while (--$i > 0) {\n                if (isset($colors[$i][5])) {\n                    switch ($colors[$i]) {\n                        case '--ansi':\n                        case '--color':\n                        case '--color=yes':\n                        case '--color=force':\n                        case '--color=always':\n                        case '--colors=always':\n                            return static::$defaultColors = true;\n\n                        case '--no-ansi':\n                        case '--color=no':\n                        case '--color=none':\n                        case '--color=never':\n                        case '--colors=never':\n                            return static::$defaultColors = false;\n                    }\n                }\n            }\n        }\n\n        $h = stream_get_meta_data($this->outputStream) + ['wrapper_type' => null];\n        $h = 'Output' === $h['stream_type'] && 'PHP' === $h['wrapper_type'] ? fopen('php://stdout', 'w') : $this->outputStream;\n\n        return static::$defaultColors = $this->hasColorSupport($h);\n    }\n\n    /**\n     * @return void\n     */\n    protected function dumpLine(int $depth, bool $endOfValue = false)\n    {\n        if ($this->colors) {\n            $this->line = sprintf(\"\\033[%sm%s\\033[m\", $this->styles['default'], $this->line);\n        }\n        parent::dumpLine($depth);\n    }\n\n    /**\n     * @return void\n     */\n    protected function endValue(Cursor $cursor)\n    {\n        if (-1 === $cursor->hashType) {\n            return;\n        }\n\n        if (Stub::ARRAY_INDEXED === $cursor->hashType || Stub::ARRAY_ASSOC === $cursor->hashType) {\n            if (self::DUMP_TRAILING_COMMA & $this->flags && 0 < $cursor->depth) {\n                $this->line .= ',';\n            } elseif (self::DUMP_COMMA_SEPARATOR & $this->flags && 1 < $cursor->hashLength - $cursor->hashIndex) {\n                $this->line .= ',';\n            }\n        }\n\n        $this->dumpLine($cursor->depth, true);\n    }\n\n    /**\n     * Returns true if the stream supports colorization.\n     *\n     * Reference: Composer\\XdebugHandler\\Process::supportsColor\n     * https://github.com/composer/xdebug-handler\n     */\n    private function hasColorSupport(mixed $stream): bool\n    {\n        if (!\\is_resource($stream) || 'stream' !== get_resource_type($stream)) {\n            return false;\n        }\n\n        // Follow https://no-color.org/\n        if (isset($_SERVER['NO_COLOR']) || false !== getenv('NO_COLOR')) {\n            return false;\n        }\n\n        if ('Hyper' === getenv('TERM_PROGRAM')) {\n            return true;\n        }\n\n        if (\\DIRECTORY_SEPARATOR === '\\\\') {\n            return (\\function_exists('sapi_windows_vt100_support')\n                && @sapi_windows_vt100_support($stream))\n                || false !== getenv('ANSICON')\n                || 'ON' === getenv('ConEmuANSI')\n                || 'xterm' === getenv('TERM');\n        }\n\n        return stream_isatty($stream);\n    }\n\n    /**\n     * Returns true if the Windows terminal supports true color.\n     *\n     * Note that this does not check an output stream, but relies on environment\n     * variables from known implementations, or a PHP and Windows version that\n     * supports true color.\n     */\n    private function isWindowsTrueColor(): bool\n    {\n        $result = 183 <= getenv('ANSICON_VER')\n            || 'ON' === getenv('ConEmuANSI')\n            || 'xterm' === getenv('TERM')\n            || 'Hyper' === getenv('TERM_PROGRAM');\n\n        if (!$result) {\n            $version = sprintf(\n                '%s.%s.%s',\n                PHP_WINDOWS_VERSION_MAJOR,\n                PHP_WINDOWS_VERSION_MINOR,\n                PHP_WINDOWS_VERSION_BUILD\n            );\n            $result = $version >= '10.0.15063';\n        }\n\n        return $result;\n    }\n\n    private function getSourceLink(string $file, int $line): string|false\n    {\n        if ($fmt = $this->displayOptions['fileLinkFormat']) {\n            return \\is_string($fmt) ? strtr($fmt, ['%f' => $file, '%l' => $line]) : ($fmt->format($file, $line) ?: 'file://'.$file.'#L'.$line);\n        }\n\n        return false;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Dumper/ContextProvider/CliContextProvider.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Dumper\\ContextProvider;\n\n/**\n * Tries to provide context on CLI.\n *\n * @author Maxime Steinhausser <maxime.steinhausser@gmail.com>\n */\nfinal class CliContextProvider implements ContextProviderInterface\n{\n    public function getContext(): ?array\n    {\n        if ('cli' !== \\PHP_SAPI) {\n            return null;\n        }\n\n        return [\n            'command_line' => $commandLine = implode(' ', $_SERVER['argv'] ?? []),\n            'identifier' => hash('crc32b', $commandLine.$_SERVER['REQUEST_TIME_FLOAT']),\n        ];\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Dumper/ContextProvider/ContextProviderInterface.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Dumper\\ContextProvider;\n\n/**\n * Interface to provide contextual data about dump data clones sent to a server.\n *\n * @author Maxime Steinhausser <maxime.steinhausser@gmail.com>\n */\ninterface ContextProviderInterface\n{\n    public function getContext(): ?array;\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Dumper/ContextProvider/RequestContextProvider.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Dumper\\ContextProvider;\n\nuse Symfony\\Component\\HttpFoundation\\RequestStack;\nuse Symfony\\Component\\VarDumper\\Caster\\ReflectionCaster;\nuse Symfony\\Component\\VarDumper\\Cloner\\VarCloner;\n\n/**\n * Tries to provide context from a request.\n *\n * @author Maxime Steinhausser <maxime.steinhausser@gmail.com>\n */\nfinal class RequestContextProvider implements ContextProviderInterface\n{\n    private RequestStack $requestStack;\n    private VarCloner $cloner;\n\n    public function __construct(RequestStack $requestStack)\n    {\n        $this->requestStack = $requestStack;\n        $this->cloner = new VarCloner();\n        $this->cloner->setMaxItems(0);\n        $this->cloner->addCasters(ReflectionCaster::UNSET_CLOSURE_FILE_INFO);\n    }\n\n    public function getContext(): ?array\n    {\n        if (null === $request = $this->requestStack->getCurrentRequest()) {\n            return null;\n        }\n\n        $controller = $request->attributes->get('_controller');\n\n        return [\n            'uri' => $request->getUri(),\n            'method' => $request->getMethod(),\n            'controller' => $controller ? $this->cloner->cloneVar($controller) : $controller,\n            'identifier' => spl_object_hash($request),\n        ];\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Dumper/ContextProvider/SourceContextProvider.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Dumper\\ContextProvider;\n\nuse Symfony\\Component\\HttpKernel\\Debug\\FileLinkFormatter;\nuse Symfony\\Component\\VarDumper\\Cloner\\VarCloner;\nuse Symfony\\Component\\VarDumper\\Dumper\\HtmlDumper;\nuse Symfony\\Component\\VarDumper\\VarDumper;\nuse Twig\\Template;\n\n/**\n * Tries to provide context from sources (class name, file, line, code excerpt, ...).\n *\n * @author Nicolas Grekas <p@tchwork.com>\n * @author Maxime Steinhausser <maxime.steinhausser@gmail.com>\n */\nfinal class SourceContextProvider implements ContextProviderInterface\n{\n    private int $limit;\n    private ?string $charset;\n    private ?string $projectDir;\n    private ?FileLinkFormatter $fileLinkFormatter;\n\n    public function __construct(string $charset = null, string $projectDir = null, FileLinkFormatter $fileLinkFormatter = null, int $limit = 9)\n    {\n        $this->charset = $charset;\n        $this->projectDir = $projectDir;\n        $this->fileLinkFormatter = $fileLinkFormatter;\n        $this->limit = $limit;\n    }\n\n    public function getContext(): ?array\n    {\n        $trace = debug_backtrace(\\DEBUG_BACKTRACE_PROVIDE_OBJECT | \\DEBUG_BACKTRACE_IGNORE_ARGS, $this->limit);\n\n        $file = $trace[1]['file'];\n        $line = $trace[1]['line'];\n        $name = false;\n        $fileExcerpt = false;\n\n        for ($i = 2; $i < $this->limit; ++$i) {\n            if (isset($trace[$i]['class'], $trace[$i]['function'])\n                && 'dump' === $trace[$i]['function']\n                && VarDumper::class === $trace[$i]['class']\n            ) {\n                $file = $trace[$i]['file'] ?? $file;\n                $line = $trace[$i]['line'] ?? $line;\n\n                while (++$i < $this->limit) {\n                    if (isset($trace[$i]['function'], $trace[$i]['file']) && empty($trace[$i]['class']) && !str_starts_with($trace[$i]['function'], 'call_user_func')) {\n                        $file = $trace[$i]['file'];\n                        $line = $trace[$i]['line'];\n\n                        break;\n                    } elseif (isset($trace[$i]['object']) && $trace[$i]['object'] instanceof Template) {\n                        $template = $trace[$i]['object'];\n                        $name = $template->getTemplateName();\n                        $src = method_exists($template, 'getSourceContext') ? $template->getSourceContext()->getCode() : (method_exists($template, 'getSource') ? $template->getSource() : false);\n                        $info = $template->getDebugInfo();\n                        if (isset($info[$trace[$i - 1]['line']])) {\n                            $line = $info[$trace[$i - 1]['line']];\n                            $file = method_exists($template, 'getSourceContext') ? $template->getSourceContext()->getPath() : null;\n\n                            if ($src) {\n                                $src = explode(\"\\n\", $src);\n                                $fileExcerpt = [];\n\n                                for ($i = max($line - 3, 1), $max = min($line + 3, \\count($src)); $i <= $max; ++$i) {\n                                    $fileExcerpt[] = '<li'.($i === $line ? ' class=\"selected\"' : '').'><code>'.$this->htmlEncode($src[$i - 1]).'</code></li>';\n                                }\n\n                                $fileExcerpt = '<ol start=\"'.max($line - 3, 1).'\">'.implode(\"\\n\", $fileExcerpt).'</ol>';\n                            }\n                        }\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n\n        if (false === $name) {\n            $name = str_replace('\\\\', '/', $file);\n            $name = substr($name, strrpos($name, '/') + 1);\n        }\n\n        $context = ['name' => $name, 'file' => $file, 'line' => $line];\n        $context['file_excerpt'] = $fileExcerpt;\n\n        if (null !== $this->projectDir) {\n            $context['project_dir'] = $this->projectDir;\n            if (str_starts_with($file, $this->projectDir)) {\n                $context['file_relative'] = ltrim(substr($file, \\strlen($this->projectDir)), \\DIRECTORY_SEPARATOR);\n            }\n        }\n\n        if ($this->fileLinkFormatter && $fileLink = $this->fileLinkFormatter->format($context['file'], $context['line'])) {\n            $context['file_link'] = $fileLink;\n        }\n\n        return $context;\n    }\n\n    private function htmlEncode(string $s): string\n    {\n        $html = '';\n\n        $dumper = new HtmlDumper(function ($line) use (&$html) { $html .= $line; }, $this->charset);\n        $dumper->setDumpHeader('');\n        $dumper->setDumpBoundaries('', '');\n\n        $cloner = new VarCloner();\n        $dumper->dump($cloner->cloneVar($s));\n\n        return substr(strip_tags($html), 1, -1);\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Dumper/ContextualizedDumper.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Dumper;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Data;\nuse Symfony\\Component\\VarDumper\\Dumper\\ContextProvider\\ContextProviderInterface;\n\n/**\n * @author Kévin Thérage <therage.kevin@gmail.com>\n */\nclass ContextualizedDumper implements DataDumperInterface\n{\n    private DataDumperInterface $wrappedDumper;\n    private array $contextProviders;\n\n    /**\n     * @param ContextProviderInterface[] $contextProviders\n     */\n    public function __construct(DataDumperInterface $wrappedDumper, array $contextProviders)\n    {\n        $this->wrappedDumper = $wrappedDumper;\n        $this->contextProviders = $contextProviders;\n    }\n\n    /**\n     * @return string|null\n     */\n    public function dump(Data $data)\n    {\n        $context = $data->getContext();\n        foreach ($this->contextProviders as $contextProvider) {\n            $context[$contextProvider::class] = $contextProvider->getContext();\n        }\n\n        return $this->wrappedDumper->dump($data->withContext($context));\n    }\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Dumper/DataDumperInterface.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Dumper;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Data;\n\n/**\n * DataDumperInterface for dumping Data objects.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\ninterface DataDumperInterface\n{\n    /**\n     * @return string|null\n     */\n    public function dump(Data $data);\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Dumper/HtmlDumper.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Dumper;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Cursor;\nuse Symfony\\Component\\VarDumper\\Cloner\\Data;\n\n/**\n * HtmlDumper dumps variables as HTML.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass HtmlDumper extends CliDumper\n{\n    public static $defaultOutput = 'php://output';\n\n    protected static $themes = [\n        'dark' => [\n            'default' => 'background-color:#18171B; color:#FF8400; line-height:1.2em; font:12px Menlo, Monaco, Consolas, monospace; word-wrap: break-word; white-space: pre-wrap; position:relative; z-index:99999; word-break: break-all',\n            'num' => 'font-weight:bold; color:#1299DA',\n            'const' => 'font-weight:bold',\n            'str' => 'font-weight:bold; color:#56DB3A',\n            'note' => 'color:#1299DA',\n            'ref' => 'color:#A0A0A0',\n            'public' => 'color:#FFFFFF',\n            'protected' => 'color:#FFFFFF',\n            'private' => 'color:#FFFFFF',\n            'meta' => 'color:#B729D9',\n            'key' => 'color:#56DB3A',\n            'index' => 'color:#1299DA',\n            'ellipsis' => 'color:#FF8400',\n            'ns' => 'user-select:none;',\n        ],\n        'light' => [\n            'default' => 'background:none; color:#CC7832; line-height:1.2em; font:12px Menlo, Monaco, Consolas, monospace; word-wrap: break-word; white-space: pre-wrap; position:relative; z-index:99999; word-break: break-all',\n            'num' => 'font-weight:bold; color:#1299DA',\n            'const' => 'font-weight:bold',\n            'str' => 'font-weight:bold; color:#629755;',\n            'note' => 'color:#6897BB',\n            'ref' => 'color:#6E6E6E',\n            'public' => 'color:#262626',\n            'protected' => 'color:#262626',\n            'private' => 'color:#262626',\n            'meta' => 'color:#B729D9',\n            'key' => 'color:#789339',\n            'index' => 'color:#1299DA',\n            'ellipsis' => 'color:#CC7832',\n            'ns' => 'user-select:none;',\n        ],\n    ];\n\n    protected $dumpHeader;\n    protected $dumpPrefix = '<pre class=sf-dump id=%s data-indent-pad=\"%s\">';\n    protected $dumpSuffix = '</pre><script>Sfdump(%s)</script>';\n    protected $dumpId = 'sf-dump';\n    protected $colors = true;\n    protected $headerIsDumped = false;\n    protected $lastDepth = -1;\n    protected $styles;\n\n    private array $displayOptions = [\n        'maxDepth' => 1,\n        'maxStringLength' => 160,\n        'fileLinkFormat' => null,\n    ];\n    private array $extraDisplayOptions = [];\n\n    public function __construct($output = null, string $charset = null, int $flags = 0)\n    {\n        AbstractDumper::__construct($output, $charset, $flags);\n        $this->dumpId = 'sf-dump-'.mt_rand();\n        $this->displayOptions['fileLinkFormat'] = \\ini_get('xdebug.file_link_format') ?: get_cfg_var('xdebug.file_link_format');\n        $this->styles = static::$themes['dark'] ?? self::$themes['dark'];\n    }\n\n    /**\n     * @return void\n     */\n    public function setStyles(array $styles)\n    {\n        $this->headerIsDumped = false;\n        $this->styles = $styles + $this->styles;\n    }\n\n    /**\n     * @return void\n     */\n    public function setTheme(string $themeName)\n    {\n        if (!isset(static::$themes[$themeName])) {\n            throw new \\InvalidArgumentException(sprintf('Theme \"%s\" does not exist in class \"%s\".', $themeName, static::class));\n        }\n\n        $this->setStyles(static::$themes[$themeName]);\n    }\n\n    /**\n     * Configures display options.\n     *\n     * @param array $displayOptions A map of display options to customize the behavior\n     *\n     * @return void\n     */\n    public function setDisplayOptions(array $displayOptions)\n    {\n        $this->headerIsDumped = false;\n        $this->displayOptions = $displayOptions + $this->displayOptions;\n    }\n\n    /**\n     * Sets an HTML header that will be dumped once in the output stream.\n     *\n     * @return void\n     */\n    public function setDumpHeader(?string $header)\n    {\n        $this->dumpHeader = $header;\n    }\n\n    /**\n     * Sets an HTML prefix and suffix that will encapse every single dump.\n     *\n     * @return void\n     */\n    public function setDumpBoundaries(string $prefix, string $suffix)\n    {\n        $this->dumpPrefix = $prefix;\n        $this->dumpSuffix = $suffix;\n    }\n\n    public function dump(Data $data, $output = null, array $extraDisplayOptions = []): ?string\n    {\n        $this->extraDisplayOptions = $extraDisplayOptions;\n        $result = parent::dump($data, $output);\n        $this->dumpId = 'sf-dump-'.mt_rand();\n\n        return $result;\n    }\n\n    /**\n     * Dumps the HTML header.\n     *\n     * @return string\n     */\n    protected function getDumpHeader()\n    {\n        $this->headerIsDumped = $this->outputStream ?? $this->lineDumper;\n\n        if (null !== $this->dumpHeader) {\n            return $this->dumpHeader;\n        }\n\n        $line = str_replace('{$options}', json_encode($this->displayOptions, \\JSON_FORCE_OBJECT), <<<'EOHTML'\n<script>\nSfdump = window.Sfdump || (function (doc) {\n\ndoc.documentElement.classList.add('sf-js-enabled');\n\nvar rxEsc = /([.*+?^${}()|\\[\\]\\/\\\\])/g,\n    idRx = /\\bsf-dump-\\d+-ref[012]\\w+\\b/,\n    keyHint = 0 <= navigator.platform.toUpperCase().indexOf('MAC') ? 'Cmd' : 'Ctrl',\n    addEventListener = function (e, n, cb) {\n        e.addEventListener(n, cb, false);\n    };\n\nif (!doc.addEventListener) {\n    addEventListener = function (element, eventName, callback) {\n        element.attachEvent('on' + eventName, function (e) {\n            e.preventDefault = function () {e.returnValue = false;};\n            e.target = e.srcElement;\n            callback(e);\n        });\n    };\n}\n\nfunction toggle(a, recursive) {\n    var s = a.nextSibling || {}, oldClass = s.className, arrow, newClass;\n\n    if (/\\bsf-dump-compact\\b/.test(oldClass)) {\n        arrow = '▼';\n        newClass = 'sf-dump-expanded';\n    } else if (/\\bsf-dump-expanded\\b/.test(oldClass)) {\n        arrow = '▶';\n        newClass = 'sf-dump-compact';\n    } else {\n        return false;\n    }\n\n    if (doc.createEvent && s.dispatchEvent) {\n        var event = doc.createEvent('Event');\n        event.initEvent('sf-dump-expanded' === newClass ? 'sfbeforedumpexpand' : 'sfbeforedumpcollapse', true, false);\n\n        s.dispatchEvent(event);\n    }\n\n    a.lastChild.innerHTML = arrow;\n    s.className = s.className.replace(/\\bsf-dump-(compact|expanded)\\b/, newClass);\n\n    if (recursive) {\n        try {\n            a = s.querySelectorAll('.'+oldClass);\n            for (s = 0; s < a.length; ++s) {\n                if (-1 == a[s].className.indexOf(newClass)) {\n                    a[s].className = newClass;\n                    a[s].previousSibling.lastChild.innerHTML = arrow;\n                }\n            }\n        } catch (e) {\n        }\n    }\n\n    return true;\n};\n\nfunction collapse(a, recursive) {\n    var s = a.nextSibling || {}, oldClass = s.className;\n\n    if (/\\bsf-dump-expanded\\b/.test(oldClass)) {\n        toggle(a, recursive);\n\n        return true;\n    }\n\n    return false;\n};\n\nfunction expand(a, recursive) {\n    var s = a.nextSibling || {}, oldClass = s.className;\n\n    if (/\\bsf-dump-compact\\b/.test(oldClass)) {\n        toggle(a, recursive);\n\n        return true;\n    }\n\n    return false;\n};\n\nfunction collapseAll(root) {\n    var a = root.querySelector('a.sf-dump-toggle');\n    if (a) {\n        collapse(a, true);\n        expand(a);\n\n        return true;\n    }\n\n    return false;\n}\n\nfunction reveal(node) {\n    var previous, parents = [];\n\n    while ((node = node.parentNode || {}) && (previous = node.previousSibling) && 'A' === previous.tagName) {\n        parents.push(previous);\n    }\n\n    if (0 !== parents.length) {\n        parents.forEach(function (parent) {\n            expand(parent);\n        });\n\n        return true;\n    }\n\n    return false;\n}\n\nfunction highlight(root, activeNode, nodes) {\n    resetHighlightedNodes(root);\n\n    Array.from(nodes||[]).forEach(function (node) {\n        if (!/\\bsf-dump-highlight\\b/.test(node.className)) {\n            node.className = node.className + ' sf-dump-highlight';\n        }\n    });\n\n    if (!/\\bsf-dump-highlight-active\\b/.test(activeNode.className)) {\n        activeNode.className = activeNode.className + ' sf-dump-highlight-active';\n    }\n}\n\nfunction resetHighlightedNodes(root) {\n    Array.from(root.querySelectorAll('.sf-dump-str, .sf-dump-key, .sf-dump-public, .sf-dump-protected, .sf-dump-private')).forEach(function (strNode) {\n        strNode.className = strNode.className.replace(/\\bsf-dump-highlight\\b/, '');\n        strNode.className = strNode.className.replace(/\\bsf-dump-highlight-active\\b/, '');\n    });\n}\n\nreturn function (root, x) {\n    root = doc.getElementById(root);\n\n    var indentRx = new RegExp('^('+(root.getAttribute('data-indent-pad') || '  ').replace(rxEsc, '\\\\$1')+')+', 'm'),\n        options = {$options},\n        elt = root.getElementsByTagName('A'),\n        len = elt.length,\n        i = 0, s, h,\n        t = [];\n\n    while (i < len) t.push(elt[i++]);\n\n    for (i in x) {\n        options[i] = x[i];\n    }\n\n    function a(e, f) {\n        addEventListener(root, e, function (e, n) {\n            if ('A' == e.target.tagName) {\n                f(e.target, e);\n            } else if ('A' == e.target.parentNode.tagName) {\n                f(e.target.parentNode, e);\n            } else {\n                n = /\\bsf-dump-ellipsis\\b/.test(e.target.className) ? e.target.parentNode : e.target;\n\n                if ((n = n.nextElementSibling) && 'A' == n.tagName) {\n                    if (!/\\bsf-dump-toggle\\b/.test(n.className)) {\n                        n = n.nextElementSibling || n;\n                    }\n\n                    f(n, e, true);\n                }\n            }\n        });\n    };\n    function isCtrlKey(e) {\n        return e.ctrlKey || e.metaKey;\n    }\n    function xpathString(str) {\n        var parts = str.match(/[^'\"]+|['\"]/g).map(function (part) {\n            if (\"'\" == part)  {\n                return '\"\\'\"';\n            }\n            if ('\"' == part) {\n                return \"'\\\"'\";\n            }\n\n            return \"'\" + part + \"'\";\n        });\n\n        return \"concat(\" + parts.join(\",\") + \", '')\";\n    }\n    function xpathHasClass(className) {\n        return \"contains(concat(' ', normalize-space(@class), ' '), ' \" + className +\" ')\";\n    }\n    a('mouseover', function (a, e, c) {\n        if (c) {\n            e.target.style.cursor = \"pointer\";\n        }\n    });\n    a('click', function (a, e, c) {\n        if (/\\bsf-dump-toggle\\b/.test(a.className)) {\n            e.preventDefault();\n            if (!toggle(a, isCtrlKey(e))) {\n                var r = doc.getElementById(a.getAttribute('href').slice(1)),\n                    s = r.previousSibling,\n                    f = r.parentNode,\n                    t = a.parentNode;\n                t.replaceChild(r, a);\n                f.replaceChild(a, s);\n                t.insertBefore(s, r);\n                f = f.firstChild.nodeValue.match(indentRx);\n                t = t.firstChild.nodeValue.match(indentRx);\n                if (f && t && f[0] !== t[0]) {\n                    r.innerHTML = r.innerHTML.replace(new RegExp('^'+f[0].replace(rxEsc, '\\\\$1'), 'mg'), t[0]);\n                }\n                if (/\\bsf-dump-compact\\b/.test(r.className)) {\n                    toggle(s, isCtrlKey(e));\n                }\n            }\n\n            if (c) {\n            } else if (doc.getSelection) {\n                try {\n                    doc.getSelection().removeAllRanges();\n                } catch (e) {\n                    doc.getSelection().empty();\n                }\n            } else {\n                doc.selection.empty();\n            }\n        } else if (/\\bsf-dump-str-toggle\\b/.test(a.className)) {\n            e.preventDefault();\n            e = a.parentNode.parentNode;\n            e.className = e.className.replace(/\\bsf-dump-str-(expand|collapse)\\b/, a.parentNode.className);\n        }\n    });\n\n    elt = root.getElementsByTagName('SAMP');\n    len = elt.length;\n    i = 0;\n\n    while (i < len) t.push(elt[i++]);\n    len = t.length;\n\n    for (i = 0; i < len; ++i) {\n        elt = t[i];\n        if ('SAMP' == elt.tagName) {\n            a = elt.previousSibling || {};\n            if ('A' != a.tagName) {\n                a = doc.createElement('A');\n                a.className = 'sf-dump-ref';\n                elt.parentNode.insertBefore(a, elt);\n            } else {\n                a.innerHTML += ' ';\n            }\n            a.title = (a.title ? a.title+'\\n[' : '[')+keyHint+'+click] Expand all children';\n            a.innerHTML += elt.className == 'sf-dump-compact' ? '<span>▶</span>' : '<span>▼</span>';\n            a.className += ' sf-dump-toggle';\n\n            x = 1;\n            if ('sf-dump' != elt.parentNode.className) {\n                x += elt.parentNode.getAttribute('data-depth')/1;\n            }\n        } else if (/\\bsf-dump-ref\\b/.test(elt.className) && (a = elt.getAttribute('href'))) {\n            a = a.slice(1);\n            elt.className += ' sf-dump-hover';\n            elt.className += ' '+a;\n\n            if (/[\\[{]$/.test(elt.previousSibling.nodeValue)) {\n                a = a != elt.nextSibling.id && doc.getElementById(a);\n                try {\n                    s = a.nextSibling;\n                    elt.appendChild(a);\n                    s.parentNode.insertBefore(a, s);\n                    if (/^[@#]/.test(elt.innerHTML)) {\n                        elt.innerHTML += ' <span>▶</span>';\n                    } else {\n                        elt.innerHTML = '<span>▶</span>';\n                        elt.className = 'sf-dump-ref';\n                    }\n                    elt.className += ' sf-dump-toggle';\n                } catch (e) {\n                    if ('&' == elt.innerHTML.charAt(0)) {\n                        elt.innerHTML = '…';\n                        elt.className = 'sf-dump-ref';\n                    }\n                }\n            }\n        }\n    }\n\n    if (doc.evaluate && Array.from && root.children.length > 1) {\n        root.setAttribute('tabindex', 0);\n\n        SearchState = function () {\n            this.nodes = [];\n            this.idx = 0;\n        };\n        SearchState.prototype = {\n            next: function () {\n                if (this.isEmpty()) {\n                    return this.current();\n                }\n                this.idx = this.idx < (this.nodes.length - 1) ? this.idx + 1 : 0;\n\n                return this.current();\n            },\n            previous: function () {\n                if (this.isEmpty()) {\n                    return this.current();\n                }\n                this.idx = this.idx > 0 ? this.idx - 1 : (this.nodes.length - 1);\n\n                return this.current();\n            },\n            isEmpty: function () {\n                return 0 === this.count();\n            },\n            current: function () {\n                if (this.isEmpty()) {\n                    return null;\n                }\n                return this.nodes[this.idx];\n            },\n            reset: function () {\n                this.nodes = [];\n                this.idx = 0;\n            },\n            count: function () {\n                return this.nodes.length;\n            },\n        };\n\n        function showCurrent(state)\n        {\n            var currentNode = state.current(), currentRect, searchRect;\n            if (currentNode) {\n                reveal(currentNode);\n                highlight(root, currentNode, state.nodes);\n                if ('scrollIntoView' in currentNode) {\n                    currentNode.scrollIntoView(true);\n                    currentRect = currentNode.getBoundingClientRect();\n                    searchRect = search.getBoundingClientRect();\n                    if (currentRect.top < (searchRect.top + searchRect.height)) {\n                        window.scrollBy(0, -(searchRect.top + searchRect.height + 5));\n                    }\n                }\n            }\n            counter.textContent = (state.isEmpty() ? 0 : state.idx + 1) + ' of ' + state.count();\n        }\n\n        var search = doc.createElement('div');\n        search.className = 'sf-dump-search-wrapper sf-dump-search-hidden';\n        search.innerHTML = '\n            <input type=\"text\" class=\"sf-dump-search-input\">\n            <span class=\"sf-dump-search-count\">0 of 0<\\/span>\n            <button type=\"button\" class=\"sf-dump-search-input-previous\" tabindex=\"-1\">\n                <svg viewBox=\"0 0 1792 1792\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M1683 1331l-166 165q-19 19-45 19t-45-19L896 965l-531 531q-19 19-45 19t-45-19l-166-165q-19-19-19-45.5t19-45.5l742-741q19-19 45-19t45 19l742 741q19 19 19 45.5t-19 45.5z\"\\/><\\/svg>\n            <\\/button>\n            <button type=\"button\" class=\"sf-dump-search-input-next\" tabindex=\"-1\">\n                <svg viewBox=\"0 0 1792 1792\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M1683 808l-742 741q-19 19-45 19t-45-19L109 808q-19-19-19-45.5t19-45.5l166-165q19-19 45-19t45 19l531 531 531-531q19-19 45-19t45 19l166 165q19 19 19 45.5t-19 45.5z\"\\/><\\/svg>\n            <\\/button>\n        ';\n        root.insertBefore(search, root.firstChild);\n\n        var state = new SearchState();\n        var searchInput = search.querySelector('.sf-dump-search-input');\n        var counter = search.querySelector('.sf-dump-search-count');\n        var searchInputTimer = 0;\n        var previousSearchQuery = '';\n\n        addEventListener(searchInput, 'keyup', function (e) {\n            var searchQuery = e.target.value;\n            /* Don't perform anything if the pressed key didn't change the query */\n            if (searchQuery === previousSearchQuery) {\n                return;\n            }\n            previousSearchQuery = searchQuery;\n            clearTimeout(searchInputTimer);\n            searchInputTimer = setTimeout(function () {\n                state.reset();\n                collapseAll(root);\n                resetHighlightedNodes(root);\n                if ('' === searchQuery) {\n                    counter.textContent = '0 of 0';\n\n                    return;\n                }\n\n                var classMatches = [\n                    \"sf-dump-str\",\n                    \"sf-dump-key\",\n                    \"sf-dump-public\",\n                    \"sf-dump-protected\",\n                    \"sf-dump-private\",\n                ].map(xpathHasClass).join(' or ');\n\n                var xpathResult = doc.evaluate('.//span[' + classMatches + '][contains(translate(child::text(), ' + xpathString(searchQuery.toUpperCase()) + ', ' + xpathString(searchQuery.toLowerCase()) + '), ' + xpathString(searchQuery.toLowerCase()) + ')]', root, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);\n\n                while (node = xpathResult.iterateNext()) state.nodes.push(node);\n\n                showCurrent(state);\n            }, 400);\n        });\n\n        Array.from(search.querySelectorAll('.sf-dump-search-input-next, .sf-dump-search-input-previous')).forEach(function (btn) {\n            addEventListener(btn, 'click', function (e) {\n                e.preventDefault();\n                -1 !== e.target.className.indexOf('next') ? state.next() : state.previous();\n                searchInput.focus();\n                collapseAll(root);\n                showCurrent(state);\n            })\n        });\n\n        addEventListener(root, 'keydown', function (e) {\n            var isSearchActive = !/\\bsf-dump-search-hidden\\b/.test(search.className);\n            if ((114 === e.keyCode && !isSearchActive) || (isCtrlKey(e) && 70 === e.keyCode)) {\n                /* F3 or CMD/CTRL + F */\n                if (70 === e.keyCode && document.activeElement === searchInput) {\n                   /*\n                    * If CMD/CTRL + F is hit while having focus on search input,\n                    * the user probably meant to trigger browser search instead.\n                    * Let the browser execute its behavior:\n                    */\n                    return;\n                }\n\n                e.preventDefault();\n                search.className = search.className.replace(/\\bsf-dump-search-hidden\\b/, '');\n                searchInput.focus();\n            } else if (isSearchActive) {\n                if (27 === e.keyCode) {\n                    /* ESC key */\n                    search.className += ' sf-dump-search-hidden';\n                    e.preventDefault();\n                    resetHighlightedNodes(root);\n                    searchInput.value = '';\n                } else if (\n                    (isCtrlKey(e) && 71 === e.keyCode) /* CMD/CTRL + G */\n                    || 13 === e.keyCode /* Enter */\n                    || 114 === e.keyCode /* F3 */\n                ) {\n                    e.preventDefault();\n                    e.shiftKey ? state.previous() : state.next();\n                    collapseAll(root);\n                    showCurrent(state);\n                }\n            }\n        });\n    }\n\n    if (0 >= options.maxStringLength) {\n        return;\n    }\n    try {\n        elt = root.querySelectorAll('.sf-dump-str');\n        len = elt.length;\n        i = 0;\n        t = [];\n\n        while (i < len) t.push(elt[i++]);\n        len = t.length;\n\n        for (i = 0; i < len; ++i) {\n            elt = t[i];\n            s = elt.innerText || elt.textContent;\n            x = s.length - options.maxStringLength;\n            if (0 < x) {\n                h = elt.innerHTML;\n                elt[elt.innerText ? 'innerText' : 'textContent'] = s.substring(0, options.maxStringLength);\n                elt.className += ' sf-dump-str-collapse';\n                elt.innerHTML = '<span class=sf-dump-str-collapse>'+h+'<a class=\"sf-dump-ref sf-dump-str-toggle\" title=\"Collapse\"> ◀</a></span>'+\n                    '<span class=sf-dump-str-expand>'+elt.innerHTML+'<a class=\"sf-dump-ref sf-dump-str-toggle\" title=\"'+x+' remaining characters\"> ▶</a></span>';\n            }\n        }\n    } catch (e) {\n    }\n};\n\n})(document);\n</script><style>\n.sf-js-enabled pre.sf-dump .sf-dump-compact,\n.sf-js-enabled .sf-dump-str-collapse .sf-dump-str-collapse,\n.sf-js-enabled .sf-dump-str-expand .sf-dump-str-expand {\n    display: none;\n}\n.sf-dump-hover:hover {\n    background-color: #B729D9;\n    color: #FFF !important;\n    border-radius: 2px;\n}\npre.sf-dump {\n    display: block;\n    white-space: pre;\n    padding: 5px;\n    overflow: initial !important;\n}\npre.sf-dump:after {\n   content: \"\";\n   visibility: hidden;\n   display: block;\n   height: 0;\n   clear: both;\n}\npre.sf-dump span {\n    display: inline;\n}\npre.sf-dump a {\n    text-decoration: none;\n    cursor: pointer;\n    border: 0;\n    outline: none;\n    color: inherit;\n}\npre.sf-dump img {\n    max-width: 50em;\n    max-height: 50em;\n    margin: .5em 0 0 0;\n    padding: 0;\n    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAHUlEQVQY02O8zAABilCaiQEN0EeA8QuUcX9g3QEAAjcC5piyhyEAAAAASUVORK5CYII=) #D3D3D3;\n}\npre.sf-dump .sf-dump-ellipsis {\n    display: inline-block;\n    overflow: visible;\n    text-overflow: ellipsis;\n    max-width: 5em;\n    white-space: nowrap;\n    overflow: hidden;\n    vertical-align: top;\n}\npre.sf-dump .sf-dump-ellipsis+.sf-dump-ellipsis {\n    max-width: none;\n}\npre.sf-dump code {\n    display:inline;\n    padding:0;\n    background:none;\n}\n.sf-dump-public.sf-dump-highlight,\n.sf-dump-protected.sf-dump-highlight,\n.sf-dump-private.sf-dump-highlight,\n.sf-dump-str.sf-dump-highlight,\n.sf-dump-key.sf-dump-highlight {\n    background: rgba(111, 172, 204, 0.3);\n    border: 1px solid #7DA0B1;\n    border-radius: 3px;\n}\n.sf-dump-public.sf-dump-highlight-active,\n.sf-dump-protected.sf-dump-highlight-active,\n.sf-dump-private.sf-dump-highlight-active,\n.sf-dump-str.sf-dump-highlight-active,\n.sf-dump-key.sf-dump-highlight-active {\n    background: rgba(253, 175, 0, 0.4);\n    border: 1px solid #ffa500;\n    border-radius: 3px;\n}\npre.sf-dump .sf-dump-search-hidden {\n    display: none !important;\n}\npre.sf-dump .sf-dump-search-wrapper {\n    font-size: 0;\n    white-space: nowrap;\n    margin-bottom: 5px;\n    display: flex;\n    position: -webkit-sticky;\n    position: sticky;\n    top: 5px;\n}\npre.sf-dump .sf-dump-search-wrapper > * {\n    vertical-align: top;\n    box-sizing: border-box;\n    height: 21px;\n    font-weight: normal;\n    border-radius: 0;\n    background: #FFF;\n    color: #757575;\n    border: 1px solid #BBB;\n}\npre.sf-dump .sf-dump-search-wrapper > input.sf-dump-search-input {\n    padding: 3px;\n    height: 21px;\n    font-size: 12px;\n    border-right: none;\n    border-top-left-radius: 3px;\n    border-bottom-left-radius: 3px;\n    color: #000;\n    min-width: 15px;\n    width: 100%;\n}\npre.sf-dump .sf-dump-search-wrapper > .sf-dump-search-input-next,\npre.sf-dump .sf-dump-search-wrapper > .sf-dump-search-input-previous {\n    background: #F2F2F2;\n    outline: none;\n    border-left: none;\n    font-size: 0;\n    line-height: 0;\n}\npre.sf-dump .sf-dump-search-wrapper > .sf-dump-search-input-next {\n    border-top-right-radius: 3px;\n    border-bottom-right-radius: 3px;\n}\npre.sf-dump .sf-dump-search-wrapper > .sf-dump-search-input-next > svg,\npre.sf-dump .sf-dump-search-wrapper > .sf-dump-search-input-previous > svg {\n    pointer-events: none;\n    width: 12px;\n    height: 12px;\n}\npre.sf-dump .sf-dump-search-wrapper > .sf-dump-search-count {\n    display: inline-block;\n    padding: 0 5px;\n    margin: 0;\n    border-left: none;\n    line-height: 21px;\n    font-size: 12px;\n}\nEOHTML\n        );\n\n        foreach ($this->styles as $class => $style) {\n            $line .= 'pre.sf-dump'.('default' === $class ? ', pre.sf-dump' : '').' .sf-dump-'.$class.'{'.$style.'}';\n        }\n        $line .= 'pre.sf-dump .sf-dump-ellipsis-note{'.$this->styles['note'].'}';\n\n        return $this->dumpHeader = preg_replace('/\\s+/', ' ', $line).'</style>'.$this->dumpHeader;\n    }\n\n    /**\n     * @return void\n     */\n    public function dumpString(Cursor $cursor, string $str, bool $bin, int $cut)\n    {\n        if ('' === $str && isset($cursor->attr['img-data'], $cursor->attr['content-type'])) {\n            $this->dumpKey($cursor);\n            $this->line .= $this->style('default', $cursor->attr['img-size'] ?? '', []);\n            $this->line .= $cursor->depth >= $this->displayOptions['maxDepth'] ? ' <samp class=sf-dump-compact>' : ' <samp class=sf-dump-expanded>';\n            $this->endValue($cursor);\n            $this->line .= $this->indentPad;\n            $this->line .= sprintf('<img src=\"data:%s;base64,%s\" /></samp>', $cursor->attr['content-type'], base64_encode($cursor->attr['img-data']));\n            $this->endValue($cursor);\n        } else {\n            parent::dumpString($cursor, $str, $bin, $cut);\n        }\n    }\n\n    /**\n     * @return void\n     */\n    public function enterHash(Cursor $cursor, int $type, string|int|null $class, bool $hasChild)\n    {\n        if (Cursor::HASH_OBJECT === $type) {\n            $cursor->attr['depth'] = $cursor->depth;\n        }\n        parent::enterHash($cursor, $type, $class, false);\n\n        if ($cursor->skipChildren || $cursor->depth >= $this->displayOptions['maxDepth']) {\n            $cursor->skipChildren = false;\n            $eol = ' class=sf-dump-compact>';\n        } else {\n            $this->expandNextHash = false;\n            $eol = ' class=sf-dump-expanded>';\n        }\n\n        if ($hasChild) {\n            $this->line .= '<samp data-depth='.($cursor->depth + 1);\n            if ($cursor->refIndex) {\n                $r = Cursor::HASH_OBJECT !== $type ? 1 - (Cursor::HASH_RESOURCE !== $type) : 2;\n                $r .= $r && 0 < $cursor->softRefHandle ? $cursor->softRefHandle : $cursor->refIndex;\n\n                $this->line .= sprintf(' id=%s-ref%s', $this->dumpId, $r);\n            }\n            $this->line .= $eol;\n            $this->dumpLine($cursor->depth);\n        }\n    }\n\n    /**\n     * @return void\n     */\n    public function leaveHash(Cursor $cursor, int $type, string|int|null $class, bool $hasChild, int $cut)\n    {\n        $this->dumpEllipsis($cursor, $hasChild, $cut);\n        if ($hasChild) {\n            $this->line .= '</samp>';\n        }\n        parent::leaveHash($cursor, $type, $class, $hasChild, 0);\n    }\n\n    protected function style(string $style, string $value, array $attr = []): string\n    {\n        if ('' === $value && ('label' !== $style || !isset($attr['file']) && !isset($attr['href']))) {\n            return '';\n        }\n\n        $v = esc($value);\n\n        if ('ref' === $style) {\n            if (empty($attr['count'])) {\n                return sprintf('<a class=sf-dump-ref>%s</a>', $v);\n            }\n            $r = ('#' !== $v[0] ? 1 - ('@' !== $v[0]) : 2).substr($value, 1);\n\n            return sprintf('<a class=sf-dump-ref href=#%s-ref%s title=\"%d occurrences\">%s</a>', $this->dumpId, $r, 1 + $attr['count'], $v);\n        }\n\n        if ('const' === $style && isset($attr['value'])) {\n            $style .= sprintf(' title=\"%s\"', esc(\\is_scalar($attr['value']) ? $attr['value'] : json_encode($attr['value'])));\n        } elseif ('public' === $style) {\n            $style .= sprintf(' title=\"%s\"', empty($attr['dynamic']) ? 'Public property' : 'Runtime added dynamic property');\n        } elseif ('str' === $style && 1 < $attr['length']) {\n            $style .= sprintf(' title=\"%d%s characters\"', $attr['length'], $attr['binary'] ? ' binary or non-UTF-8' : '');\n        } elseif ('note' === $style && 0 < ($attr['depth'] ?? 0) && false !== $c = strrpos($value, '\\\\')) {\n            $style .= ' title=\"\"';\n            $attr += [\n                'ellipsis' => \\strlen($value) - $c,\n                'ellipsis-type' => 'note',\n                'ellipsis-tail' => 1,\n            ];\n        } elseif ('protected' === $style) {\n            $style .= ' title=\"Protected property\"';\n        } elseif ('meta' === $style && isset($attr['title'])) {\n            $style .= sprintf(' title=\"%s\"', esc($this->utf8Encode($attr['title'])));\n        } elseif ('private' === $style) {\n            $style .= sprintf(' title=\"Private property defined in class:&#10;`%s`\"', esc($this->utf8Encode($attr['class'])));\n        }\n\n        if (isset($attr['ellipsis'])) {\n            $class = 'sf-dump-ellipsis';\n            if (isset($attr['ellipsis-type'])) {\n                $class = sprintf('\"%s sf-dump-ellipsis-%s\"', $class, $attr['ellipsis-type']);\n            }\n            $label = esc(substr($value, -$attr['ellipsis']));\n            $style = str_replace(' title=\"', \" title=\\\"$v\\n\", $style);\n            $v = sprintf('<span class=%s>%s</span>', $class, substr($v, 0, -\\strlen($label)));\n\n            if (!empty($attr['ellipsis-tail'])) {\n                $tail = \\strlen(esc(substr($value, -$attr['ellipsis'], $attr['ellipsis-tail'])));\n                $v .= sprintf('<span class=%s>%s</span>%s', $class, substr($label, 0, $tail), substr($label, $tail));\n            } else {\n                $v .= $label;\n            }\n        }\n\n        $map = static::$controlCharsMap;\n        $v = \"<span class=sf-dump-{$style}>\".preg_replace_callback(static::$controlCharsRx, function ($c) use ($map) {\n            $s = $b = '<span class=\"sf-dump-default';\n            $c = $c[$i = 0];\n            if ($ns = \"\\r\" === $c[$i] || \"\\n\" === $c[$i]) {\n                $s .= ' sf-dump-ns';\n            }\n            $s .= '\">';\n            do {\n                if ((\"\\r\" === $c[$i] || \"\\n\" === $c[$i]) !== $ns) {\n                    $s .= '</span>'.$b;\n                    if ($ns = !$ns) {\n                        $s .= ' sf-dump-ns';\n                    }\n                    $s .= '\">';\n                }\n\n                $s .= $map[$c[$i]] ?? sprintf('\\x%02X', \\ord($c[$i]));\n            } while (isset($c[++$i]));\n\n            return $s.'</span>';\n        }, $v).'</span>';\n\n        if (!($attr['binary'] ?? false)) {\n            $v = preg_replace_callback(static::$unicodeCharsRx, function ($c) {\n                return '<span class=sf-dump-default>\\u{'.strtoupper(dechex(mb_ord($c[0]))).'}</span>';\n            }, $v);\n        }\n\n        if (isset($attr['file']) && $href = $this->getSourceLink($attr['file'], $attr['line'] ?? 0)) {\n            $attr['href'] = $href;\n        }\n        if (isset($attr['href'])) {\n            if ('label' === $style) {\n                $v .= '^';\n            }\n            $target = isset($attr['file']) ? '' : ' target=\"_blank\"';\n            $v = sprintf('<a href=\"%s\"%s rel=\"noopener noreferrer\">%s</a>', esc($this->utf8Encode($attr['href'])), $target, $v);\n        }\n        if (isset($attr['lang'])) {\n            $v = sprintf('<code class=\"%s\">%s</code>', esc($attr['lang']), $v);\n        }\n        if ('label' === $style) {\n            $v .= ' ';\n        }\n\n        return $v;\n    }\n\n    /**\n     * @return void\n     */\n    protected function dumpLine(int $depth, bool $endOfValue = false)\n    {\n        if (-1 === $this->lastDepth) {\n            $this->line = sprintf($this->dumpPrefix, $this->dumpId, $this->indentPad).$this->line;\n        }\n        if ($this->headerIsDumped !== ($this->outputStream ?? $this->lineDumper)) {\n            $this->line = $this->getDumpHeader().$this->line;\n        }\n\n        if (-1 === $depth) {\n            $args = ['\"'.$this->dumpId.'\"'];\n            if ($this->extraDisplayOptions) {\n                $args[] = json_encode($this->extraDisplayOptions, \\JSON_FORCE_OBJECT);\n            }\n            // Replace is for BC\n            $this->line .= sprintf(str_replace('\"%s\"', '%s', $this->dumpSuffix), implode(', ', $args));\n        }\n        $this->lastDepth = $depth;\n\n        $this->line = mb_encode_numericentity($this->line, [0x80, 0x10FFFF, 0, 0x1FFFFF], 'UTF-8');\n\n        if (-1 === $depth) {\n            AbstractDumper::dumpLine(0);\n        }\n        AbstractDumper::dumpLine($depth);\n    }\n\n    private function getSourceLink(string $file, int $line): string|false\n    {\n        $options = $this->extraDisplayOptions + $this->displayOptions;\n\n        if ($fmt = $options['fileLinkFormat']) {\n            return \\is_string($fmt) ? strtr($fmt, ['%f' => $file, '%l' => $line]) : $fmt->format($file, $line);\n        }\n\n        return false;\n    }\n}\n\nfunction esc(string $str): string\n{\n    return htmlspecialchars($str, \\ENT_QUOTES, 'UTF-8');\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Dumper/ServerDumper.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Dumper;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Data;\nuse Symfony\\Component\\VarDumper\\Dumper\\ContextProvider\\ContextProviderInterface;\nuse Symfony\\Component\\VarDumper\\Server\\Connection;\n\n/**\n * ServerDumper forwards serialized Data clones to a server.\n *\n * @author Maxime Steinhausser <maxime.steinhausser@gmail.com>\n */\nclass ServerDumper implements DataDumperInterface\n{\n    private Connection $connection;\n    private ?DataDumperInterface $wrappedDumper;\n\n    /**\n     * @param string                     $host             The server host\n     * @param DataDumperInterface|null   $wrappedDumper    A wrapped instance used whenever we failed contacting the server\n     * @param ContextProviderInterface[] $contextProviders Context providers indexed by context name\n     */\n    public function __construct(string $host, DataDumperInterface $wrappedDumper = null, array $contextProviders = [])\n    {\n        $this->connection = new Connection($host, $contextProviders);\n        $this->wrappedDumper = $wrappedDumper;\n    }\n\n    public function getContextProviders(): array\n    {\n        return $this->connection->getContextProviders();\n    }\n\n    /**\n     * @return string|null\n     */\n    public function dump(Data $data)\n    {\n        if (!$this->connection->write($data) && $this->wrappedDumper) {\n            return $this->wrappedDumper->dump($data);\n        }\n\n        return null;\n    }\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Exception/ThrowingCasterException.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Exception;\n\n/**\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass ThrowingCasterException extends \\Exception\n{\n    /**\n     * @param \\Throwable $prev The exception thrown from the caster\n     */\n    public function __construct(\\Throwable $prev)\n    {\n        parent::__construct('Unexpected '.$prev::class.' thrown from a caster: '.$prev->getMessage(), 0, $prev);\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/LICENSE',
    'Copyright (c) 2014-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/README.md',
    'VarDumper Component\n===================\n\nThe VarDumper component provides mechanisms for walking through any arbitrary\nPHP variable. It provides a better `dump()` function that you can use instead\nof `var_dump()`.\n\nResources\n---------\n\n * [Documentation](https://symfony.com/doc/current/components/var_dumper/introduction.html)\n * [Contributing](https://symfony.com/doc/current/contributing/index.html)\n * [Report issues](https://github.com/symfony/symfony/issues) and\n   [send Pull Requests](https://github.com/symfony/symfony/pulls)\n   in the [main Symfony repository](https://github.com/symfony/symfony)\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Resources/bin/var-dump-server',
    "#!/usr/bin/env php\n<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nif ('cli' !== PHP_SAPI) {\n    throw new Exception('This script must be run from the command line.');\n}\n\n/**\n * Starts a dump server to collect and output dumps on a single place with multiple formats support.\n *\n * @author Maxime Steinhausser <maxime.steinhausser@gmail.com>\n */\n\nuse Psr\\Log\\LoggerInterface;\nuse Symfony\\Component\\Console\\Application;\nuse Symfony\\Component\\Console\\Input\\ArgvInput;\nuse Symfony\\Component\\Console\\Input\\InputOption;\nuse Symfony\\Component\\Console\\Logger\\ConsoleLogger;\nuse Symfony\\Component\\Console\\Output\\ConsoleOutput;\nuse Symfony\\Component\\VarDumper\\Command\\ServerDumpCommand;\nuse Symfony\\Component\\VarDumper\\Server\\DumpServer;\n\nfunction includeIfExists(string $file): bool\n{\n    return file_exists($file) && include $file;\n}\n\nif (\n    !includeIfExists(__DIR__ . '/../../../../autoload.php') &&\n    !includeIfExists(__DIR__ . '/../../vendor/autoload.php') &&\n    !includeIfExists(__DIR__ . '/../../../../../../vendor/autoload.php')\n) {\n    fwrite(STDERR, 'Install dependencies using Composer.'.PHP_EOL);\n    exit(1);\n}\n\nif (!class_exists(Application::class)) {\n    fwrite(STDERR, 'You need the \"symfony/console\" component in order to run the VarDumper server.'.PHP_EOL);\n    exit(1);\n}\n\n$input = new ArgvInput();\n$output = new ConsoleOutput();\n$defaultHost = '127.0.0.1:9912';\n$host = $input->getParameterOption(['--host'], $_SERVER['VAR_DUMPER_SERVER'] ?? $defaultHost, true);\n$logger = interface_exists(LoggerInterface::class) ? new ConsoleLogger($output->getErrorOutput()) : null;\n\n$app = new Application();\n\n$app->getDefinition()->addOption(\n    new InputOption('--host', null, InputOption::VALUE_REQUIRED, 'The address the server should listen to', $defaultHost)\n);\n\n$app->add($command = new ServerDumpCommand(new DumpServer($host, $logger)))\n    ->getApplication()\n    ->setDefaultCommand($command->getName(), true)\n    ->run($input, $output)\n;\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Resources/css/htmlDescriptor.css',
    'body {\n    display: flex;\n    flex-direction: column-reverse;\n    justify-content: flex-end;\n    max-width: 1140px;\n    margin: auto;\n    padding: 15px;\n    word-wrap: break-word;\n    background-color: #F9F9F9;\n    color: #222;\n    font-family: Helvetica, Arial, sans-serif;\n    font-size: 14px;\n    line-height: 1.4;\n}\np {\n    margin: 0;\n}\na {\n    color: #218BC3;\n    text-decoration: none;\n}\na:hover {\n    text-decoration: underline;\n}\n.text-small {\n    font-size: 12px !important;\n}\narticle {\n    margin: 5px;\n    margin-bottom: 10px;\n}\narticle > header > .row {\n    display: flex;\n    flex-direction: row;\n    align-items: baseline;\n    margin-bottom: 10px;\n}\narticle > header > .row > .col {\n    flex: 1;\n    display: flex;\n    align-items: baseline;\n}\narticle > header > .row > h2 {\n    font-size: 14px;\n    color: #222;\n    font-weight: normal;\n    font-family: "Lucida Console", monospace, sans-serif;\n    word-break: break-all;\n    margin: 20px 5px 0 0;\n    user-select: all;\n}\narticle > header > .row > h2 > code {\n    white-space: nowrap;\n    user-select: none;\n    color: #cc2255;\n    background-color: #f7f7f9;\n    border: 1px solid #e1e1e8;\n    border-radius: 3px;\n    margin-right: 5px;\n    padding: 0 3px;\n}\narticle > header > .row > time.col {\n    flex: 0;\n    text-align: right;\n    white-space: nowrap;\n    color: #999;\n    font-style: italic;\n}\narticle > header ul.tags {\n    list-style: none;\n    padding: 0;\n    margin: 0;\n    font-size: 12px;\n}\narticle > header ul.tags > li {\n    user-select: all;\n    margin-bottom: 2px;\n}\narticle > header ul.tags > li > span.badge {\n    display: inline-block;\n    padding: .25em .4em;\n    margin-right: 5px;\n    border-radius: 4px;\n    background-color: #6c757d3b;\n    color: #524d4d;\n    font-size: 12px;\n    text-align: center;\n    font-weight: 700;\n    line-height: 1;\n    white-space: nowrap;\n    vertical-align: baseline;\n    user-select: none;\n}\narticle > section.body {\n    border: 1px solid #d8d8d8;\n    background: #FFF;\n    padding: 10px;\n    border-radius: 3px;\n}\npre.sf-dump {\n    border-radius: 3px;\n    margin-bottom: 0;\n}\n.hidden {\n    display: none !important;\n}\n.dumped-tag > .sf-dump {\n    display: inline-block;\n    margin: 0;\n    padding: 1px 5px;\n    line-height: 1.4;\n    vertical-align: top;\n    background-color: transparent;\n    user-select: auto;\n}\n.dumped-tag > pre.sf-dump,\n.dumped-tag > .sf-dump-default {\n    color: #CC7832;\n    background: none;\n}\n.dumped-tag > .sf-dump .sf-dump-str { color: #629755; }\n.dumped-tag > .sf-dump .sf-dump-private,\n.dumped-tag > .sf-dump .sf-dump-protected,\n.dumped-tag > .sf-dump .sf-dump-public { color: #262626; }\n.dumped-tag > .sf-dump .sf-dump-note { color: #6897BB; }\n.dumped-tag > .sf-dump .sf-dump-key { color: #789339; }\n.dumped-tag > .sf-dump .sf-dump-ref { color: #6E6E6E; }\n.dumped-tag > .sf-dump .sf-dump-ellipsis { color: #CC7832; max-width: 100em; }\n.dumped-tag > .sf-dump .sf-dump-ellipsis-path { max-width: 5em; }\n.dumped-tag > .sf-dump .sf-dump-ns { user-select: none; }\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Resources/functions/dump.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nuse Symfony\\Component\\VarDumper\\Caster\\ScalarStub;\nuse Symfony\\Component\\VarDumper\\VarDumper;\n\nif (!function_exists('dump')) {\n    /**\n     * @author Nicolas Grekas <p@tchwork.com>\n     * @author Alexandre Daubois <alex.daubois@gmail.com>\n     */\n    function dump(mixed ...$vars): mixed\n    {\n        if (!$vars) {\n            VarDumper::dump(new ScalarStub('🐛'));\n\n            return null;\n        }\n\n        if (array_key_exists(0, $vars) && 1 === count($vars)) {\n            VarDumper::dump($vars[0]);\n            $k = 0;\n        } else {\n            foreach ($vars as $k => $v) {\n                VarDumper::dump($v, is_int($k) ? 1 + $k : $k);\n            }\n        }\n\n        if (1 < count($vars)) {\n            return $vars;\n        }\n\n        return $vars[$k];\n    }\n}\n\nif (!function_exists('dd')) {\n    function dd(mixed ...$vars): never\n    {\n        if (!in_array(\\PHP_SAPI, ['cli', 'phpdbg'], true) && !headers_sent()) {\n            header('HTTP/1.1 500 Internal Server Error');\n        }\n\n        if (array_key_exists(0, $vars) && 1 === count($vars)) {\n            VarDumper::dump($vars[0]);\n        } else {\n            foreach ($vars as $k => $v) {\n                VarDumper::dump($v, is_int($k) ? 1 + $k : $k);\n            }\n        }\n\n        exit(1);\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Resources/js/htmlDescriptor.js',
    "document.addEventListener('DOMContentLoaded', function() {\n  let prev = null;\n  Array.from(document.getElementsByTagName('article')).reverse().forEach(function (article) {\n    const dedupId = article.dataset.dedupId;\n    if (dedupId === prev) {\n      article.getElementsByTagName('header')[0].classList.add('hidden');\n    }\n    prev = dedupId;\n  });\n});\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Server/Connection.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Server;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Data;\nuse Symfony\\Component\\VarDumper\\Dumper\\ContextProvider\\ContextProviderInterface;\n\n/**\n * Forwards serialized Data clones to a server.\n *\n * @author Maxime Steinhausser <maxime.steinhausser@gmail.com>\n */\nclass Connection\n{\n    private string $host;\n    private array $contextProviders;\n\n    /**\n     * @var resource|null\n     */\n    private $socket;\n\n    /**\n     * @param string                     $host             The server host\n     * @param ContextProviderInterface[] $contextProviders Context providers indexed by context name\n     */\n    public function __construct(string $host, array $contextProviders = [])\n    {\n        if (!str_contains($host, '://')) {\n            $host = 'tcp://'.$host;\n        }\n\n        $this->host = $host;\n        $this->contextProviders = $contextProviders;\n    }\n\n    public function getContextProviders(): array\n    {\n        return $this->contextProviders;\n    }\n\n    public function write(Data $data): bool\n    {\n        $socketIsFresh = !$this->socket;\n        if (!$this->socket = $this->socket ?: $this->createSocket()) {\n            return false;\n        }\n\n        $context = ['timestamp' => microtime(true)];\n        foreach ($this->contextProviders as $name => $provider) {\n            $context[$name] = $provider->getContext();\n        }\n        $context = array_filter($context);\n        $encodedPayload = base64_encode(serialize([$data, $context])).\"\\n\";\n\n        set_error_handler(fn () => true);\n        try {\n            if (-1 !== stream_socket_sendto($this->socket, $encodedPayload)) {\n                return true;\n            }\n            if (!$socketIsFresh) {\n                stream_socket_shutdown($this->socket, \\STREAM_SHUT_RDWR);\n                fclose($this->socket);\n                $this->socket = $this->createSocket();\n            }\n            if (-1 !== stream_socket_sendto($this->socket, $encodedPayload)) {\n                return true;\n            }\n        } finally {\n            restore_error_handler();\n        }\n\n        return false;\n    }\n\n    /**\n     * @return resource|null\n     */\n    private function createSocket()\n    {\n        set_error_handler(fn () => true);\n        try {\n            return stream_socket_client($this->host, $errno, $errstr, 3) ?: null;\n        } finally {\n            restore_error_handler();\n        }\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Server/DumpServer.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Server;\n\nuse Psr\\Log\\LoggerInterface;\nuse Symfony\\Component\\VarDumper\\Cloner\\Data;\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * A server collecting Data clones sent by a ServerDumper.\n *\n * @author Maxime Steinhausser <maxime.steinhausser@gmail.com>\n *\n * @final\n */\nclass DumpServer\n{\n    private string $host;\n    private ?LoggerInterface $logger;\n\n    /**\n     * @var resource|null\n     */\n    private $socket;\n\n    public function __construct(string $host, LoggerInterface $logger = null)\n    {\n        if (!str_contains($host, '://')) {\n            $host = 'tcp://'.$host;\n        }\n\n        $this->host = $host;\n        $this->logger = $logger;\n    }\n\n    public function start(): void\n    {\n        if (!$this->socket = stream_socket_server($this->host, $errno, $errstr)) {\n            throw new \\RuntimeException(sprintf('Server start failed on \"%s\": ', $this->host).$errstr.' '.$errno);\n        }\n    }\n\n    public function listen(callable $callback): void\n    {\n        if (null === $this->socket) {\n            $this->start();\n        }\n\n        foreach ($this->getMessages() as $clientId => $message) {\n            $this->logger?->info('Received a payload from client {clientId}', ['clientId' => $clientId]);\n\n            $payload = @unserialize(base64_decode($message), ['allowed_classes' => [Data::class, Stub::class]]);\n\n            // Impossible to decode the message, give up.\n            if (false === $payload) {\n                $this->logger?->warning('Unable to decode a message from {clientId} client.', ['clientId' => $clientId]);\n\n                continue;\n            }\n\n            if (!\\is_array($payload) || \\count($payload) < 2 || !$payload[0] instanceof Data || !\\is_array($payload[1])) {\n                $this->logger?->warning('Invalid payload from {clientId} client. Expected an array of two elements (Data $data, array $context)', ['clientId' => $clientId]);\n\n                continue;\n            }\n\n            [$data, $context] = $payload;\n\n            $callback($data, $context, $clientId);\n        }\n    }\n\n    public function getHost(): string\n    {\n        return $this->host;\n    }\n\n    private function getMessages(): iterable\n    {\n        $sockets = [(int) $this->socket => $this->socket];\n        $write = [];\n\n        while (true) {\n            $read = $sockets;\n            stream_select($read, $write, $write, null);\n\n            foreach ($read as $stream) {\n                if ($this->socket === $stream) {\n                    $stream = stream_socket_accept($this->socket);\n                    $sockets[(int) $stream] = $stream;\n                } elseif (feof($stream)) {\n                    unset($sockets[(int) $stream]);\n                    fclose($stream);\n                } else {\n                    yield (int) $stream => fgets($stream);\n                }\n            }\n        }\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Test/VarDumperTestTrait.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Test;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\VarCloner;\nuse Symfony\\Component\\VarDumper\\Dumper\\CliDumper;\n\n/**\n * @author Nicolas Grekas <p@tchwork.com>\n */\ntrait VarDumperTestTrait\n{\n    /**\n     * @internal\n     */\n    private array $varDumperConfig = [\n        'casters' => [],\n        'flags' => null,\n    ];\n\n    protected function setUpVarDumper(array $casters, int $flags = null): void\n    {\n        $this->varDumperConfig['casters'] = $casters;\n        $this->varDumperConfig['flags'] = $flags;\n    }\n\n    /**\n     * @after\n     */\n    protected function tearDownVarDumper(): void\n    {\n        $this->varDumperConfig['casters'] = [];\n        $this->varDumperConfig['flags'] = null;\n    }\n\n    public function assertDumpEquals(mixed $expected, mixed $data, int $filter = 0, string $message = '')\n    {\n        $this->assertSame($this->prepareExpectation($expected, $filter), $this->getDump($data, null, $filter), $message);\n    }\n\n    public function assertDumpMatchesFormat(mixed $expected, mixed $data, int $filter = 0, string $message = '')\n    {\n        $this->assertStringMatchesFormat($this->prepareExpectation($expected, $filter), $this->getDump($data, null, $filter), $message);\n    }\n\n    protected function getDump(mixed $data, string|int $key = null, int $filter = 0): ?string\n    {\n        if (null === $flags = $this->varDumperConfig['flags']) {\n            $flags = getenv('DUMP_LIGHT_ARRAY') ? CliDumper::DUMP_LIGHT_ARRAY : 0;\n            $flags |= getenv('DUMP_STRING_LENGTH') ? CliDumper::DUMP_STRING_LENGTH : 0;\n            $flags |= getenv('DUMP_COMMA_SEPARATOR') ? CliDumper::DUMP_COMMA_SEPARATOR : 0;\n        }\n\n        $cloner = new VarCloner();\n        $cloner->addCasters($this->varDumperConfig['casters']);\n        $cloner->setMaxItems(-1);\n        $dumper = new CliDumper(null, null, $flags);\n        $dumper->setColors(false);\n        $data = $cloner->cloneVar($data, $filter)->withRefHandles(false);\n        if (null !== $key && null === $data = $data->seek($key)) {\n            return null;\n        }\n\n        return rtrim($dumper->dump($data, true));\n    }\n\n    private function prepareExpectation(mixed $expected, int $filter): string\n    {\n        if (!\\is_string($expected)) {\n            $expected = $this->getDump($expected, null, $filter);\n        }\n\n        return rtrim($expected);\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/VarDumper.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper;\n\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\RequestStack;\nuse Symfony\\Component\\HttpKernel\\Debug\\FileLinkFormatter;\nuse Symfony\\Component\\VarDumper\\Caster\\ReflectionCaster;\nuse Symfony\\Component\\VarDumper\\Cloner\\VarCloner;\nuse Symfony\\Component\\VarDumper\\Dumper\\CliDumper;\nuse Symfony\\Component\\VarDumper\\Dumper\\ContextProvider\\CliContextProvider;\nuse Symfony\\Component\\VarDumper\\Dumper\\ContextProvider\\RequestContextProvider;\nuse Symfony\\Component\\VarDumper\\Dumper\\ContextProvider\\SourceContextProvider;\nuse Symfony\\Component\\VarDumper\\Dumper\\ContextualizedDumper;\nuse Symfony\\Component\\VarDumper\\Dumper\\HtmlDumper;\nuse Symfony\\Component\\VarDumper\\Dumper\\ServerDumper;\n\n// Load the global dump() function\nrequire_once __DIR__.'/Resources/functions/dump.php';\n\n/**\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass VarDumper\n{\n    /**\n     * @var callable|null\n     */\n    private static $handler;\n\n    /**\n     * @param string|null $label\n     *\n     * @return mixed\n     */\n    public static function dump(mixed $var/* , string $label = null */)\n    {\n        $label = 2 <= \\func_num_args() ? func_get_arg(1) : null;\n        if (null === self::$handler) {\n            self::register();\n        }\n\n        return (self::$handler)($var, $label);\n    }\n\n    public static function setHandler(callable $callable = null): ?callable\n    {\n        if (1 > \\func_num_args()) {\n            trigger_deprecation('symfony/var-dumper', '6.2', 'Calling \"%s()\" without any arguments is deprecated, pass null explicitly instead.', __METHOD__);\n        }\n        $prevHandler = self::$handler;\n\n        // Prevent replacing the handler with expected format as soon as the env var was set:\n        if (isset($_SERVER['VAR_DUMPER_FORMAT'])) {\n            return $prevHandler;\n        }\n\n        self::$handler = $callable;\n\n        return $prevHandler;\n    }\n\n    private static function register(): void\n    {\n        $cloner = new VarCloner();\n        $cloner->addCasters(ReflectionCaster::UNSET_CLOSURE_FILE_INFO);\n\n        $format = $_SERVER['VAR_DUMPER_FORMAT'] ?? null;\n        switch (true) {\n            case 'html' === $format:\n                $dumper = new HtmlDumper();\n                break;\n            case 'cli' === $format:\n                $dumper = new CliDumper();\n                break;\n            case 'server' === $format:\n            case $format && 'tcp' === parse_url($format, \\PHP_URL_SCHEME):\n                $host = 'server' === $format ? $_SERVER['VAR_DUMPER_SERVER'] ?? '127.0.0.1:9912' : $format;\n                $dumper = \\in_array(\\PHP_SAPI, ['cli', 'phpdbg'], true) ? new CliDumper() : new HtmlDumper();\n                $dumper = new ServerDumper($host, $dumper, self::getDefaultContextProviders());\n                break;\n            default:\n                $dumper = \\in_array(\\PHP_SAPI, ['cli', 'phpdbg'], true) ? new CliDumper() : new HtmlDumper();\n        }\n\n        if (!$dumper instanceof ServerDumper) {\n            $dumper = new ContextualizedDumper($dumper, [new SourceContextProvider()]);\n        }\n\n        self::$handler = function ($var, string $label = null) use ($cloner, $dumper) {\n            $var = $cloner->cloneVar($var);\n\n            if (null !== $label) {\n                $var = $var->withContext(['label' => $label]);\n            }\n\n            $dumper->dump($var);\n        };\n    }\n\n    private static function getDefaultContextProviders(): array\n    {\n        $contextProviders = [];\n\n        if (!\\in_array(\\PHP_SAPI, ['cli', 'phpdbg'], true) && class_exists(Request::class)) {\n            $requestStack = new RequestStack();\n            $requestStack->push(Request::createFromGlobals());\n            $contextProviders['request'] = new RequestContextProvider($requestStack);\n        }\n\n        $fileLinkFormatter = class_exists(FileLinkFormatter::class) ? new FileLinkFormatter(null, $requestStack ?? null) : null;\n\n        return $contextProviders + [\n            'cli' => new CliContextProvider(),\n            'source' => new SourceContextProvider(null, null, $fileLinkFormatter),\n        ];\n    }\n}\n",
  )
}
