import type { WebPHP } from '@php-wasm/web'

export function setupComposer(php: WebPHP) {
  php.mkdirTree('/arena/vendor/composer')
  php.mkdirTree('/arena/vendor/symfony')
  php.mkdirTree('/arena/vendor/symfony/polyfill-mbstring')
  php.mkdirTree('/arena/vendor/symfony/polyfill-mbstring/Resources')
  php.mkdirTree('/arena/vendor/symfony/polyfill-mbstring/Resources/unidata')
  php.mkdirTree('/arena/vendor/symfony/var-dumper')
  php.mkdirTree('/arena/vendor/symfony/var-dumper/Caster')
  php.mkdirTree('/arena/vendor/symfony/var-dumper/Cloner')
  php.mkdirTree('/arena/vendor/symfony/var-dumper/Dumper')
  php.mkdirTree('/arena/vendor/symfony/var-dumper/Exception')
  php.mkdirTree('/arena/vendor/symfony/var-dumper/Resources')
  php.mkdirTree('/arena/vendor/symfony/var-dumper/Resources/functions')
  php.mkdirTree('/arena/vendor/symfony/var-dumper/Test')
  php.mkdirTree('/arena/vendor/symfony/var-dumper/Tests')
  php.mkdirTree('/arena/vendor/symfony/var-dumper/Tests/Caster')
  php.mkdirTree('/arena/vendor/symfony/var-dumper/Tests/Cloner')
  php.mkdirTree('/arena/vendor/symfony/var-dumper/Tests/Dumper')
  php.mkdirTree('/arena/vendor/symfony/var-dumper/Tests/Fixtures')
  php.mkdirTree('/arena/vendor/symfony/var-dumper/Tests/Test')

  php.writeFile(
    '/arena/vendor/autoload.php',
    "<?php\n\n// autoload.php @generated by Composer\n\nrequire_once __DIR__ . '/composer/autoload_real.php';\n\nreturn ComposerAutoloaderInitffa5c95d62044bc8f73f2a3f518c243f::getLoader();\n",
  )
  php.writeFile(
    '/arena/vendor/composer/autoload_classmap.php',
    '<?php\n\n// autoload_classmap.php @generated by Composer\n\n$vendorDir = dirname(dirname(__FILE__));\n$baseDir = dirname($vendorDir);\n\nreturn array(\n);\n',
  )
  php.writeFile(
    '/arena/vendor/composer/autoload_files.php',
    "<?php\n\n// autoload_files.php @generated by Composer\n\n$vendorDir = dirname(dirname(__FILE__));\n$baseDir = dirname($vendorDir);\n\nreturn array(\n    '0e6d7bf4a5811bfa5cf40c5ccd6fae6a' => $vendorDir . '/symfony/polyfill-mbstring/bootstrap.php',\n    '667aeda72477189d0494fecd327c3641' => $vendorDir . '/symfony/var-dumper/Resources/functions/dump.php',\n);\n",
  )
  php.writeFile(
    '/arena/vendor/composer/autoload_namespaces.php',
    '<?php\n\n// autoload_namespaces.php @generated by Composer\n\n$vendorDir = dirname(dirname(__FILE__));\n$baseDir = dirname($vendorDir);\n\nreturn array(\n);\n',
  )
  php.writeFile(
    '/arena/vendor/composer/autoload_psr4.php',
    "<?php\n\n// autoload_psr4.php @generated by Composer\n\n$vendorDir = dirname(dirname(__FILE__));\n$baseDir = dirname($vendorDir);\n\nreturn array(\n    'Symfony\\\\Polyfill\\\\Mbstring\\\\' => array($vendorDir . '/symfony/polyfill-mbstring'),\n    'Symfony\\\\Component\\\\VarDumper\\\\' => array($vendorDir . '/symfony/var-dumper'),\n);\n",
  )
  php.writeFile(
    '/arena/vendor/composer/autoload_real.php',
    "<?php\n\n// autoload_real.php @generated by Composer\n\nclass ComposerAutoloaderInitffa5c95d62044bc8f73f2a3f518c243f\n{\n    private static $loader;\n\n    public static function loadClassLoader($class)\n    {\n        if ('Composer\\Autoload\\ClassLoader' === $class) {\n            require __DIR__ . '/ClassLoader.php';\n        }\n    }\n\n    /**\n     * @return \\Composer\\Autoload\\ClassLoader\n     */\n    public static function getLoader()\n    {\n        if (null !== self::$loader) {\n            return self::$loader;\n        }\n\n        spl_autoload_register(array('ComposerAutoloaderInitffa5c95d62044bc8f73f2a3f518c243f', 'loadClassLoader'), true, true);\n        self::$loader = $loader = new \\Composer\\Autoload\\ClassLoader();\n        spl_autoload_unregister(array('ComposerAutoloaderInitffa5c95d62044bc8f73f2a3f518c243f', 'loadClassLoader'));\n\n        $useStaticLoader = PHP_VERSION_ID >= 50600 && !defined('HHVM_VERSION') && (!function_exists('zend_loader_file_encoded') || !zend_loader_file_encoded());\n        if ($useStaticLoader) {\n            require_once __DIR__ . '/autoload_static.php';\n\n            call_user_func(\\Composer\\Autoload\\ComposerStaticInitffa5c95d62044bc8f73f2a3f518c243f::getInitializer($loader));\n        } else {\n            $map = require __DIR__ . '/autoload_namespaces.php';\n            foreach ($map as $namespace => $path) {\n                $loader->set($namespace, $path);\n            }\n\n            $map = require __DIR__ . '/autoload_psr4.php';\n            foreach ($map as $namespace => $path) {\n                $loader->setPsr4($namespace, $path);\n            }\n\n            $classMap = require __DIR__ . '/autoload_classmap.php';\n            if ($classMap) {\n                $loader->addClassMap($classMap);\n            }\n        }\n\n        $loader->register(true);\n\n        if ($useStaticLoader) {\n            $includeFiles = Composer\\Autoload\\ComposerStaticInitffa5c95d62044bc8f73f2a3f518c243f::$files;\n        } else {\n            $includeFiles = require __DIR__ . '/autoload_files.php';\n        }\n        foreach ($includeFiles as $fileIdentifier => $file) {\n            composerRequireffa5c95d62044bc8f73f2a3f518c243f($fileIdentifier, $file);\n        }\n\n        return $loader;\n    }\n}\n\nfunction composerRequireffa5c95d62044bc8f73f2a3f518c243f($fileIdentifier, $file)\n{\n    if (empty($GLOBALS['__composer_autoload_files'][$fileIdentifier])) {\n        require $file;\n\n        $GLOBALS['__composer_autoload_files'][$fileIdentifier] = true;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/composer/autoload_static.php',
    "<?php\n\n// autoload_static.php @generated by Composer\n\nnamespace Composer\\Autoload;\n\nclass ComposerStaticInitffa5c95d62044bc8f73f2a3f518c243f\n{\n    public static $files = array (\n        '0e6d7bf4a5811bfa5cf40c5ccd6fae6a' => __DIR__ . '/..' . '/symfony/polyfill-mbstring/bootstrap.php',\n        '667aeda72477189d0494fecd327c3641' => __DIR__ . '/..' . '/symfony/var-dumper/Resources/functions/dump.php',\n    );\n\n    public static $prefixLengthsPsr4 = array (\n        'S' => \n        array (\n            'Symfony\\\\Polyfill\\\\Mbstring\\\\' => 26,\n            'Symfony\\\\Component\\\\VarDumper\\\\' => 28,\n        ),\n    );\n\n    public static $prefixDirsPsr4 = array (\n        'Symfony\\\\Polyfill\\\\Mbstring\\\\' => \n        array (\n            0 => __DIR__ . '/..' . '/symfony/polyfill-mbstring',\n        ),\n        'Symfony\\\\Component\\\\VarDumper\\\\' => \n        array (\n            0 => __DIR__ . '/..' . '/symfony/var-dumper',\n        ),\n    );\n\n    public static function getInitializer(ClassLoader $loader)\n    {\n        return \\Closure::bind(function () use ($loader) {\n            $loader->prefixLengthsPsr4 = ComposerStaticInitffa5c95d62044bc8f73f2a3f518c243f::$prefixLengthsPsr4;\n            $loader->prefixDirsPsr4 = ComposerStaticInitffa5c95d62044bc8f73f2a3f518c243f::$prefixDirsPsr4;\n\n        }, null, ClassLoader::class);\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/composer/ClassLoader.php',
    "<?php\n\n/*\n * This file is part of Composer.\n *\n * (c) Nils Adermann <naderman@naderman.de>\n *     Jordi Boggiano <j.boggiano@seld.be>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Composer\\Autoload;\n\n/**\n * ClassLoader implements a PSR-0, PSR-4 and classmap class loader.\n *\n *     $loader = new \\Composer\\Autoload\\ClassLoader();\n *\n *     // register classes with namespaces\n *     $loader->add('Symfony\\Component', __DIR__.'/component');\n *     $loader->add('Symfony',           __DIR__.'/framework');\n *\n *     // activate the autoloader\n *     $loader->register();\n *\n *     // to enable searching the include path (eg. for PEAR packages)\n *     $loader->setUseIncludePath(true);\n *\n * In this example, if you try to use a class in the Symfony\\Component\n * namespace or one of its children (Symfony\\Component\\Console for instance),\n * the autoloader will first look for the class under the component/\n * directory, and it will then fallback to the framework/ directory if not\n * found before giving up.\n *\n * This class is loosely based on the Symfony UniversalClassLoader.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n * @author Jordi Boggiano <j.boggiano@seld.be>\n * @see    http://www.php-fig.org/psr/psr-0/\n * @see    http://www.php-fig.org/psr/psr-4/\n */\nclass ClassLoader\n{\n    // PSR-4\n    private $prefixLengthsPsr4 = array();\n    private $prefixDirsPsr4 = array();\n    private $fallbackDirsPsr4 = array();\n\n    // PSR-0\n    private $prefixesPsr0 = array();\n    private $fallbackDirsPsr0 = array();\n\n    private $useIncludePath = false;\n    private $classMap = array();\n    private $classMapAuthoritative = false;\n    private $missingClasses = array();\n    private $apcuPrefix;\n\n    public function getPrefixes()\n    {\n        if (!empty($this->prefixesPsr0)) {\n            return call_user_func_array('array_merge', array_values($this->prefixesPsr0));\n        }\n\n        return array();\n    }\n\n    public function getPrefixesPsr4()\n    {\n        return $this->prefixDirsPsr4;\n    }\n\n    public function getFallbackDirs()\n    {\n        return $this->fallbackDirsPsr0;\n    }\n\n    public function getFallbackDirsPsr4()\n    {\n        return $this->fallbackDirsPsr4;\n    }\n\n    public function getClassMap()\n    {\n        return $this->classMap;\n    }\n\n    /**\n     * @param array $classMap Class to filename map\n     */\n    public function addClassMap(array $classMap)\n    {\n        if ($this->classMap) {\n            $this->classMap = array_merge($this->classMap, $classMap);\n        } else {\n            $this->classMap = $classMap;\n        }\n    }\n\n    /**\n     * Registers a set of PSR-0 directories for a given prefix, either\n     * appending or prepending to the ones previously set for this prefix.\n     *\n     * @param string       $prefix  The prefix\n     * @param array|string $paths   The PSR-0 root directories\n     * @param bool         $prepend Whether to prepend the directories\n     */\n    public function add($prefix, $paths, $prepend = false)\n    {\n        if (!$prefix) {\n            if ($prepend) {\n                $this->fallbackDirsPsr0 = array_merge(\n                    (array) $paths,\n                    $this->fallbackDirsPsr0\n                );\n            } else {\n                $this->fallbackDirsPsr0 = array_merge(\n                    $this->fallbackDirsPsr0,\n                    (array) $paths\n                );\n            }\n\n            return;\n        }\n\n        $first = $prefix[0];\n        if (!isset($this->prefixesPsr0[$first][$prefix])) {\n            $this->prefixesPsr0[$first][$prefix] = (array) $paths;\n\n            return;\n        }\n        if ($prepend) {\n            $this->prefixesPsr0[$first][$prefix] = array_merge(\n                (array) $paths,\n                $this->prefixesPsr0[$first][$prefix]\n            );\n        } else {\n            $this->prefixesPsr0[$first][$prefix] = array_merge(\n                $this->prefixesPsr0[$first][$prefix],\n                (array) $paths\n            );\n        }\n    }\n\n    /**\n     * Registers a set of PSR-4 directories for a given namespace, either\n     * appending or prepending to the ones previously set for this namespace.\n     *\n     * @param string       $prefix  The prefix/namespace, with trailing '\\\\'\n     * @param array|string $paths   The PSR-4 base directories\n     * @param bool         $prepend Whether to prepend the directories\n     *\n     * @throws \\InvalidArgumentException\n     */\n    public function addPsr4($prefix, $paths, $prepend = false)\n    {\n        if (!$prefix) {\n            // Register directories for the root namespace.\n            if ($prepend) {\n                $this->fallbackDirsPsr4 = array_merge(\n                    (array) $paths,\n                    $this->fallbackDirsPsr4\n                );\n            } else {\n                $this->fallbackDirsPsr4 = array_merge(\n                    $this->fallbackDirsPsr4,\n                    (array) $paths\n                );\n            }\n        } elseif (!isset($this->prefixDirsPsr4[$prefix])) {\n            // Register directories for a new namespace.\n            $length = strlen($prefix);\n            if ('\\\\' !== $prefix[$length - 1]) {\n                throw new \\InvalidArgumentException(\"A non-empty PSR-4 prefix must end with a namespace separator.\");\n            }\n            $this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;\n            $this->prefixDirsPsr4[$prefix] = (array) $paths;\n        } elseif ($prepend) {\n            // Prepend directories for an already registered namespace.\n            $this->prefixDirsPsr4[$prefix] = array_merge(\n                (array) $paths,\n                $this->prefixDirsPsr4[$prefix]\n            );\n        } else {\n            // Append directories for an already registered namespace.\n            $this->prefixDirsPsr4[$prefix] = array_merge(\n                $this->prefixDirsPsr4[$prefix],\n                (array) $paths\n            );\n        }\n    }\n\n    /**\n     * Registers a set of PSR-0 directories for a given prefix,\n     * replacing any others previously set for this prefix.\n     *\n     * @param string       $prefix The prefix\n     * @param array|string $paths  The PSR-0 base directories\n     */\n    public function set($prefix, $paths)\n    {\n        if (!$prefix) {\n            $this->fallbackDirsPsr0 = (array) $paths;\n        } else {\n            $this->prefixesPsr0[$prefix[0]][$prefix] = (array) $paths;\n        }\n    }\n\n    /**\n     * Registers a set of PSR-4 directories for a given namespace,\n     * replacing any others previously set for this namespace.\n     *\n     * @param string       $prefix The prefix/namespace, with trailing '\\\\'\n     * @param array|string $paths  The PSR-4 base directories\n     *\n     * @throws \\InvalidArgumentException\n     */\n    public function setPsr4($prefix, $paths)\n    {\n        if (!$prefix) {\n            $this->fallbackDirsPsr4 = (array) $paths;\n        } else {\n            $length = strlen($prefix);\n            if ('\\\\' !== $prefix[$length - 1]) {\n                throw new \\InvalidArgumentException(\"A non-empty PSR-4 prefix must end with a namespace separator.\");\n            }\n            $this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;\n            $this->prefixDirsPsr4[$prefix] = (array) $paths;\n        }\n    }\n\n    /**\n     * Turns on searching the include path for class files.\n     *\n     * @param bool $useIncludePath\n     */\n    public function setUseIncludePath($useIncludePath)\n    {\n        $this->useIncludePath = $useIncludePath;\n    }\n\n    /**\n     * Can be used to check if the autoloader uses the include path to check\n     * for classes.\n     *\n     * @return bool\n     */\n    public function getUseIncludePath()\n    {\n        return $this->useIncludePath;\n    }\n\n    /**\n     * Turns off searching the prefix and fallback directories for classes\n     * that have not been registered with the class map.\n     *\n     * @param bool $classMapAuthoritative\n     */\n    public function setClassMapAuthoritative($classMapAuthoritative)\n    {\n        $this->classMapAuthoritative = $classMapAuthoritative;\n    }\n\n    /**\n     * Should class lookup fail if not found in the current class map?\n     *\n     * @return bool\n     */\n    public function isClassMapAuthoritative()\n    {\n        return $this->classMapAuthoritative;\n    }\n\n    /**\n     * APCu prefix to use to cache found/not-found classes, if the extension is enabled.\n     *\n     * @param string|null $apcuPrefix\n     */\n    public function setApcuPrefix($apcuPrefix)\n    {\n        $this->apcuPrefix = function_exists('apcu_fetch') && filter_var(ini_get('apc.enabled'), FILTER_VALIDATE_BOOLEAN) ? $apcuPrefix : null;\n    }\n\n    /**\n     * The APCu prefix in use, or null if APCu caching is not enabled.\n     *\n     * @return string|null\n     */\n    public function getApcuPrefix()\n    {\n        return $this->apcuPrefix;\n    }\n\n    /**\n     * Registers this instance as an autoloader.\n     *\n     * @param bool $prepend Whether to prepend the autoloader or not\n     */\n    public function register($prepend = false)\n    {\n        spl_autoload_register(array($this, 'loadClass'), true, $prepend);\n    }\n\n    /**\n     * Unregisters this instance as an autoloader.\n     */\n    public function unregister()\n    {\n        spl_autoload_unregister(array($this, 'loadClass'));\n    }\n\n    /**\n     * Loads the given class or interface.\n     *\n     * @param  string    $class The name of the class\n     * @return bool|null True if loaded, null otherwise\n     */\n    public function loadClass($class)\n    {\n        if ($file = $this->findFile($class)) {\n            includeFile($file);\n\n            return true;\n        }\n    }\n\n    /**\n     * Finds the path to the file where the class is defined.\n     *\n     * @param string $class The name of the class\n     *\n     * @return string|false The path if found, false otherwise\n     */\n    public function findFile($class)\n    {\n        // class map lookup\n        if (isset($this->classMap[$class])) {\n            return $this->classMap[$class];\n        }\n        if ($this->classMapAuthoritative || isset($this->missingClasses[$class])) {\n            return false;\n        }\n        if (null !== $this->apcuPrefix) {\n            $file = apcu_fetch($this->apcuPrefix.$class, $hit);\n            if ($hit) {\n                return $file;\n            }\n        }\n\n        $file = $this->findFileWithExtension($class, '.php');\n\n        // Search for Hack files if we are running on HHVM\n        if (false === $file && defined('HHVM_VERSION')) {\n            $file = $this->findFileWithExtension($class, '.hh');\n        }\n\n        if (null !== $this->apcuPrefix) {\n            apcu_add($this->apcuPrefix.$class, $file);\n        }\n\n        if (false === $file) {\n            // Remember that this class does not exist.\n            $this->missingClasses[$class] = true;\n        }\n\n        return $file;\n    }\n\n    private function findFileWithExtension($class, $ext)\n    {\n        // PSR-4 lookup\n        $logicalPathPsr4 = strtr($class, '\\\\', DIRECTORY_SEPARATOR) . $ext;\n\n        $first = $class[0];\n        if (isset($this->prefixLengthsPsr4[$first])) {\n            $subPath = $class;\n            while (false !== $lastPos = strrpos($subPath, '\\\\')) {\n                $subPath = substr($subPath, 0, $lastPos);\n                $search = $subPath . '\\\\';\n                if (isset($this->prefixDirsPsr4[$search])) {\n                    $pathEnd = DIRECTORY_SEPARATOR . substr($logicalPathPsr4, $lastPos + 1);\n                    foreach ($this->prefixDirsPsr4[$search] as $dir) {\n                        if (file_exists($file = $dir . $pathEnd)) {\n                            return $file;\n                        }\n                    }\n                }\n            }\n        }\n\n        // PSR-4 fallback dirs\n        foreach ($this->fallbackDirsPsr4 as $dir) {\n            if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr4)) {\n                return $file;\n            }\n        }\n\n        // PSR-0 lookup\n        if (false !== $pos = strrpos($class, '\\\\')) {\n            // namespaced class name\n            $logicalPathPsr0 = substr($logicalPathPsr4, 0, $pos + 1)\n                . strtr(substr($logicalPathPsr4, $pos + 1), '_', DIRECTORY_SEPARATOR);\n        } else {\n            // PEAR-like class name\n            $logicalPathPsr0 = strtr($class, '_', DIRECTORY_SEPARATOR) . $ext;\n        }\n\n        if (isset($this->prefixesPsr0[$first])) {\n            foreach ($this->prefixesPsr0[$first] as $prefix => $dirs) {\n                if (0 === strpos($class, $prefix)) {\n                    foreach ($dirs as $dir) {\n                        if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {\n                            return $file;\n                        }\n                    }\n                }\n            }\n        }\n\n        // PSR-0 fallback dirs\n        foreach ($this->fallbackDirsPsr0 as $dir) {\n            if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {\n                return $file;\n            }\n        }\n\n        // PSR-0 include paths.\n        if ($this->useIncludePath && $file = stream_resolve_include_path($logicalPathPsr0)) {\n            return $file;\n        }\n\n        return false;\n    }\n}\n\n/**\n * Scope isolated include.\n *\n * Prevents access to $this/self from included files.\n */\nfunction includeFile($file)\n{\n    include $file;\n}\n",
  )
  php.writeFile(
    '/arena/vendor/composer/installed.json',
    '[\n    {\n        "name": "symfony/polyfill-mbstring",\n        "version": "v1.19.0",\n        "version_normalized": "1.19.0.0",\n        "source": {\n            "type": "git",\n            "url": "https://github.com/symfony/polyfill-mbstring.git",\n            "reference": "b5f7b932ee6fa802fc792eabd77c4c88084517ce"\n        },\n        "dist": {\n            "type": "zip",\n            "url": "https://api.github.com/repos/symfony/polyfill-mbstring/zipball/b5f7b932ee6fa802fc792eabd77c4c88084517ce",\n            "reference": "b5f7b932ee6fa802fc792eabd77c4c88084517ce",\n            "shasum": ""\n        },\n        "require": {\n            "php": ">=5.3.3"\n        },\n        "suggest": {\n            "ext-mbstring": "For best performance"\n        },\n        "time": "2020-10-23T09:01:57+00:00",\n        "type": "library",\n        "extra": {\n            "branch-alias": {\n                "dev-main": "1.19-dev"\n            },\n            "thanks": {\n                "name": "symfony/polyfill",\n                "url": "https://github.com/symfony/polyfill"\n            }\n        },\n        "installation-source": "dist",\n        "autoload": {\n            "files": [\n                "bootstrap.php"\n            ],\n            "psr-4": {\n                "Symfony\\\\Polyfill\\\\Mbstring\\\\": ""\n            }\n        },\n        "notification-url": "https://packagist.org/downloads/",\n        "license": [\n            "MIT"\n        ],\n        "authors": [\n            {\n                "name": "Nicolas Grekas",\n                "email": "p@tchwork.com"\n            },\n            {\n                "name": "Symfony Community",\n                "homepage": "https://symfony.com/contributors"\n            }\n        ],\n        "description": "Symfony polyfill for the Mbstring extension",\n        "homepage": "https://symfony.com",\n        "keywords": [\n            "compatibility",\n            "mbstring",\n            "polyfill",\n            "portable",\n            "shim"\n        ],\n        "funding": [\n            {\n                "url": "https://symfony.com/sponsor",\n                "type": "custom"\n            },\n            {\n                "url": "https://github.com/fabpot",\n                "type": "github"\n            },\n            {\n                "url": "https://tidelift.com/funding/github/packagist/symfony/symfony",\n                "type": "tidelift"\n            }\n        ]\n    },\n    {\n        "name": "symfony/var-dumper",\n        "version": "v3.4.47",\n        "version_normalized": "3.4.47.0",\n        "source": {\n            "type": "git",\n            "url": "https://github.com/symfony/var-dumper.git",\n            "reference": "0719f6cf4633a38b2c1585140998579ce23b4b7d"\n        },\n        "dist": {\n            "type": "zip",\n            "url": "https://api.github.com/repos/symfony/var-dumper/zipball/0719f6cf4633a38b2c1585140998579ce23b4b7d",\n            "reference": "0719f6cf4633a38b2c1585140998579ce23b4b7d",\n            "shasum": ""\n        },\n        "require": {\n            "php": "^5.5.9|>=7.0.8",\n            "symfony/polyfill-mbstring": "~1.0"\n        },\n        "conflict": {\n            "phpunit/phpunit": "<4.8.35|<5.4.3,>=5.0"\n        },\n        "require-dev": {\n            "ext-iconv": "*",\n            "twig/twig": "~1.34|~2.4"\n        },\n        "suggest": {\n            "ext-iconv": "To convert non-UTF-8 strings to UTF-8 (or symfony/polyfill-iconv in case ext-iconv cannot be used).",\n            "ext-intl": "To show region name in time zone dump",\n            "ext-symfony_debug": ""\n        },\n        "time": "2020-10-24T10:57:07+00:00",\n        "type": "library",\n        "installation-source": "dist",\n        "autoload": {\n            "files": [\n                "Resources/functions/dump.php"\n            ],\n            "psr-4": {\n                "Symfony\\\\Component\\\\VarDumper\\\\": ""\n            },\n            "exclude-from-classmap": [\n                "/Tests/"\n            ]\n        },\n        "notification-url": "https://packagist.org/downloads/",\n        "license": [\n            "MIT"\n        ],\n        "authors": [\n            {\n                "name": "Nicolas Grekas",\n                "email": "p@tchwork.com"\n            },\n            {\n                "name": "Symfony Community",\n                "homepage": "https://symfony.com/contributors"\n            }\n        ],\n        "description": "Symfony mechanism for exploring and dumping PHP variables",\n        "homepage": "https://symfony.com",\n        "keywords": [\n            "debug",\n            "dump"\n        ],\n        "funding": [\n            {\n                "url": "https://symfony.com/sponsor",\n                "type": "custom"\n            },\n            {\n                "url": "https://github.com/fabpot",\n                "type": "github"\n            },\n            {\n                "url": "https://tidelift.com/funding/github/packagist/symfony/symfony",\n                "type": "tidelift"\n            }\n        ]\n    }\n]\n',
  )
  php.writeFile(
    '/arena/vendor/composer/LICENSE',
    '\nCopyright (c) Nils Adermann, Jordi Boggiano\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/polyfill-mbstring/bootstrap.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nuse Symfony\\Polyfill\\Mbstring as p;\n\nif (!function_exists('mb_convert_encoding')) {\n    function mb_convert_encoding($string, $to_encoding, $from_encoding = null) { return p\\Mbstring::mb_convert_encoding($string, $to_encoding, $from_encoding); }\n}\nif (!function_exists('mb_decode_mimeheader')) {\n    function mb_decode_mimeheader($string) { return p\\Mbstring::mb_decode_mimeheader($string); }\n}\nif (!function_exists('mb_encode_mimeheader')) {\n    function mb_encode_mimeheader($string, $charset = null, $transfer_encoding = null, $newline = null, $indent = null) { return p\\Mbstring::mb_encode_mimeheader($string, $charset, $transfer_encoding, $newline, $indent); }\n}\nif (!function_exists('mb_decode_numericentity')) {\n    function mb_decode_numericentity($string, $map, $encoding = null) { return p\\Mbstring::mb_decode_numericentity($string, $map, $encoding); }\n}\nif (!function_exists('mb_encode_numericentity')) {\n    function mb_encode_numericentity($string, $map, $encoding = null, $hex = false) { return p\\Mbstring::mb_encode_numericentity($string, $map, $encoding, $hex); }\n}\nif (!function_exists('mb_convert_case')) {\n    function mb_convert_case($string, $mode, $encoding = null) { return p\\Mbstring::mb_convert_case($string, $mode, $encoding); }\n}\nif (!function_exists('mb_internal_encoding')) {\n    function mb_internal_encoding($encoding = null) { return p\\Mbstring::mb_internal_encoding($encoding); }\n}\nif (!function_exists('mb_language')) {\n    function mb_language($language = null) { return p\\Mbstring::mb_language($language); }\n}\nif (!function_exists('mb_list_encodings')) {\n    function mb_list_encodings() { return p\\Mbstring::mb_list_encodings(); }\n}\nif (!function_exists('mb_encoding_aliases')) {\n    function mb_encoding_aliases($encoding) { return p\\Mbstring::mb_encoding_aliases($encoding); }\n}\nif (!function_exists('mb_check_encoding')) {\n    function mb_check_encoding($value = null, $encoding = null) { return p\\Mbstring::mb_check_encoding($value, $encoding); }\n}\nif (!function_exists('mb_detect_encoding')) {\n    function mb_detect_encoding($string, $encodings = null, $strict = false) { return p\\Mbstring::mb_detect_encoding($string, $encodings, $strict); }\n}\nif (!function_exists('mb_detect_order')) {\n    function mb_detect_order($encoding = null) { return p\\Mbstring::mb_detect_order($encoding); }\n}\nif (!function_exists('mb_parse_str')) {\n    function mb_parse_str($string, &$result = array()) { parse_str($string, $result); }\n}\nif (!function_exists('mb_strlen')) {\n    function mb_strlen($string, $encoding = null) { return p\\Mbstring::mb_strlen($string, $encoding); }\n}\nif (!function_exists('mb_strpos')) {\n    function mb_strpos($haystack, $needle, $offset = 0, $encoding = null) { return p\\Mbstring::mb_strpos($haystack, $needle, $offset, $encoding); }\n}\nif (!function_exists('mb_strtolower')) {\n    function mb_strtolower($string, $encoding = null) { return p\\Mbstring::mb_strtolower($string, $encoding); }\n}\nif (!function_exists('mb_strtoupper')) {\n    function mb_strtoupper($string, $encoding = null) { return p\\Mbstring::mb_strtoupper($string, $encoding); }\n}\nif (!function_exists('mb_substitute_character')) {\n    function mb_substitute_character($substitute_character = null) { return p\\Mbstring::mb_substitute_character($substitute_character); }\n}\nif (!function_exists('mb_substr')) {\n    function mb_substr($string, $start, $length = 2147483647, $encoding = null) { return p\\Mbstring::mb_substr($string, $start, $length, $encoding); }\n}\nif (!function_exists('mb_stripos')) {\n    function mb_stripos($haystack, $needle, $offset = 0, $encoding = null) { return p\\Mbstring::mb_stripos($haystack, $needle, $offset, $encoding); }\n}\nif (!function_exists('mb_stristr')) {\n    function mb_stristr($haystack, $needle, $before_needle = false, $encoding = null) { return p\\Mbstring::mb_stristr($haystack, $needle, $before_needle, $encoding); }\n}\nif (!function_exists('mb_strrchr')) {\n    function mb_strrchr($haystack, $needle, $before_needle = false, $encoding = null) { return p\\Mbstring::mb_strrchr($haystack, $needle, $before_needle, $encoding); }\n}\nif (!function_exists('mb_strrichr')) {\n    function mb_strrichr($haystack, $needle, $before_needle = false, $encoding = null) { return p\\Mbstring::mb_strrichr($haystack, $needle, $before_needle, $encoding); }\n}\nif (!function_exists('mb_strripos')) {\n    function mb_strripos($haystack, $needle, $offset = 0, $encoding = null) { return p\\Mbstring::mb_strripos($haystack, $needle, $offset, $encoding); }\n}\nif (!function_exists('mb_strrpos')) {\n    function mb_strrpos($haystack, $needle, $offset = 0, $encoding = null) { return p\\Mbstring::mb_strrpos($haystack, $needle, $offset, $encoding); }\n}\nif (!function_exists('mb_strstr')) {\n    function mb_strstr($haystack, $needle, $before_needle = false, $encoding = null) { return p\\Mbstring::mb_strstr($haystack, $needle, $before_needle, $encoding); }\n}\nif (!function_exists('mb_get_info')) {\n    function mb_get_info($type = 'all') { return p\\Mbstring::mb_get_info($type); }\n}\nif (!function_exists('mb_http_output')) {\n    function mb_http_output($encoding = null) { return p\\Mbstring::mb_http_output($encoding); }\n}\nif (!function_exists('mb_strwidth')) {\n    function mb_strwidth($string, $encoding = null) { return p\\Mbstring::mb_strwidth($string, $encoding); }\n}\nif (!function_exists('mb_substr_count')) {\n    function mb_substr_count($haystack, $needle, $encoding = null) { return p\\Mbstring::mb_substr_count($haystack, $needle, $encoding); }\n}\nif (!function_exists('mb_output_handler')) {\n    function mb_output_handler($string, $status) { return p\\Mbstring::mb_output_handler($string, $status); }\n}\nif (!function_exists('mb_http_input')) {\n    function mb_http_input($type = '') { return p\\Mbstring::mb_http_input($type); }\n}\n\nif (PHP_VERSION_ID >= 80000) {\n    require_once __DIR__.'/Resources/mb_convert_variables.php8';\n} elseif (!function_exists('mb_convert_variables')) {\n    function mb_convert_variables($toEncoding, $fromEncoding, &$a = null, &$b = null, &$c = null, &$d = null, &$e = null, &$f = null) { return p\\Mbstring::mb_convert_variables($toEncoding, $fromEncoding, $a, $b, $c, $d, $e, $f); }\n}\n\nif (!function_exists('mb_ord')) {\n    function mb_ord($string, $encoding = null) { return p\\Mbstring::mb_ord($string, $encoding); }\n}\nif (!function_exists('mb_chr')) {\n    function mb_chr($codepoint, $encoding = null) { return p\\Mbstring::mb_chr($codepoint, $encoding); }\n}\nif (!function_exists('mb_scrub')) {\n    function mb_scrub($string, $encoding = null) { $encoding = null === $encoding ? mb_internal_encoding() : $encoding; return mb_convert_encoding($string, $encoding, $encoding); }\n}\nif (!function_exists('mb_str_split')) {\n    function mb_str_split($string, $length = 1, $encoding = null) { return p\\Mbstring::mb_str_split($string, $length, $encoding); }\n}\n\nif (extension_loaded('mbstring')) {\n    return;\n}\n\nif (!defined('MB_CASE_UPPER')) {\n    define('MB_CASE_UPPER', 0);\n}\nif (!defined('MB_CASE_LOWER')) {\n    define('MB_CASE_LOWER', 1);\n}\nif (!defined('MB_CASE_TITLE')) {\n    define('MB_CASE_TITLE', 2);\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/polyfill-mbstring/composer.json',
    '{\n    "name": "symfony/polyfill-mbstring",\n    "type": "library",\n    "description": "Symfony polyfill for the Mbstring extension",\n    "keywords": ["polyfill", "shim", "compatibility", "portable", "mbstring"],\n    "homepage": "https://symfony.com",\n    "license": "MIT",\n    "authors": [\n        {\n            "name": "Nicolas Grekas",\n            "email": "p@tchwork.com"\n        },\n        {\n            "name": "Symfony Community",\n            "homepage": "https://symfony.com/contributors"\n        }\n    ],\n    "require": {\n        "php": ">=5.3.3"\n    },\n    "autoload": {\n        "psr-4": { "Symfony\\\\Polyfill\\\\Mbstring\\\\": "" },\n        "files": [ "bootstrap.php" ]\n    },\n    "suggest": {\n        "ext-mbstring": "For best performance"\n    },\n    "minimum-stability": "dev",\n    "extra": {\n        "branch-alias": {\n            "dev-main": "1.19-dev"\n        },\n        "thanks": {\n            "name": "symfony/polyfill",\n            "url": "https://github.com/symfony/polyfill"\n        }\n    }\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/polyfill-mbstring/LICENSE',
    'Copyright (c) 2015-2019 Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/polyfill-mbstring/Mbstring.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Polyfill\\Mbstring;\n\n/**\n * Partial mbstring implementation in PHP, iconv based, UTF-8 centric.\n *\n * Implemented:\n * - mb_chr                  - Returns a specific character from its Unicode code point\n * - mb_convert_encoding     - Convert character encoding\n * - mb_convert_variables    - Convert character code in variable(s)\n * - mb_decode_mimeheader    - Decode string in MIME header field\n * - mb_encode_mimeheader    - Encode string for MIME header XXX NATIVE IMPLEMENTATION IS REALLY BUGGED\n * - mb_decode_numericentity - Decode HTML numeric string reference to character\n * - mb_encode_numericentity - Encode character to HTML numeric string reference\n * - mb_convert_case         - Perform case folding on a string\n * - mb_detect_encoding      - Detect character encoding\n * - mb_get_info             - Get internal settings of mbstring\n * - mb_http_input           - Detect HTTP input character encoding\n * - mb_http_output          - Set/Get HTTP output character encoding\n * - mb_internal_encoding    - Set/Get internal character encoding\n * - mb_list_encodings       - Returns an array of all supported encodings\n * - mb_ord                  - Returns the Unicode code point of a character\n * - mb_output_handler       - Callback function converts character encoding in output buffer\n * - mb_scrub                - Replaces ill-formed byte sequences with substitute characters\n * - mb_strlen               - Get string length\n * - mb_strpos               - Find position of first occurrence of string in a string\n * - mb_strrpos              - Find position of last occurrence of a string in a string\n * - mb_str_split            - Convert a string to an array\n * - mb_strtolower           - Make a string lowercase\n * - mb_strtoupper           - Make a string uppercase\n * - mb_substitute_character - Set/Get substitution character\n * - mb_substr               - Get part of string\n * - mb_stripos              - Finds position of first occurrence of a string within another, case insensitive\n * - mb_stristr              - Finds first occurrence of a string within another, case insensitive\n * - mb_strrchr              - Finds the last occurrence of a character in a string within another\n * - mb_strrichr             - Finds the last occurrence of a character in a string within another, case insensitive\n * - mb_strripos             - Finds position of last occurrence of a string within another, case insensitive\n * - mb_strstr               - Finds first occurrence of a string within another\n * - mb_strwidth             - Return width of string\n * - mb_substr_count         - Count the number of substring occurrences\n *\n * Not implemented:\n * - mb_convert_kana         - Convert \"kana\" one from another (\"zen-kaku\", \"han-kaku\" and more)\n * - mb_ereg_*               - Regular expression with multibyte support\n * - mb_parse_str            - Parse GET/POST/COOKIE data and set global variable\n * - mb_preferred_mime_name  - Get MIME charset string\n * - mb_regex_encoding       - Returns current encoding for multibyte regex as string\n * - mb_regex_set_options    - Set/Get the default options for mbregex functions\n * - mb_send_mail            - Send encoded mail\n * - mb_split                - Split multibyte string using regular expression\n * - mb_strcut               - Get part of string\n * - mb_strimwidth           - Get truncated string with specified width\n *\n * @author Nicolas Grekas <p@tchwork.com>\n *\n * @internal\n */\nfinal class Mbstring\n{\n    const MB_CASE_FOLD = PHP_INT_MAX;\n\n    private static $encodingList = array('ASCII', 'UTF-8');\n    private static $language = 'neutral';\n    private static $internalEncoding = 'UTF-8';\n    private static $caseFold = array(\n        array('µ', 'ſ', \"\\xCD\\x85\", 'ς', \"\\xCF\\x90\", \"\\xCF\\x91\", \"\\xCF\\x95\", \"\\xCF\\x96\", \"\\xCF\\xB0\", \"\\xCF\\xB1\", \"\\xCF\\xB5\", \"\\xE1\\xBA\\x9B\", \"\\xE1\\xBE\\xBE\"),\n        array('μ', 's', 'ι',        'σ', 'β',        'θ',        'φ',        'π',        'κ',        'ρ',        'ε',        \"\\xE1\\xB9\\xA1\", 'ι'),\n    );\n\n    public static function mb_convert_encoding($s, $toEncoding, $fromEncoding = null)\n    {\n        if (\\is_array($fromEncoding) || false !== strpos($fromEncoding, ',')) {\n            $fromEncoding = self::mb_detect_encoding($s, $fromEncoding);\n        } else {\n            $fromEncoding = self::getEncoding($fromEncoding);\n        }\n\n        $toEncoding = self::getEncoding($toEncoding);\n\n        if ('BASE64' === $fromEncoding) {\n            $s = base64_decode($s);\n            $fromEncoding = $toEncoding;\n        }\n\n        if ('BASE64' === $toEncoding) {\n            return base64_encode($s);\n        }\n\n        if ('HTML-ENTITIES' === $toEncoding || 'HTML' === $toEncoding) {\n            if ('HTML-ENTITIES' === $fromEncoding || 'HTML' === $fromEncoding) {\n                $fromEncoding = 'Windows-1252';\n            }\n            if ('UTF-8' !== $fromEncoding) {\n                $s = iconv($fromEncoding, 'UTF-8//IGNORE', $s);\n            }\n\n            return preg_replace_callback('/[\\x80-\\xFF]+/', array(__CLASS__, 'html_encoding_callback'), $s);\n        }\n\n        if ('HTML-ENTITIES' === $fromEncoding) {\n            $s = html_entity_decode($s, ENT_COMPAT, 'UTF-8');\n            $fromEncoding = 'UTF-8';\n        }\n\n        return iconv($fromEncoding, $toEncoding.'//IGNORE', $s);\n    }\n\n    public static function mb_convert_variables($toEncoding, $fromEncoding, &$a = null, &$b = null, &$c = null, &$d = null, &$e = null, &$f = null)\n    {\n        $vars = array(&$a, &$b, &$c, &$d, &$e, &$f);\n\n        $ok = true;\n        array_walk_recursive($vars, function (&$v) use (&$ok, $toEncoding, $fromEncoding) {\n            if (false === $v = Mbstring::mb_convert_encoding($v, $toEncoding, $fromEncoding)) {\n                $ok = false;\n            }\n        });\n\n        return $ok ? $fromEncoding : false;\n    }\n\n    public static function mb_decode_mimeheader($s)\n    {\n        return iconv_mime_decode($s, 2, self::$internalEncoding);\n    }\n\n    public static function mb_encode_mimeheader($s, $charset = null, $transferEncoding = null, $linefeed = null, $indent = null)\n    {\n        trigger_error('mb_encode_mimeheader() is bugged. Please use iconv_mime_encode() instead', E_USER_WARNING);\n    }\n\n    public static function mb_decode_numericentity($s, $convmap, $encoding = null)\n    {\n        if (null !== $s && !\\is_scalar($s) && !(\\is_object($s) && \\method_exists($s, '__toString'))) {\n            trigger_error('mb_decode_numericentity() expects parameter 1 to be string, '.\\gettype($s).' given', E_USER_WARNING);\n\n            return null;\n        }\n\n        if (!\\is_array($convmap) || !$convmap) {\n            return false;\n        }\n\n        if (null !== $encoding && !\\is_scalar($encoding)) {\n            trigger_error('mb_decode_numericentity() expects parameter 3 to be string, '.\\gettype($s).' given', E_USER_WARNING);\n\n            return '';  // Instead of null (cf. mb_encode_numericentity).\n        }\n\n        $s = (string) $s;\n        if ('' === $s) {\n            return '';\n        }\n\n        $encoding = self::getEncoding($encoding);\n\n        if ('UTF-8' === $encoding) {\n            $encoding = null;\n            if (!preg_match('//u', $s)) {\n                $s = @iconv('UTF-8', 'UTF-8//IGNORE', $s);\n            }\n        } else {\n            $s = iconv($encoding, 'UTF-8//IGNORE', $s);\n        }\n\n        $cnt = floor(\\count($convmap) / 4) * 4;\n\n        for ($i = 0; $i < $cnt; $i += 4) {\n            // collector_decode_htmlnumericentity ignores $convmap[$i + 3]\n            $convmap[$i] += $convmap[$i + 2];\n            $convmap[$i + 1] += $convmap[$i + 2];\n        }\n\n        $s = preg_replace_callback('/&#(?:0*([0-9]+)|x0*([0-9a-fA-F]+))(?!&);?/', function (array $m) use ($cnt, $convmap) {\n            $c = isset($m[2]) ? (int) hexdec($m[2]) : $m[1];\n            for ($i = 0; $i < $cnt; $i += 4) {\n                if ($c >= $convmap[$i] && $c <= $convmap[$i + 1]) {\n                    return Mbstring::mb_chr($c - $convmap[$i + 2]);\n                }\n            }\n\n            return $m[0];\n        }, $s);\n\n        if (null === $encoding) {\n            return $s;\n        }\n\n        return iconv('UTF-8', $encoding.'//IGNORE', $s);\n    }\n\n    public static function mb_encode_numericentity($s, $convmap, $encoding = null, $is_hex = false)\n    {\n        if (null !== $s && !\\is_scalar($s) && !(\\is_object($s) && \\method_exists($s, '__toString'))) {\n            trigger_error('mb_encode_numericentity() expects parameter 1 to be string, '.\\gettype($s).' given', E_USER_WARNING);\n\n            return null;\n        }\n\n        if (!\\is_array($convmap) || !$convmap) {\n            return false;\n        }\n\n        if (null !== $encoding && !\\is_scalar($encoding)) {\n            trigger_error('mb_encode_numericentity() expects parameter 3 to be string, '.\\gettype($s).' given', E_USER_WARNING);\n\n            return null;  // Instead of '' (cf. mb_decode_numericentity).\n        }\n\n        if (null !== $is_hex && !\\is_scalar($is_hex)) {\n            trigger_error('mb_encode_numericentity() expects parameter 4 to be boolean, '.\\gettype($s).' given', E_USER_WARNING);\n\n            return null;\n        }\n\n        $s = (string) $s;\n        if ('' === $s) {\n            return '';\n        }\n\n        $encoding = self::getEncoding($encoding);\n\n        if ('UTF-8' === $encoding) {\n            $encoding = null;\n            if (!preg_match('//u', $s)) {\n                $s = @iconv('UTF-8', 'UTF-8//IGNORE', $s);\n            }\n        } else {\n            $s = iconv($encoding, 'UTF-8//IGNORE', $s);\n        }\n\n        static $ulenMask = array(\"\\xC0\" => 2, \"\\xD0\" => 2, \"\\xE0\" => 3, \"\\xF0\" => 4);\n\n        $cnt = floor(\\count($convmap) / 4) * 4;\n        $i = 0;\n        $len = \\strlen($s);\n        $result = '';\n\n        while ($i < $len) {\n            $ulen = $s[$i] < \"\\x80\" ? 1 : $ulenMask[$s[$i] & \"\\xF0\"];\n            $uchr = substr($s, $i, $ulen);\n            $i += $ulen;\n            $c = self::mb_ord($uchr);\n\n            for ($j = 0; $j < $cnt; $j += 4) {\n                if ($c >= $convmap[$j] && $c <= $convmap[$j + 1]) {\n                    $cOffset = ($c + $convmap[$j + 2]) & $convmap[$j + 3];\n                    $result .= $is_hex ? sprintf('&#x%X;', $cOffset) : '&#'.$cOffset.';';\n                    continue 2;\n                }\n            }\n            $result .= $uchr;\n        }\n\n        if (null === $encoding) {\n            return $result;\n        }\n\n        return iconv('UTF-8', $encoding.'//IGNORE', $result);\n    }\n\n    public static function mb_convert_case($s, $mode, $encoding = null)\n    {\n        $s = (string) $s;\n        if ('' === $s) {\n            return '';\n        }\n\n        $encoding = self::getEncoding($encoding);\n\n        if ('UTF-8' === $encoding) {\n            $encoding = null;\n            if (!preg_match('//u', $s)) {\n                $s = @iconv('UTF-8', 'UTF-8//IGNORE', $s);\n            }\n        } else {\n            $s = iconv($encoding, 'UTF-8//IGNORE', $s);\n        }\n\n        if (MB_CASE_TITLE == $mode) {\n            static $titleRegexp = null;\n            if (null === $titleRegexp) {\n                $titleRegexp = self::getData('titleCaseRegexp');\n            }\n            $s = preg_replace_callback($titleRegexp, array(__CLASS__, 'title_case'), $s);\n        } else {\n            if (MB_CASE_UPPER == $mode) {\n                static $upper = null;\n                if (null === $upper) {\n                    $upper = self::getData('upperCase');\n                }\n                $map = $upper;\n            } else {\n                if (self::MB_CASE_FOLD === $mode) {\n                    $s = str_replace(self::$caseFold[0], self::$caseFold[1], $s);\n                }\n\n                static $lower = null;\n                if (null === $lower) {\n                    $lower = self::getData('lowerCase');\n                }\n                $map = $lower;\n            }\n\n            static $ulenMask = array(\"\\xC0\" => 2, \"\\xD0\" => 2, \"\\xE0\" => 3, \"\\xF0\" => 4);\n\n            $i = 0;\n            $len = \\strlen($s);\n\n            while ($i < $len) {\n                $ulen = $s[$i] < \"\\x80\" ? 1 : $ulenMask[$s[$i] & \"\\xF0\"];\n                $uchr = substr($s, $i, $ulen);\n                $i += $ulen;\n\n                if (isset($map[$uchr])) {\n                    $uchr = $map[$uchr];\n                    $nlen = \\strlen($uchr);\n\n                    if ($nlen == $ulen) {\n                        $nlen = $i;\n                        do {\n                            $s[--$nlen] = $uchr[--$ulen];\n                        } while ($ulen);\n                    } else {\n                        $s = substr_replace($s, $uchr, $i - $ulen, $ulen);\n                        $len += $nlen - $ulen;\n                        $i += $nlen - $ulen;\n                    }\n                }\n            }\n        }\n\n        if (null === $encoding) {\n            return $s;\n        }\n\n        return iconv('UTF-8', $encoding.'//IGNORE', $s);\n    }\n\n    public static function mb_internal_encoding($encoding = null)\n    {\n        if (null === $encoding) {\n            return self::$internalEncoding;\n        }\n\n        $encoding = self::getEncoding($encoding);\n\n        if ('UTF-8' === $encoding || false !== @iconv($encoding, $encoding, ' ')) {\n            self::$internalEncoding = $encoding;\n\n            return true;\n        }\n\n        return false;\n    }\n\n    public static function mb_language($lang = null)\n    {\n        if (null === $lang) {\n            return self::$language;\n        }\n\n        switch ($lang = strtolower($lang)) {\n            case 'uni':\n            case 'neutral':\n                self::$language = $lang;\n\n                return true;\n        }\n\n        return false;\n    }\n\n    public static function mb_list_encodings()\n    {\n        return array('UTF-8');\n    }\n\n    public static function mb_encoding_aliases($encoding)\n    {\n        switch (strtoupper($encoding)) {\n            case 'UTF8':\n            case 'UTF-8':\n                return array('utf8');\n        }\n\n        return false;\n    }\n\n    public static function mb_check_encoding($var = null, $encoding = null)\n    {\n        if (null === $encoding) {\n            if (null === $var) {\n                return false;\n            }\n            $encoding = self::$internalEncoding;\n        }\n\n        return self::mb_detect_encoding($var, array($encoding)) || false !== @iconv($encoding, $encoding, $var);\n    }\n\n    public static function mb_detect_encoding($str, $encodingList = null, $strict = false)\n    {\n        if (null === $encodingList) {\n            $encodingList = self::$encodingList;\n        } else {\n            if (!\\is_array($encodingList)) {\n                $encodingList = array_map('trim', explode(',', $encodingList));\n            }\n            $encodingList = array_map('strtoupper', $encodingList);\n        }\n\n        foreach ($encodingList as $enc) {\n            switch ($enc) {\n                case 'ASCII':\n                    if (!preg_match('/[\\x80-\\xFF]/', $str)) {\n                        return $enc;\n                    }\n                    break;\n\n                case 'UTF8':\n                case 'UTF-8':\n                    if (preg_match('//u', $str)) {\n                        return 'UTF-8';\n                    }\n                    break;\n\n                default:\n                    if (0 === strncmp($enc, 'ISO-8859-', 9)) {\n                        return $enc;\n                    }\n            }\n        }\n\n        return false;\n    }\n\n    public static function mb_detect_order($encodingList = null)\n    {\n        if (null === $encodingList) {\n            return self::$encodingList;\n        }\n\n        if (!\\is_array($encodingList)) {\n            $encodingList = array_map('trim', explode(',', $encodingList));\n        }\n        $encodingList = array_map('strtoupper', $encodingList);\n\n        foreach ($encodingList as $enc) {\n            switch ($enc) {\n                default:\n                    if (strncmp($enc, 'ISO-8859-', 9)) {\n                        return false;\n                    }\n                    // no break\n                case 'ASCII':\n                case 'UTF8':\n                case 'UTF-8':\n            }\n        }\n\n        self::$encodingList = $encodingList;\n\n        return true;\n    }\n\n    public static function mb_strlen($s, $encoding = null)\n    {\n        $encoding = self::getEncoding($encoding);\n        if ('CP850' === $encoding || 'ASCII' === $encoding) {\n            return \\strlen($s);\n        }\n\n        return @iconv_strlen($s, $encoding);\n    }\n\n    public static function mb_strpos($haystack, $needle, $offset = 0, $encoding = null)\n    {\n        $encoding = self::getEncoding($encoding);\n        if ('CP850' === $encoding || 'ASCII' === $encoding) {\n            return strpos($haystack, $needle, $offset);\n        }\n\n        $needle = (string) $needle;\n        if ('' === $needle) {\n            trigger_error(__METHOD__.': Empty delimiter', E_USER_WARNING);\n\n            return false;\n        }\n\n        return iconv_strpos($haystack, $needle, $offset, $encoding);\n    }\n\n    public static function mb_strrpos($haystack, $needle, $offset = 0, $encoding = null)\n    {\n        $encoding = self::getEncoding($encoding);\n        if ('CP850' === $encoding || 'ASCII' === $encoding) {\n            return strrpos($haystack, $needle, $offset);\n        }\n\n        if ($offset != (int) $offset) {\n            $offset = 0;\n        } elseif ($offset = (int) $offset) {\n            if ($offset < 0) {\n                if (0 > $offset += self::mb_strlen($needle)) {\n                    $haystack = self::mb_substr($haystack, 0, $offset, $encoding);\n                }\n                $offset = 0;\n            } else {\n                $haystack = self::mb_substr($haystack, $offset, 2147483647, $encoding);\n            }\n        }\n\n        $pos = iconv_strrpos($haystack, $needle, $encoding);\n\n        return false !== $pos ? $offset + $pos : false;\n    }\n\n    public static function mb_str_split($string, $split_length = 1, $encoding = null)\n    {\n        if (null !== $string && !\\is_scalar($string) && !(\\is_object($string) && \\method_exists($string, '__toString'))) {\n            trigger_error('mb_str_split() expects parameter 1 to be string, '.\\gettype($string).' given', E_USER_WARNING);\n\n            return null;\n        }\n\n        if (1 > $split_length = (int) $split_length) {\n            trigger_error('The length of each segment must be greater than zero', E_USER_WARNING);\n\n            return false;\n        }\n\n        if (null === $encoding) {\n            $encoding = mb_internal_encoding();\n        }\n\n        if ('UTF-8' === $encoding = self::getEncoding($encoding)) {\n            $rx = '/(';\n            while (65535 < $split_length) {\n                $rx .= '.{65535}';\n                $split_length -= 65535;\n            }\n            $rx .= '.{'.$split_length.'})/us';\n\n            return preg_split($rx, $string, null, PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY);\n        }\n\n        $result = array();\n        $length = mb_strlen($string, $encoding);\n\n        for ($i = 0; $i < $length; $i += $split_length) {\n            $result[] = mb_substr($string, $i, $split_length, $encoding);\n        }\n\n        return $result;\n    }\n\n    public static function mb_strtolower($s, $encoding = null)\n    {\n        return self::mb_convert_case($s, MB_CASE_LOWER, $encoding);\n    }\n\n    public static function mb_strtoupper($s, $encoding = null)\n    {\n        return self::mb_convert_case($s, MB_CASE_UPPER, $encoding);\n    }\n\n    public static function mb_substitute_character($c = null)\n    {\n        if (0 === strcasecmp($c, 'none')) {\n            return true;\n        }\n\n        return null !== $c ? false : 'none';\n    }\n\n    public static function mb_substr($s, $start, $length = null, $encoding = null)\n    {\n        $encoding = self::getEncoding($encoding);\n        if ('CP850' === $encoding || 'ASCII' === $encoding) {\n            return (string) substr($s, $start, null === $length ? 2147483647 : $length);\n        }\n\n        if ($start < 0) {\n            $start = iconv_strlen($s, $encoding) + $start;\n            if ($start < 0) {\n                $start = 0;\n            }\n        }\n\n        if (null === $length) {\n            $length = 2147483647;\n        } elseif ($length < 0) {\n            $length = iconv_strlen($s, $encoding) + $length - $start;\n            if ($length < 0) {\n                return '';\n            }\n        }\n\n        return (string) iconv_substr($s, $start, $length, $encoding);\n    }\n\n    public static function mb_stripos($haystack, $needle, $offset = 0, $encoding = null)\n    {\n        $haystack = self::mb_convert_case($haystack, self::MB_CASE_FOLD, $encoding);\n        $needle = self::mb_convert_case($needle, self::MB_CASE_FOLD, $encoding);\n\n        return self::mb_strpos($haystack, $needle, $offset, $encoding);\n    }\n\n    public static function mb_stristr($haystack, $needle, $part = false, $encoding = null)\n    {\n        $pos = self::mb_stripos($haystack, $needle, 0, $encoding);\n\n        return self::getSubpart($pos, $part, $haystack, $encoding);\n    }\n\n    public static function mb_strrchr($haystack, $needle, $part = false, $encoding = null)\n    {\n        $encoding = self::getEncoding($encoding);\n        if ('CP850' === $encoding || 'ASCII' === $encoding) {\n            $pos = strrpos($haystack, $needle);\n        } else {\n            $needle = self::mb_substr($needle, 0, 1, $encoding);\n            $pos = iconv_strrpos($haystack, $needle, $encoding);\n        }\n\n        return self::getSubpart($pos, $part, $haystack, $encoding);\n    }\n\n    public static function mb_strrichr($haystack, $needle, $part = false, $encoding = null)\n    {\n        $needle = self::mb_substr($needle, 0, 1, $encoding);\n        $pos = self::mb_strripos($haystack, $needle, $encoding);\n\n        return self::getSubpart($pos, $part, $haystack, $encoding);\n    }\n\n    public static function mb_strripos($haystack, $needle, $offset = 0, $encoding = null)\n    {\n        $haystack = self::mb_convert_case($haystack, self::MB_CASE_FOLD, $encoding);\n        $needle = self::mb_convert_case($needle, self::MB_CASE_FOLD, $encoding);\n\n        return self::mb_strrpos($haystack, $needle, $offset, $encoding);\n    }\n\n    public static function mb_strstr($haystack, $needle, $part = false, $encoding = null)\n    {\n        $pos = strpos($haystack, $needle);\n        if (false === $pos) {\n            return false;\n        }\n        if ($part) {\n            return substr($haystack, 0, $pos);\n        }\n\n        return substr($haystack, $pos);\n    }\n\n    public static function mb_get_info($type = 'all')\n    {\n        $info = array(\n            'internal_encoding' => self::$internalEncoding,\n            'http_output' => 'pass',\n            'http_output_conv_mimetypes' => '^(text/|application/xhtml\\+xml)',\n            'func_overload' => 0,\n            'func_overload_list' => 'no overload',\n            'mail_charset' => 'UTF-8',\n            'mail_header_encoding' => 'BASE64',\n            'mail_body_encoding' => 'BASE64',\n            'illegal_chars' => 0,\n            'encoding_translation' => 'Off',\n            'language' => self::$language,\n            'detect_order' => self::$encodingList,\n            'substitute_character' => 'none',\n            'strict_detection' => 'Off',\n        );\n\n        if ('all' === $type) {\n            return $info;\n        }\n        if (isset($info[$type])) {\n            return $info[$type];\n        }\n\n        return false;\n    }\n\n    public static function mb_http_input($type = '')\n    {\n        return false;\n    }\n\n    public static function mb_http_output($encoding = null)\n    {\n        return null !== $encoding ? 'pass' === $encoding : 'pass';\n    }\n\n    public static function mb_strwidth($s, $encoding = null)\n    {\n        $encoding = self::getEncoding($encoding);\n\n        if ('UTF-8' !== $encoding) {\n            $s = iconv($encoding, 'UTF-8//IGNORE', $s);\n        }\n\n        $s = preg_replace('/[\\x{1100}-\\x{115F}\\x{2329}\\x{232A}\\x{2E80}-\\x{303E}\\x{3040}-\\x{A4CF}\\x{AC00}-\\x{D7A3}\\x{F900}-\\x{FAFF}\\x{FE10}-\\x{FE19}\\x{FE30}-\\x{FE6F}\\x{FF00}-\\x{FF60}\\x{FFE0}-\\x{FFE6}\\x{20000}-\\x{2FFFD}\\x{30000}-\\x{3FFFD}]/u', '', $s, -1, $wide);\n\n        return ($wide << 1) + iconv_strlen($s, 'UTF-8');\n    }\n\n    public static function mb_substr_count($haystack, $needle, $encoding = null)\n    {\n        return substr_count($haystack, $needle);\n    }\n\n    public static function mb_output_handler($contents, $status)\n    {\n        return $contents;\n    }\n\n    public static function mb_chr($code, $encoding = null)\n    {\n        if (0x80 > $code %= 0x200000) {\n            $s = \\chr($code);\n        } elseif (0x800 > $code) {\n            $s = \\chr(0xC0 | $code >> 6).\\chr(0x80 | $code & 0x3F);\n        } elseif (0x10000 > $code) {\n            $s = \\chr(0xE0 | $code >> 12).\\chr(0x80 | $code >> 6 & 0x3F).\\chr(0x80 | $code & 0x3F);\n        } else {\n            $s = \\chr(0xF0 | $code >> 18).\\chr(0x80 | $code >> 12 & 0x3F).\\chr(0x80 | $code >> 6 & 0x3F).\\chr(0x80 | $code & 0x3F);\n        }\n\n        if ('UTF-8' !== $encoding = self::getEncoding($encoding)) {\n            $s = mb_convert_encoding($s, $encoding, 'UTF-8');\n        }\n\n        return $s;\n    }\n\n    public static function mb_ord($s, $encoding = null)\n    {\n        if ('UTF-8' !== $encoding = self::getEncoding($encoding)) {\n            $s = mb_convert_encoding($s, 'UTF-8', $encoding);\n        }\n\n        if (1 === \\strlen($s)) {\n            return \\ord($s);\n        }\n\n        $code = ($s = unpack('C*', substr($s, 0, 4))) ? $s[1] : 0;\n        if (0xF0 <= $code) {\n            return (($code - 0xF0) << 18) + (($s[2] - 0x80) << 12) + (($s[3] - 0x80) << 6) + $s[4] - 0x80;\n        }\n        if (0xE0 <= $code) {\n            return (($code - 0xE0) << 12) + (($s[2] - 0x80) << 6) + $s[3] - 0x80;\n        }\n        if (0xC0 <= $code) {\n            return (($code - 0xC0) << 6) + $s[2] - 0x80;\n        }\n\n        return $code;\n    }\n\n    private static function getSubpart($pos, $part, $haystack, $encoding)\n    {\n        if (false === $pos) {\n            return false;\n        }\n        if ($part) {\n            return self::mb_substr($haystack, 0, $pos, $encoding);\n        }\n\n        return self::mb_substr($haystack, $pos, null, $encoding);\n    }\n\n    private static function html_encoding_callback(array $m)\n    {\n        $i = 1;\n        $entities = '';\n        $m = unpack('C*', htmlentities($m[0], ENT_COMPAT, 'UTF-8'));\n\n        while (isset($m[$i])) {\n            if (0x80 > $m[$i]) {\n                $entities .= \\chr($m[$i++]);\n                continue;\n            }\n            if (0xF0 <= $m[$i]) {\n                $c = (($m[$i++] - 0xF0) << 18) + (($m[$i++] - 0x80) << 12) + (($m[$i++] - 0x80) << 6) + $m[$i++] - 0x80;\n            } elseif (0xE0 <= $m[$i]) {\n                $c = (($m[$i++] - 0xE0) << 12) + (($m[$i++] - 0x80) << 6) + $m[$i++] - 0x80;\n            } else {\n                $c = (($m[$i++] - 0xC0) << 6) + $m[$i++] - 0x80;\n            }\n\n            $entities .= '&#'.$c.';';\n        }\n\n        return $entities;\n    }\n\n    private static function title_case(array $s)\n    {\n        return self::mb_convert_case($s[1], MB_CASE_UPPER, 'UTF-8').self::mb_convert_case($s[2], MB_CASE_LOWER, 'UTF-8');\n    }\n\n    private static function getData($file)\n    {\n        if (file_exists($file = __DIR__.'/Resources/unidata/'.$file.'.php')) {\n            return require $file;\n        }\n\n        return false;\n    }\n\n    private static function getEncoding($encoding)\n    {\n        if (null === $encoding) {\n            return self::$internalEncoding;\n        }\n\n        if ('UTF-8' === $encoding) {\n            return 'UTF-8';\n        }\n\n        $encoding = strtoupper($encoding);\n\n        if ('8BIT' === $encoding || 'BINARY' === $encoding) {\n            return 'CP850';\n        }\n\n        if ('UTF8' === $encoding) {\n            return 'UTF-8';\n        }\n\n        return $encoding;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/polyfill-mbstring/README.md',
    'Symfony Polyfill / Mbstring\n===========================\n\nThis component provides a partial, native PHP implementation for the\n[Mbstring](https://php.net/mbstring) extension.\n\nMore information can be found in the\n[main Polyfill README](https://github.com/symfony/polyfill/blob/master/README.md).\n\nLicense\n=======\n\nThis library is released under the [MIT license](LICENSE).\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/polyfill-mbstring/Resources/mb_convert_variables.php8',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nuse Symfony\\Polyfill\\Mbstring as p;\n\nif (!function_exists('mb_convert_variables')) {\n    /**\n     * Convert character code in variable(s)\n     */\n    function mb_convert_variables($to_encoding, $from_encoding, &$var, &...$vars)\n    {\n        $vars = [&$var, ...$vars];\n\n        $ok = true;\n        array_walk_recursive($vars, function (&$v) use (&$ok, $to_encoding, $from_encoding) {\n            if (false === $v = p\\Mbstring::mb_convert_encoding($v, $to_encoding, $from_encoding)) {\n                $ok = false;\n            }\n        });\n\n        return $ok ? $from_encoding : false;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/polyfill-mbstring/Resources/unidata/lowerCase.php',
    "<?php\n\nreturn array (\n  'A' => 'a',\n  'B' => 'b',\n  'C' => 'c',\n  'D' => 'd',\n  'E' => 'e',\n  'F' => 'f',\n  'G' => 'g',\n  'H' => 'h',\n  'I' => 'i',\n  'J' => 'j',\n  'K' => 'k',\n  'L' => 'l',\n  'M' => 'm',\n  'N' => 'n',\n  'O' => 'o',\n  'P' => 'p',\n  'Q' => 'q',\n  'R' => 'r',\n  'S' => 's',\n  'T' => 't',\n  'U' => 'u',\n  'V' => 'v',\n  'W' => 'w',\n  'X' => 'x',\n  'Y' => 'y',\n  'Z' => 'z',\n  'À' => 'à',\n  'Á' => 'á',\n  'Â' => 'â',\n  'Ã' => 'ã',\n  'Ä' => 'ä',\n  'Å' => 'å',\n  'Æ' => 'æ',\n  'Ç' => 'ç',\n  'È' => 'è',\n  'É' => 'é',\n  'Ê' => 'ê',\n  'Ë' => 'ë',\n  'Ì' => 'ì',\n  'Í' => 'í',\n  'Î' => 'î',\n  'Ï' => 'ï',\n  'Ð' => 'ð',\n  'Ñ' => 'ñ',\n  'Ò' => 'ò',\n  'Ó' => 'ó',\n  'Ô' => 'ô',\n  'Õ' => 'õ',\n  'Ö' => 'ö',\n  'Ø' => 'ø',\n  'Ù' => 'ù',\n  'Ú' => 'ú',\n  'Û' => 'û',\n  'Ü' => 'ü',\n  'Ý' => 'ý',\n  'Þ' => 'þ',\n  'Ā' => 'ā',\n  'Ă' => 'ă',\n  'Ą' => 'ą',\n  'Ć' => 'ć',\n  'Ĉ' => 'ĉ',\n  'Ċ' => 'ċ',\n  'Č' => 'č',\n  'Ď' => 'ď',\n  'Đ' => 'đ',\n  'Ē' => 'ē',\n  'Ĕ' => 'ĕ',\n  'Ė' => 'ė',\n  'Ę' => 'ę',\n  'Ě' => 'ě',\n  'Ĝ' => 'ĝ',\n  'Ğ' => 'ğ',\n  'Ġ' => 'ġ',\n  'Ģ' => 'ģ',\n  'Ĥ' => 'ĥ',\n  'Ħ' => 'ħ',\n  'Ĩ' => 'ĩ',\n  'Ī' => 'ī',\n  'Ĭ' => 'ĭ',\n  'Į' => 'į',\n  'İ' => 'i',\n  'Ĳ' => 'ĳ',\n  'Ĵ' => 'ĵ',\n  'Ķ' => 'ķ',\n  'Ĺ' => 'ĺ',\n  'Ļ' => 'ļ',\n  'Ľ' => 'ľ',\n  'Ŀ' => 'ŀ',\n  'Ł' => 'ł',\n  'Ń' => 'ń',\n  'Ņ' => 'ņ',\n  'Ň' => 'ň',\n  'Ŋ' => 'ŋ',\n  'Ō' => 'ō',\n  'Ŏ' => 'ŏ',\n  'Ő' => 'ő',\n  'Œ' => 'œ',\n  'Ŕ' => 'ŕ',\n  'Ŗ' => 'ŗ',\n  'Ř' => 'ř',\n  'Ś' => 'ś',\n  'Ŝ' => 'ŝ',\n  'Ş' => 'ş',\n  'Š' => 'š',\n  'Ţ' => 'ţ',\n  'Ť' => 'ť',\n  'Ŧ' => 'ŧ',\n  'Ũ' => 'ũ',\n  'Ū' => 'ū',\n  'Ŭ' => 'ŭ',\n  'Ů' => 'ů',\n  'Ű' => 'ű',\n  'Ų' => 'ų',\n  'Ŵ' => 'ŵ',\n  'Ŷ' => 'ŷ',\n  'Ÿ' => 'ÿ',\n  'Ź' => 'ź',\n  'Ż' => 'ż',\n  'Ž' => 'ž',\n  'Ɓ' => 'ɓ',\n  'Ƃ' => 'ƃ',\n  'Ƅ' => 'ƅ',\n  'Ɔ' => 'ɔ',\n  'Ƈ' => 'ƈ',\n  'Ɖ' => 'ɖ',\n  'Ɗ' => 'ɗ',\n  'Ƌ' => 'ƌ',\n  'Ǝ' => 'ǝ',\n  'Ə' => 'ə',\n  'Ɛ' => 'ɛ',\n  'Ƒ' => 'ƒ',\n  'Ɠ' => 'ɠ',\n  'Ɣ' => 'ɣ',\n  'Ɩ' => 'ɩ',\n  'Ɨ' => 'ɨ',\n  'Ƙ' => 'ƙ',\n  'Ɯ' => 'ɯ',\n  'Ɲ' => 'ɲ',\n  'Ɵ' => 'ɵ',\n  'Ơ' => 'ơ',\n  'Ƣ' => 'ƣ',\n  'Ƥ' => 'ƥ',\n  'Ʀ' => 'ʀ',\n  'Ƨ' => 'ƨ',\n  'Ʃ' => 'ʃ',\n  'Ƭ' => 'ƭ',\n  'Ʈ' => 'ʈ',\n  'Ư' => 'ư',\n  'Ʊ' => 'ʊ',\n  'Ʋ' => 'ʋ',\n  'Ƴ' => 'ƴ',\n  'Ƶ' => 'ƶ',\n  'Ʒ' => 'ʒ',\n  'Ƹ' => 'ƹ',\n  'Ƽ' => 'ƽ',\n  'Ǆ' => 'ǆ',\n  'ǅ' => 'ǆ',\n  'Ǉ' => 'ǉ',\n  'ǈ' => 'ǉ',\n  'Ǌ' => 'ǌ',\n  'ǋ' => 'ǌ',\n  'Ǎ' => 'ǎ',\n  'Ǐ' => 'ǐ',\n  'Ǒ' => 'ǒ',\n  'Ǔ' => 'ǔ',\n  'Ǖ' => 'ǖ',\n  'Ǘ' => 'ǘ',\n  'Ǚ' => 'ǚ',\n  'Ǜ' => 'ǜ',\n  'Ǟ' => 'ǟ',\n  'Ǡ' => 'ǡ',\n  'Ǣ' => 'ǣ',\n  'Ǥ' => 'ǥ',\n  'Ǧ' => 'ǧ',\n  'Ǩ' => 'ǩ',\n  'Ǫ' => 'ǫ',\n  'Ǭ' => 'ǭ',\n  'Ǯ' => 'ǯ',\n  'Ǳ' => 'ǳ',\n  'ǲ' => 'ǳ',\n  'Ǵ' => 'ǵ',\n  'Ƕ' => 'ƕ',\n  'Ƿ' => 'ƿ',\n  'Ǹ' => 'ǹ',\n  'Ǻ' => 'ǻ',\n  'Ǽ' => 'ǽ',\n  'Ǿ' => 'ǿ',\n  'Ȁ' => 'ȁ',\n  'Ȃ' => 'ȃ',\n  'Ȅ' => 'ȅ',\n  'Ȇ' => 'ȇ',\n  'Ȉ' => 'ȉ',\n  'Ȋ' => 'ȋ',\n  'Ȍ' => 'ȍ',\n  'Ȏ' => 'ȏ',\n  'Ȑ' => 'ȑ',\n  'Ȓ' => 'ȓ',\n  'Ȕ' => 'ȕ',\n  'Ȗ' => 'ȗ',\n  'Ș' => 'ș',\n  'Ț' => 'ț',\n  'Ȝ' => 'ȝ',\n  'Ȟ' => 'ȟ',\n  'Ƞ' => 'ƞ',\n  'Ȣ' => 'ȣ',\n  'Ȥ' => 'ȥ',\n  'Ȧ' => 'ȧ',\n  'Ȩ' => 'ȩ',\n  'Ȫ' => 'ȫ',\n  'Ȭ' => 'ȭ',\n  'Ȯ' => 'ȯ',\n  'Ȱ' => 'ȱ',\n  'Ȳ' => 'ȳ',\n  'Ⱥ' => 'ⱥ',\n  'Ȼ' => 'ȼ',\n  'Ƚ' => 'ƚ',\n  'Ⱦ' => 'ⱦ',\n  'Ɂ' => 'ɂ',\n  'Ƀ' => 'ƀ',\n  'Ʉ' => 'ʉ',\n  'Ʌ' => 'ʌ',\n  'Ɇ' => 'ɇ',\n  'Ɉ' => 'ɉ',\n  'Ɋ' => 'ɋ',\n  'Ɍ' => 'ɍ',\n  'Ɏ' => 'ɏ',\n  'Ͱ' => 'ͱ',\n  'Ͳ' => 'ͳ',\n  'Ͷ' => 'ͷ',\n  'Ϳ' => 'ϳ',\n  'Ά' => 'ά',\n  'Έ' => 'έ',\n  'Ή' => 'ή',\n  'Ί' => 'ί',\n  'Ό' => 'ό',\n  'Ύ' => 'ύ',\n  'Ώ' => 'ώ',\n  'Α' => 'α',\n  'Β' => 'β',\n  'Γ' => 'γ',\n  'Δ' => 'δ',\n  'Ε' => 'ε',\n  'Ζ' => 'ζ',\n  'Η' => 'η',\n  'Θ' => 'θ',\n  'Ι' => 'ι',\n  'Κ' => 'κ',\n  'Λ' => 'λ',\n  'Μ' => 'μ',\n  'Ν' => 'ν',\n  'Ξ' => 'ξ',\n  'Ο' => 'ο',\n  'Π' => 'π',\n  'Ρ' => 'ρ',\n  'Σ' => 'σ',\n  'Τ' => 'τ',\n  'Υ' => 'υ',\n  'Φ' => 'φ',\n  'Χ' => 'χ',\n  'Ψ' => 'ψ',\n  'Ω' => 'ω',\n  'Ϊ' => 'ϊ',\n  'Ϋ' => 'ϋ',\n  'Ϗ' => 'ϗ',\n  'Ϙ' => 'ϙ',\n  'Ϛ' => 'ϛ',\n  'Ϝ' => 'ϝ',\n  'Ϟ' => 'ϟ',\n  'Ϡ' => 'ϡ',\n  'Ϣ' => 'ϣ',\n  'Ϥ' => 'ϥ',\n  'Ϧ' => 'ϧ',\n  'Ϩ' => 'ϩ',\n  'Ϫ' => 'ϫ',\n  'Ϭ' => 'ϭ',\n  'Ϯ' => 'ϯ',\n  'ϴ' => 'θ',\n  'Ϸ' => 'ϸ',\n  'Ϲ' => 'ϲ',\n  'Ϻ' => 'ϻ',\n  'Ͻ' => 'ͻ',\n  'Ͼ' => 'ͼ',\n  'Ͽ' => 'ͽ',\n  'Ѐ' => 'ѐ',\n  'Ё' => 'ё',\n  'Ђ' => 'ђ',\n  'Ѓ' => 'ѓ',\n  'Є' => 'є',\n  'Ѕ' => 'ѕ',\n  'І' => 'і',\n  'Ї' => 'ї',\n  'Ј' => 'ј',\n  'Љ' => 'љ',\n  'Њ' => 'њ',\n  'Ћ' => 'ћ',\n  'Ќ' => 'ќ',\n  'Ѝ' => 'ѝ',\n  'Ў' => 'ў',\n  'Џ' => 'џ',\n  'А' => 'а',\n  'Б' => 'б',\n  'В' => 'в',\n  'Г' => 'г',\n  'Д' => 'д',\n  'Е' => 'е',\n  'Ж' => 'ж',\n  'З' => 'з',\n  'И' => 'и',\n  'Й' => 'й',\n  'К' => 'к',\n  'Л' => 'л',\n  'М' => 'м',\n  'Н' => 'н',\n  'О' => 'о',\n  'П' => 'п',\n  'Р' => 'р',\n  'С' => 'с',\n  'Т' => 'т',\n  'У' => 'у',\n  'Ф' => 'ф',\n  'Х' => 'х',\n  'Ц' => 'ц',\n  'Ч' => 'ч',\n  'Ш' => 'ш',\n  'Щ' => 'щ',\n  'Ъ' => 'ъ',\n  'Ы' => 'ы',\n  'Ь' => 'ь',\n  'Э' => 'э',\n  'Ю' => 'ю',\n  'Я' => 'я',\n  'Ѡ' => 'ѡ',\n  'Ѣ' => 'ѣ',\n  'Ѥ' => 'ѥ',\n  'Ѧ' => 'ѧ',\n  'Ѩ' => 'ѩ',\n  'Ѫ' => 'ѫ',\n  'Ѭ' => 'ѭ',\n  'Ѯ' => 'ѯ',\n  'Ѱ' => 'ѱ',\n  'Ѳ' => 'ѳ',\n  'Ѵ' => 'ѵ',\n  'Ѷ' => 'ѷ',\n  'Ѹ' => 'ѹ',\n  'Ѻ' => 'ѻ',\n  'Ѽ' => 'ѽ',\n  'Ѿ' => 'ѿ',\n  'Ҁ' => 'ҁ',\n  'Ҋ' => 'ҋ',\n  'Ҍ' => 'ҍ',\n  'Ҏ' => 'ҏ',\n  'Ґ' => 'ґ',\n  'Ғ' => 'ғ',\n  'Ҕ' => 'ҕ',\n  'Җ' => 'җ',\n  'Ҙ' => 'ҙ',\n  'Қ' => 'қ',\n  'Ҝ' => 'ҝ',\n  'Ҟ' => 'ҟ',\n  'Ҡ' => 'ҡ',\n  'Ң' => 'ң',\n  'Ҥ' => 'ҥ',\n  'Ҧ' => 'ҧ',\n  'Ҩ' => 'ҩ',\n  'Ҫ' => 'ҫ',\n  'Ҭ' => 'ҭ',\n  'Ү' => 'ү',\n  'Ұ' => 'ұ',\n  'Ҳ' => 'ҳ',\n  'Ҵ' => 'ҵ',\n  'Ҷ' => 'ҷ',\n  'Ҹ' => 'ҹ',\n  'Һ' => 'һ',\n  'Ҽ' => 'ҽ',\n  'Ҿ' => 'ҿ',\n  'Ӏ' => 'ӏ',\n  'Ӂ' => 'ӂ',\n  'Ӄ' => 'ӄ',\n  'Ӆ' => 'ӆ',\n  'Ӈ' => 'ӈ',\n  'Ӊ' => 'ӊ',\n  'Ӌ' => 'ӌ',\n  'Ӎ' => 'ӎ',\n  'Ӑ' => 'ӑ',\n  'Ӓ' => 'ӓ',\n  'Ӕ' => 'ӕ',\n  'Ӗ' => 'ӗ',\n  'Ә' => 'ә',\n  'Ӛ' => 'ӛ',\n  'Ӝ' => 'ӝ',\n  'Ӟ' => 'ӟ',\n  'Ӡ' => 'ӡ',\n  'Ӣ' => 'ӣ',\n  'Ӥ' => 'ӥ',\n  'Ӧ' => 'ӧ',\n  'Ө' => 'ө',\n  'Ӫ' => 'ӫ',\n  'Ӭ' => 'ӭ',\n  'Ӯ' => 'ӯ',\n  'Ӱ' => 'ӱ',\n  'Ӳ' => 'ӳ',\n  'Ӵ' => 'ӵ',\n  'Ӷ' => 'ӷ',\n  'Ӹ' => 'ӹ',\n  'Ӻ' => 'ӻ',\n  'Ӽ' => 'ӽ',\n  'Ӿ' => 'ӿ',\n  'Ԁ' => 'ԁ',\n  'Ԃ' => 'ԃ',\n  'Ԅ' => 'ԅ',\n  'Ԇ' => 'ԇ',\n  'Ԉ' => 'ԉ',\n  'Ԋ' => 'ԋ',\n  'Ԍ' => 'ԍ',\n  'Ԏ' => 'ԏ',\n  'Ԑ' => 'ԑ',\n  'Ԓ' => 'ԓ',\n  'Ԕ' => 'ԕ',\n  'Ԗ' => 'ԗ',\n  'Ԙ' => 'ԙ',\n  'Ԛ' => 'ԛ',\n  'Ԝ' => 'ԝ',\n  'Ԟ' => 'ԟ',\n  'Ԡ' => 'ԡ',\n  'Ԣ' => 'ԣ',\n  'Ԥ' => 'ԥ',\n  'Ԧ' => 'ԧ',\n  'Ԩ' => 'ԩ',\n  'Ԫ' => 'ԫ',\n  'Ԭ' => 'ԭ',\n  'Ԯ' => 'ԯ',\n  'Ա' => 'ա',\n  'Բ' => 'բ',\n  'Գ' => 'գ',\n  'Դ' => 'դ',\n  'Ե' => 'ե',\n  'Զ' => 'զ',\n  'Է' => 'է',\n  'Ը' => 'ը',\n  'Թ' => 'թ',\n  'Ժ' => 'ժ',\n  'Ի' => 'ի',\n  'Լ' => 'լ',\n  'Խ' => 'խ',\n  'Ծ' => 'ծ',\n  'Կ' => 'կ',\n  'Հ' => 'հ',\n  'Ձ' => 'ձ',\n  'Ղ' => 'ղ',\n  'Ճ' => 'ճ',\n  'Մ' => 'մ',\n  'Յ' => 'յ',\n  'Ն' => 'ն',\n  'Շ' => 'շ',\n  'Ո' => 'ո',\n  'Չ' => 'չ',\n  'Պ' => 'պ',\n  'Ջ' => 'ջ',\n  'Ռ' => 'ռ',\n  'Ս' => 'ս',\n  'Վ' => 'վ',\n  'Տ' => 'տ',\n  'Ր' => 'ր',\n  'Ց' => 'ց',\n  'Ւ' => 'ւ',\n  'Փ' => 'փ',\n  'Ք' => 'ք',\n  'Օ' => 'օ',\n  'Ֆ' => 'ֆ',\n  'Ⴀ' => 'ⴀ',\n  'Ⴁ' => 'ⴁ',\n  'Ⴂ' => 'ⴂ',\n  'Ⴃ' => 'ⴃ',\n  'Ⴄ' => 'ⴄ',\n  'Ⴅ' => 'ⴅ',\n  'Ⴆ' => 'ⴆ',\n  'Ⴇ' => 'ⴇ',\n  'Ⴈ' => 'ⴈ',\n  'Ⴉ' => 'ⴉ',\n  'Ⴊ' => 'ⴊ',\n  'Ⴋ' => 'ⴋ',\n  'Ⴌ' => 'ⴌ',\n  'Ⴍ' => 'ⴍ',\n  'Ⴎ' => 'ⴎ',\n  'Ⴏ' => 'ⴏ',\n  'Ⴐ' => 'ⴐ',\n  'Ⴑ' => 'ⴑ',\n  'Ⴒ' => 'ⴒ',\n  'Ⴓ' => 'ⴓ',\n  'Ⴔ' => 'ⴔ',\n  'Ⴕ' => 'ⴕ',\n  'Ⴖ' => 'ⴖ',\n  'Ⴗ' => 'ⴗ',\n  'Ⴘ' => 'ⴘ',\n  'Ⴙ' => 'ⴙ',\n  'Ⴚ' => 'ⴚ',\n  'Ⴛ' => 'ⴛ',\n  'Ⴜ' => 'ⴜ',\n  'Ⴝ' => 'ⴝ',\n  'Ⴞ' => 'ⴞ',\n  'Ⴟ' => 'ⴟ',\n  'Ⴠ' => 'ⴠ',\n  'Ⴡ' => 'ⴡ',\n  'Ⴢ' => 'ⴢ',\n  'Ⴣ' => 'ⴣ',\n  'Ⴤ' => 'ⴤ',\n  'Ⴥ' => 'ⴥ',\n  'Ⴧ' => 'ⴧ',\n  'Ⴭ' => 'ⴭ',\n  'Ꭰ' => 'ꭰ',\n  'Ꭱ' => 'ꭱ',\n  'Ꭲ' => 'ꭲ',\n  'Ꭳ' => 'ꭳ',\n  'Ꭴ' => 'ꭴ',\n  'Ꭵ' => 'ꭵ',\n  'Ꭶ' => 'ꭶ',\n  'Ꭷ' => 'ꭷ',\n  'Ꭸ' => 'ꭸ',\n  'Ꭹ' => 'ꭹ',\n  'Ꭺ' => 'ꭺ',\n  'Ꭻ' => 'ꭻ',\n  'Ꭼ' => 'ꭼ',\n  'Ꭽ' => 'ꭽ',\n  'Ꭾ' => 'ꭾ',\n  'Ꭿ' => 'ꭿ',\n  'Ꮀ' => 'ꮀ',\n  'Ꮁ' => 'ꮁ',\n  'Ꮂ' => 'ꮂ',\n  'Ꮃ' => 'ꮃ',\n  'Ꮄ' => 'ꮄ',\n  'Ꮅ' => 'ꮅ',\n  'Ꮆ' => 'ꮆ',\n  'Ꮇ' => 'ꮇ',\n  'Ꮈ' => 'ꮈ',\n  'Ꮉ' => 'ꮉ',\n  'Ꮊ' => 'ꮊ',\n  'Ꮋ' => 'ꮋ',\n  'Ꮌ' => 'ꮌ',\n  'Ꮍ' => 'ꮍ',\n  'Ꮎ' => 'ꮎ',\n  'Ꮏ' => 'ꮏ',\n  'Ꮐ' => 'ꮐ',\n  'Ꮑ' => 'ꮑ',\n  'Ꮒ' => 'ꮒ',\n  'Ꮓ' => 'ꮓ',\n  'Ꮔ' => 'ꮔ',\n  'Ꮕ' => 'ꮕ',\n  'Ꮖ' => 'ꮖ',\n  'Ꮗ' => 'ꮗ',\n  'Ꮘ' => 'ꮘ',\n  'Ꮙ' => 'ꮙ',\n  'Ꮚ' => 'ꮚ',\n  'Ꮛ' => 'ꮛ',\n  'Ꮜ' => 'ꮜ',\n  'Ꮝ' => 'ꮝ',\n  'Ꮞ' => 'ꮞ',\n  'Ꮟ' => 'ꮟ',\n  'Ꮠ' => 'ꮠ',\n  'Ꮡ' => 'ꮡ',\n  'Ꮢ' => 'ꮢ',\n  'Ꮣ' => 'ꮣ',\n  'Ꮤ' => 'ꮤ',\n  'Ꮥ' => 'ꮥ',\n  'Ꮦ' => 'ꮦ',\n  'Ꮧ' => 'ꮧ',\n  'Ꮨ' => 'ꮨ',\n  'Ꮩ' => 'ꮩ',\n  'Ꮪ' => 'ꮪ',\n  'Ꮫ' => 'ꮫ',\n  'Ꮬ' => 'ꮬ',\n  'Ꮭ' => 'ꮭ',\n  'Ꮮ' => 'ꮮ',\n  'Ꮯ' => 'ꮯ',\n  'Ꮰ' => 'ꮰ',\n  'Ꮱ' => 'ꮱ',\n  'Ꮲ' => 'ꮲ',\n  'Ꮳ' => 'ꮳ',\n  'Ꮴ' => 'ꮴ',\n  'Ꮵ' => 'ꮵ',\n  'Ꮶ' => 'ꮶ',\n  'Ꮷ' => 'ꮷ',\n  'Ꮸ' => 'ꮸ',\n  'Ꮹ' => 'ꮹ',\n  'Ꮺ' => 'ꮺ',\n  'Ꮻ' => 'ꮻ',\n  'Ꮼ' => 'ꮼ',\n  'Ꮽ' => 'ꮽ',\n  'Ꮾ' => 'ꮾ',\n  'Ꮿ' => 'ꮿ',\n  'Ᏸ' => 'ᏸ',\n  'Ᏹ' => 'ᏹ',\n  'Ᏺ' => 'ᏺ',\n  'Ᏻ' => 'ᏻ',\n  'Ᏼ' => 'ᏼ',\n  'Ᏽ' => 'ᏽ',\n  'Ა' => 'ა',\n  'Ბ' => 'ბ',\n  'Გ' => 'გ',\n  'Დ' => 'დ',\n  'Ე' => 'ე',\n  'Ვ' => 'ვ',\n  'Ზ' => 'ზ',\n  'Თ' => 'თ',\n  'Ი' => 'ი',\n  'Კ' => 'კ',\n  'Ლ' => 'ლ',\n  'Მ' => 'მ',\n  'Ნ' => 'ნ',\n  'Ო' => 'ო',\n  'Პ' => 'პ',\n  'Ჟ' => 'ჟ',\n  'Რ' => 'რ',\n  'Ს' => 'ს',\n  'Ტ' => 'ტ',\n  'Უ' => 'უ',\n  'Ფ' => 'ფ',\n  'Ქ' => 'ქ',\n  'Ღ' => 'ღ',\n  'Ყ' => 'ყ',\n  'Შ' => 'შ',\n  'Ჩ' => 'ჩ',\n  'Ც' => 'ც',\n  'Ძ' => 'ძ',\n  'Წ' => 'წ',\n  'Ჭ' => 'ჭ',\n  'Ხ' => 'ხ',\n  'Ჯ' => 'ჯ',\n  'Ჰ' => 'ჰ',\n  'Ჱ' => 'ჱ',\n  'Ჲ' => 'ჲ',\n  'Ჳ' => 'ჳ',\n  'Ჴ' => 'ჴ',\n  'Ჵ' => 'ჵ',\n  'Ჶ' => 'ჶ',\n  'Ჷ' => 'ჷ',\n  'Ჸ' => 'ჸ',\n  'Ჹ' => 'ჹ',\n  'Ჺ' => 'ჺ',\n  'Ჽ' => 'ჽ',\n  'Ჾ' => 'ჾ',\n  'Ჿ' => 'ჿ',\n  'Ḁ' => 'ḁ',\n  'Ḃ' => 'ḃ',\n  'Ḅ' => 'ḅ',\n  'Ḇ' => 'ḇ',\n  'Ḉ' => 'ḉ',\n  'Ḋ' => 'ḋ',\n  'Ḍ' => 'ḍ',\n  'Ḏ' => 'ḏ',\n  'Ḑ' => 'ḑ',\n  'Ḓ' => 'ḓ',\n  'Ḕ' => 'ḕ',\n  'Ḗ' => 'ḗ',\n  'Ḙ' => 'ḙ',\n  'Ḛ' => 'ḛ',\n  'Ḝ' => 'ḝ',\n  'Ḟ' => 'ḟ',\n  'Ḡ' => 'ḡ',\n  'Ḣ' => 'ḣ',\n  'Ḥ' => 'ḥ',\n  'Ḧ' => 'ḧ',\n  'Ḩ' => 'ḩ',\n  'Ḫ' => 'ḫ',\n  'Ḭ' => 'ḭ',\n  'Ḯ' => 'ḯ',\n  'Ḱ' => 'ḱ',\n  'Ḳ' => 'ḳ',\n  'Ḵ' => 'ḵ',\n  'Ḷ' => 'ḷ',\n  'Ḹ' => 'ḹ',\n  'Ḻ' => 'ḻ',\n  'Ḽ' => 'ḽ',\n  'Ḿ' => 'ḿ',\n  'Ṁ' => 'ṁ',\n  'Ṃ' => 'ṃ',\n  'Ṅ' => 'ṅ',\n  'Ṇ' => 'ṇ',\n  'Ṉ' => 'ṉ',\n  'Ṋ' => 'ṋ',\n  'Ṍ' => 'ṍ',\n  'Ṏ' => 'ṏ',\n  'Ṑ' => 'ṑ',\n  'Ṓ' => 'ṓ',\n  'Ṕ' => 'ṕ',\n  'Ṗ' => 'ṗ',\n  'Ṙ' => 'ṙ',\n  'Ṛ' => 'ṛ',\n  'Ṝ' => 'ṝ',\n  'Ṟ' => 'ṟ',\n  'Ṡ' => 'ṡ',\n  'Ṣ' => 'ṣ',\n  'Ṥ' => 'ṥ',\n  'Ṧ' => 'ṧ',\n  'Ṩ' => 'ṩ',\n  'Ṫ' => 'ṫ',\n  'Ṭ' => 'ṭ',\n  'Ṯ' => 'ṯ',\n  'Ṱ' => 'ṱ',\n  'Ṳ' => 'ṳ',\n  'Ṵ' => 'ṵ',\n  'Ṷ' => 'ṷ',\n  'Ṹ' => 'ṹ',\n  'Ṻ' => 'ṻ',\n  'Ṽ' => 'ṽ',\n  'Ṿ' => 'ṿ',\n  'Ẁ' => 'ẁ',\n  'Ẃ' => 'ẃ',\n  'Ẅ' => 'ẅ',\n  'Ẇ' => 'ẇ',\n  'Ẉ' => 'ẉ',\n  'Ẋ' => 'ẋ',\n  'Ẍ' => 'ẍ',\n  'Ẏ' => 'ẏ',\n  'Ẑ' => 'ẑ',\n  'Ẓ' => 'ẓ',\n  'Ẕ' => 'ẕ',\n  'ẞ' => 'ß',\n  'Ạ' => 'ạ',\n  'Ả' => 'ả',\n  'Ấ' => 'ấ',\n  'Ầ' => 'ầ',\n  'Ẩ' => 'ẩ',\n  'Ẫ' => 'ẫ',\n  'Ậ' => 'ậ',\n  'Ắ' => 'ắ',\n  'Ằ' => 'ằ',\n  'Ẳ' => 'ẳ',\n  'Ẵ' => 'ẵ',\n  'Ặ' => 'ặ',\n  'Ẹ' => 'ẹ',\n  'Ẻ' => 'ẻ',\n  'Ẽ' => 'ẽ',\n  'Ế' => 'ế',\n  'Ề' => 'ề',\n  'Ể' => 'ể',\n  'Ễ' => 'ễ',\n  'Ệ' => 'ệ',\n  'Ỉ' => 'ỉ',\n  'Ị' => 'ị',\n  'Ọ' => 'ọ',\n  'Ỏ' => 'ỏ',\n  'Ố' => 'ố',\n  'Ồ' => 'ồ',\n  'Ổ' => 'ổ',\n  'Ỗ' => 'ỗ',\n  'Ộ' => 'ộ',\n  'Ớ' => 'ớ',\n  'Ờ' => 'ờ',\n  'Ở' => 'ở',\n  'Ỡ' => 'ỡ',\n  'Ợ' => 'ợ',\n  'Ụ' => 'ụ',\n  'Ủ' => 'ủ',\n  'Ứ' => 'ứ',\n  'Ừ' => 'ừ',\n  'Ử' => 'ử',\n  'Ữ' => 'ữ',\n  'Ự' => 'ự',\n  'Ỳ' => 'ỳ',\n  'Ỵ' => 'ỵ',\n  'Ỷ' => 'ỷ',\n  'Ỹ' => 'ỹ',\n  'Ỻ' => 'ỻ',\n  'Ỽ' => 'ỽ',\n  'Ỿ' => 'ỿ',\n  'Ἀ' => 'ἀ',\n  'Ἁ' => 'ἁ',\n  'Ἂ' => 'ἂ',\n  'Ἃ' => 'ἃ',\n  'Ἄ' => 'ἄ',\n  'Ἅ' => 'ἅ',\n  'Ἆ' => 'ἆ',\n  'Ἇ' => 'ἇ',\n  'Ἐ' => 'ἐ',\n  'Ἑ' => 'ἑ',\n  'Ἒ' => 'ἒ',\n  'Ἓ' => 'ἓ',\n  'Ἔ' => 'ἔ',\n  'Ἕ' => 'ἕ',\n  'Ἠ' => 'ἠ',\n  'Ἡ' => 'ἡ',\n  'Ἢ' => 'ἢ',\n  'Ἣ' => 'ἣ',\n  'Ἤ' => 'ἤ',\n  'Ἥ' => 'ἥ',\n  'Ἦ' => 'ἦ',\n  'Ἧ' => 'ἧ',\n  'Ἰ' => 'ἰ',\n  'Ἱ' => 'ἱ',\n  'Ἲ' => 'ἲ',\n  'Ἳ' => 'ἳ',\n  'Ἴ' => 'ἴ',\n  'Ἵ' => 'ἵ',\n  'Ἶ' => 'ἶ',\n  'Ἷ' => 'ἷ',\n  'Ὀ' => 'ὀ',\n  'Ὁ' => 'ὁ',\n  'Ὂ' => 'ὂ',\n  'Ὃ' => 'ὃ',\n  'Ὄ' => 'ὄ',\n  'Ὅ' => 'ὅ',\n  'Ὑ' => 'ὑ',\n  'Ὓ' => 'ὓ',\n  'Ὕ' => 'ὕ',\n  'Ὗ' => 'ὗ',\n  'Ὠ' => 'ὠ',\n  'Ὡ' => 'ὡ',\n  'Ὢ' => 'ὢ',\n  'Ὣ' => 'ὣ',\n  'Ὤ' => 'ὤ',\n  'Ὥ' => 'ὥ',\n  'Ὦ' => 'ὦ',\n  'Ὧ' => 'ὧ',\n  'ᾈ' => 'ᾀ',\n  'ᾉ' => 'ᾁ',\n  'ᾊ' => 'ᾂ',\n  'ᾋ' => 'ᾃ',\n  'ᾌ' => 'ᾄ',\n  'ᾍ' => 'ᾅ',\n  'ᾎ' => 'ᾆ',\n  'ᾏ' => 'ᾇ',\n  'ᾘ' => 'ᾐ',\n  'ᾙ' => 'ᾑ',\n  'ᾚ' => 'ᾒ',\n  'ᾛ' => 'ᾓ',\n  'ᾜ' => 'ᾔ',\n  'ᾝ' => 'ᾕ',\n  'ᾞ' => 'ᾖ',\n  'ᾟ' => 'ᾗ',\n  'ᾨ' => 'ᾠ',\n  'ᾩ' => 'ᾡ',\n  'ᾪ' => 'ᾢ',\n  'ᾫ' => 'ᾣ',\n  'ᾬ' => 'ᾤ',\n  'ᾭ' => 'ᾥ',\n  'ᾮ' => 'ᾦ',\n  'ᾯ' => 'ᾧ',\n  'Ᾰ' => 'ᾰ',\n  'Ᾱ' => 'ᾱ',\n  'Ὰ' => 'ὰ',\n  'Ά' => 'ά',\n  'ᾼ' => 'ᾳ',\n  'Ὲ' => 'ὲ',\n  'Έ' => 'έ',\n  'Ὴ' => 'ὴ',\n  'Ή' => 'ή',\n  'ῌ' => 'ῃ',\n  'Ῐ' => 'ῐ',\n  'Ῑ' => 'ῑ',\n  'Ὶ' => 'ὶ',\n  'Ί' => 'ί',\n  'Ῠ' => 'ῠ',\n  'Ῡ' => 'ῡ',\n  'Ὺ' => 'ὺ',\n  'Ύ' => 'ύ',\n  'Ῥ' => 'ῥ',\n  'Ὸ' => 'ὸ',\n  'Ό' => 'ό',\n  'Ὼ' => 'ὼ',\n  'Ώ' => 'ώ',\n  'ῼ' => 'ῳ',\n  'Ω' => 'ω',\n  'K' => 'k',\n  'Å' => 'å',\n  'Ⅎ' => 'ⅎ',\n  'Ⅰ' => 'ⅰ',\n  'Ⅱ' => 'ⅱ',\n  'Ⅲ' => 'ⅲ',\n  'Ⅳ' => 'ⅳ',\n  'Ⅴ' => 'ⅴ',\n  'Ⅵ' => 'ⅵ',\n  'Ⅶ' => 'ⅶ',\n  'Ⅷ' => 'ⅷ',\n  'Ⅸ' => 'ⅸ',\n  'Ⅹ' => 'ⅹ',\n  'Ⅺ' => 'ⅺ',\n  'Ⅻ' => 'ⅻ',\n  'Ⅼ' => 'ⅼ',\n  'Ⅽ' => 'ⅽ',\n  'Ⅾ' => 'ⅾ',\n  'Ⅿ' => 'ⅿ',\n  'Ↄ' => 'ↄ',\n  'Ⓐ' => 'ⓐ',\n  'Ⓑ' => 'ⓑ',\n  'Ⓒ' => 'ⓒ',\n  'Ⓓ' => 'ⓓ',\n  'Ⓔ' => 'ⓔ',\n  'Ⓕ' => 'ⓕ',\n  'Ⓖ' => 'ⓖ',\n  'Ⓗ' => 'ⓗ',\n  'Ⓘ' => 'ⓘ',\n  'Ⓙ' => 'ⓙ',\n  'Ⓚ' => 'ⓚ',\n  'Ⓛ' => 'ⓛ',\n  'Ⓜ' => 'ⓜ',\n  'Ⓝ' => 'ⓝ',\n  'Ⓞ' => 'ⓞ',\n  'Ⓟ' => 'ⓟ',\n  'Ⓠ' => 'ⓠ',\n  'Ⓡ' => 'ⓡ',\n  'Ⓢ' => 'ⓢ',\n  'Ⓣ' => 'ⓣ',\n  'Ⓤ' => 'ⓤ',\n  'Ⓥ' => 'ⓥ',\n  'Ⓦ' => 'ⓦ',\n  'Ⓧ' => 'ⓧ',\n  'Ⓨ' => 'ⓨ',\n  'Ⓩ' => 'ⓩ',\n  'Ⰰ' => 'ⰰ',\n  'Ⰱ' => 'ⰱ',\n  'Ⰲ' => 'ⰲ',\n  'Ⰳ' => 'ⰳ',\n  'Ⰴ' => 'ⰴ',\n  'Ⰵ' => 'ⰵ',\n  'Ⰶ' => 'ⰶ',\n  'Ⰷ' => 'ⰷ',\n  'Ⰸ' => 'ⰸ',\n  'Ⰹ' => 'ⰹ',\n  'Ⰺ' => 'ⰺ',\n  'Ⰻ' => 'ⰻ',\n  'Ⰼ' => 'ⰼ',\n  'Ⰽ' => 'ⰽ',\n  'Ⰾ' => 'ⰾ',\n  'Ⰿ' => 'ⰿ',\n  'Ⱀ' => 'ⱀ',\n  'Ⱁ' => 'ⱁ',\n  'Ⱂ' => 'ⱂ',\n  'Ⱃ' => 'ⱃ',\n  'Ⱄ' => 'ⱄ',\n  'Ⱅ' => 'ⱅ',\n  'Ⱆ' => 'ⱆ',\n  'Ⱇ' => 'ⱇ',\n  'Ⱈ' => 'ⱈ',\n  'Ⱉ' => 'ⱉ',\n  'Ⱊ' => 'ⱊ',\n  'Ⱋ' => 'ⱋ',\n  'Ⱌ' => 'ⱌ',\n  'Ⱍ' => 'ⱍ',\n  'Ⱎ' => 'ⱎ',\n  'Ⱏ' => 'ⱏ',\n  'Ⱐ' => 'ⱐ',\n  'Ⱑ' => 'ⱑ',\n  'Ⱒ' => 'ⱒ',\n  'Ⱓ' => 'ⱓ',\n  'Ⱔ' => 'ⱔ',\n  'Ⱕ' => 'ⱕ',\n  'Ⱖ' => 'ⱖ',\n  'Ⱗ' => 'ⱗ',\n  'Ⱘ' => 'ⱘ',\n  'Ⱙ' => 'ⱙ',\n  'Ⱚ' => 'ⱚ',\n  'Ⱛ' => 'ⱛ',\n  'Ⱜ' => 'ⱜ',\n  'Ⱝ' => 'ⱝ',\n  'Ⱞ' => 'ⱞ',\n  'Ⱡ' => 'ⱡ',\n  'Ɫ' => 'ɫ',\n  'Ᵽ' => 'ᵽ',\n  'Ɽ' => 'ɽ',\n  'Ⱨ' => 'ⱨ',\n  'Ⱪ' => 'ⱪ',\n  'Ⱬ' => 'ⱬ',\n  'Ɑ' => 'ɑ',\n  'Ɱ' => 'ɱ',\n  'Ɐ' => 'ɐ',\n  'Ɒ' => 'ɒ',\n  'Ⱳ' => 'ⱳ',\n  'Ⱶ' => 'ⱶ',\n  'Ȿ' => 'ȿ',\n  'Ɀ' => 'ɀ',\n  'Ⲁ' => 'ⲁ',\n  'Ⲃ' => 'ⲃ',\n  'Ⲅ' => 'ⲅ',\n  'Ⲇ' => 'ⲇ',\n  'Ⲉ' => 'ⲉ',\n  'Ⲋ' => 'ⲋ',\n  'Ⲍ' => 'ⲍ',\n  'Ⲏ' => 'ⲏ',\n  'Ⲑ' => 'ⲑ',\n  'Ⲓ' => 'ⲓ',\n  'Ⲕ' => 'ⲕ',\n  'Ⲗ' => 'ⲗ',\n  'Ⲙ' => 'ⲙ',\n  'Ⲛ' => 'ⲛ',\n  'Ⲝ' => 'ⲝ',\n  'Ⲟ' => 'ⲟ',\n  'Ⲡ' => 'ⲡ',\n  'Ⲣ' => 'ⲣ',\n  'Ⲥ' => 'ⲥ',\n  'Ⲧ' => 'ⲧ',\n  'Ⲩ' => 'ⲩ',\n  'Ⲫ' => 'ⲫ',\n  'Ⲭ' => 'ⲭ',\n  'Ⲯ' => 'ⲯ',\n  'Ⲱ' => 'ⲱ',\n  'Ⲳ' => 'ⲳ',\n  'Ⲵ' => 'ⲵ',\n  'Ⲷ' => 'ⲷ',\n  'Ⲹ' => 'ⲹ',\n  'Ⲻ' => 'ⲻ',\n  'Ⲽ' => 'ⲽ',\n  'Ⲿ' => 'ⲿ',\n  'Ⳁ' => 'ⳁ',\n  'Ⳃ' => 'ⳃ',\n  'Ⳅ' => 'ⳅ',\n  'Ⳇ' => 'ⳇ',\n  'Ⳉ' => 'ⳉ',\n  'Ⳋ' => 'ⳋ',\n  'Ⳍ' => 'ⳍ',\n  'Ⳏ' => 'ⳏ',\n  'Ⳑ' => 'ⳑ',\n  'Ⳓ' => 'ⳓ',\n  'Ⳕ' => 'ⳕ',\n  'Ⳗ' => 'ⳗ',\n  'Ⳙ' => 'ⳙ',\n  'Ⳛ' => 'ⳛ',\n  'Ⳝ' => 'ⳝ',\n  'Ⳟ' => 'ⳟ',\n  'Ⳡ' => 'ⳡ',\n  'Ⳣ' => 'ⳣ',\n  'Ⳬ' => 'ⳬ',\n  'Ⳮ' => 'ⳮ',\n  'Ⳳ' => 'ⳳ',\n  'Ꙁ' => 'ꙁ',\n  'Ꙃ' => 'ꙃ',\n  'Ꙅ' => 'ꙅ',\n  'Ꙇ' => 'ꙇ',\n  'Ꙉ' => 'ꙉ',\n  'Ꙋ' => 'ꙋ',\n  'Ꙍ' => 'ꙍ',\n  'Ꙏ' => 'ꙏ',\n  'Ꙑ' => 'ꙑ',\n  'Ꙓ' => 'ꙓ',\n  'Ꙕ' => 'ꙕ',\n  'Ꙗ' => 'ꙗ',\n  'Ꙙ' => 'ꙙ',\n  'Ꙛ' => 'ꙛ',\n  'Ꙝ' => 'ꙝ',\n  'Ꙟ' => 'ꙟ',\n  'Ꙡ' => 'ꙡ',\n  'Ꙣ' => 'ꙣ',\n  'Ꙥ' => 'ꙥ',\n  'Ꙧ' => 'ꙧ',\n  'Ꙩ' => 'ꙩ',\n  'Ꙫ' => 'ꙫ',\n  'Ꙭ' => 'ꙭ',\n  'Ꚁ' => 'ꚁ',\n  'Ꚃ' => 'ꚃ',\n  'Ꚅ' => 'ꚅ',\n  'Ꚇ' => 'ꚇ',\n  'Ꚉ' => 'ꚉ',\n  'Ꚋ' => 'ꚋ',\n  'Ꚍ' => 'ꚍ',\n  'Ꚏ' => 'ꚏ',\n  'Ꚑ' => 'ꚑ',\n  'Ꚓ' => 'ꚓ',\n  'Ꚕ' => 'ꚕ',\n  'Ꚗ' => 'ꚗ',\n  'Ꚙ' => 'ꚙ',\n  'Ꚛ' => 'ꚛ',\n  'Ꜣ' => 'ꜣ',\n  'Ꜥ' => 'ꜥ',\n  'Ꜧ' => 'ꜧ',\n  'Ꜩ' => 'ꜩ',\n  'Ꜫ' => 'ꜫ',\n  'Ꜭ' => 'ꜭ',\n  'Ꜯ' => 'ꜯ',\n  'Ꜳ' => 'ꜳ',\n  'Ꜵ' => 'ꜵ',\n  'Ꜷ' => 'ꜷ',\n  'Ꜹ' => 'ꜹ',\n  'Ꜻ' => 'ꜻ',\n  'Ꜽ' => 'ꜽ',\n  'Ꜿ' => 'ꜿ',\n  'Ꝁ' => 'ꝁ',\n  'Ꝃ' => 'ꝃ',\n  'Ꝅ' => 'ꝅ',\n  'Ꝇ' => 'ꝇ',\n  'Ꝉ' => 'ꝉ',\n  'Ꝋ' => 'ꝋ',\n  'Ꝍ' => 'ꝍ',\n  'Ꝏ' => 'ꝏ',\n  'Ꝑ' => 'ꝑ',\n  'Ꝓ' => 'ꝓ',\n  'Ꝕ' => 'ꝕ',\n  'Ꝗ' => 'ꝗ',\n  'Ꝙ' => 'ꝙ',\n  'Ꝛ' => 'ꝛ',\n  'Ꝝ' => 'ꝝ',\n  'Ꝟ' => 'ꝟ',\n  'Ꝡ' => 'ꝡ',\n  'Ꝣ' => 'ꝣ',\n  'Ꝥ' => 'ꝥ',\n  'Ꝧ' => 'ꝧ',\n  'Ꝩ' => 'ꝩ',\n  'Ꝫ' => 'ꝫ',\n  'Ꝭ' => 'ꝭ',\n  'Ꝯ' => 'ꝯ',\n  'Ꝺ' => 'ꝺ',\n  'Ꝼ' => 'ꝼ',\n  'Ᵹ' => 'ᵹ',\n  'Ꝿ' => 'ꝿ',\n  'Ꞁ' => 'ꞁ',\n  'Ꞃ' => 'ꞃ',\n  'Ꞅ' => 'ꞅ',\n  'Ꞇ' => 'ꞇ',\n  'Ꞌ' => 'ꞌ',\n  'Ɥ' => 'ɥ',\n  'Ꞑ' => 'ꞑ',\n  'Ꞓ' => 'ꞓ',\n  'Ꞗ' => 'ꞗ',\n  'Ꞙ' => 'ꞙ',\n  'Ꞛ' => 'ꞛ',\n  'Ꞝ' => 'ꞝ',\n  'Ꞟ' => 'ꞟ',\n  'Ꞡ' => 'ꞡ',\n  'Ꞣ' => 'ꞣ',\n  'Ꞥ' => 'ꞥ',\n  'Ꞧ' => 'ꞧ',\n  'Ꞩ' => 'ꞩ',\n  'Ɦ' => 'ɦ',\n  'Ɜ' => 'ɜ',\n  'Ɡ' => 'ɡ',\n  'Ɬ' => 'ɬ',\n  'Ɪ' => 'ɪ',\n  'Ʞ' => 'ʞ',\n  'Ʇ' => 'ʇ',\n  'Ʝ' => 'ʝ',\n  'Ꭓ' => 'ꭓ',\n  'Ꞵ' => 'ꞵ',\n  'Ꞷ' => 'ꞷ',\n  'Ꞹ' => 'ꞹ',\n  'Ꞻ' => 'ꞻ',\n  'Ꞽ' => 'ꞽ',\n  'Ꞿ' => 'ꞿ',\n  'Ꟃ' => 'ꟃ',\n  'Ꞔ' => 'ꞔ',\n  'Ʂ' => 'ʂ',\n  'Ᶎ' => 'ᶎ',\n  'Ꟈ' => 'ꟈ',\n  'Ꟊ' => 'ꟊ',\n  'Ꟶ' => 'ꟶ',\n  'Ａ' => 'ａ',\n  'Ｂ' => 'ｂ',\n  'Ｃ' => 'ｃ',\n  'Ｄ' => 'ｄ',\n  'Ｅ' => 'ｅ',\n  'Ｆ' => 'ｆ',\n  'Ｇ' => 'ｇ',\n  'Ｈ' => 'ｈ',\n  'Ｉ' => 'ｉ',\n  'Ｊ' => 'ｊ',\n  'Ｋ' => 'ｋ',\n  'Ｌ' => 'ｌ',\n  'Ｍ' => 'ｍ',\n  'Ｎ' => 'ｎ',\n  'Ｏ' => 'ｏ',\n  'Ｐ' => 'ｐ',\n  'Ｑ' => 'ｑ',\n  'Ｒ' => 'ｒ',\n  'Ｓ' => 'ｓ',\n  'Ｔ' => 'ｔ',\n  'Ｕ' => 'ｕ',\n  'Ｖ' => 'ｖ',\n  'Ｗ' => 'ｗ',\n  'Ｘ' => 'ｘ',\n  'Ｙ' => 'ｙ',\n  'Ｚ' => 'ｚ',\n  '𐐀' => '𐐨',\n  '𐐁' => '𐐩',\n  '𐐂' => '𐐪',\n  '𐐃' => '𐐫',\n  '𐐄' => '𐐬',\n  '𐐅' => '𐐭',\n  '𐐆' => '𐐮',\n  '𐐇' => '𐐯',\n  '𐐈' => '𐐰',\n  '𐐉' => '𐐱',\n  '𐐊' => '𐐲',\n  '𐐋' => '𐐳',\n  '𐐌' => '𐐴',\n  '𐐍' => '𐐵',\n  '𐐎' => '𐐶',\n  '𐐏' => '𐐷',\n  '𐐐' => '𐐸',\n  '𐐑' => '𐐹',\n  '𐐒' => '𐐺',\n  '𐐓' => '𐐻',\n  '𐐔' => '𐐼',\n  '𐐕' => '𐐽',\n  '𐐖' => '𐐾',\n  '𐐗' => '𐐿',\n  '𐐘' => '𐑀',\n  '𐐙' => '𐑁',\n  '𐐚' => '𐑂',\n  '𐐛' => '𐑃',\n  '𐐜' => '𐑄',\n  '𐐝' => '𐑅',\n  '𐐞' => '𐑆',\n  '𐐟' => '𐑇',\n  '𐐠' => '𐑈',\n  '𐐡' => '𐑉',\n  '𐐢' => '𐑊',\n  '𐐣' => '𐑋',\n  '𐐤' => '𐑌',\n  '𐐥' => '𐑍',\n  '𐐦' => '𐑎',\n  '𐐧' => '𐑏',\n  '𐒰' => '𐓘',\n  '𐒱' => '𐓙',\n  '𐒲' => '𐓚',\n  '𐒳' => '𐓛',\n  '𐒴' => '𐓜',\n  '𐒵' => '𐓝',\n  '𐒶' => '𐓞',\n  '𐒷' => '𐓟',\n  '𐒸' => '𐓠',\n  '𐒹' => '𐓡',\n  '𐒺' => '𐓢',\n  '𐒻' => '𐓣',\n  '𐒼' => '𐓤',\n  '𐒽' => '𐓥',\n  '𐒾' => '𐓦',\n  '𐒿' => '𐓧',\n  '𐓀' => '𐓨',\n  '𐓁' => '𐓩',\n  '𐓂' => '𐓪',\n  '𐓃' => '𐓫',\n  '𐓄' => '𐓬',\n  '𐓅' => '𐓭',\n  '𐓆' => '𐓮',\n  '𐓇' => '𐓯',\n  '𐓈' => '𐓰',\n  '𐓉' => '𐓱',\n  '𐓊' => '𐓲',\n  '𐓋' => '𐓳',\n  '𐓌' => '𐓴',\n  '𐓍' => '𐓵',\n  '𐓎' => '𐓶',\n  '𐓏' => '𐓷',\n  '𐓐' => '𐓸',\n  '𐓑' => '𐓹',\n  '𐓒' => '𐓺',\n  '𐓓' => '𐓻',\n  '𐲀' => '𐳀',\n  '𐲁' => '𐳁',\n  '𐲂' => '𐳂',\n  '𐲃' => '𐳃',\n  '𐲄' => '𐳄',\n  '𐲅' => '𐳅',\n  '𐲆' => '𐳆',\n  '𐲇' => '𐳇',\n  '𐲈' => '𐳈',\n  '𐲉' => '𐳉',\n  '𐲊' => '𐳊',\n  '𐲋' => '𐳋',\n  '𐲌' => '𐳌',\n  '𐲍' => '𐳍',\n  '𐲎' => '𐳎',\n  '𐲏' => '𐳏',\n  '𐲐' => '𐳐',\n  '𐲑' => '𐳑',\n  '𐲒' => '𐳒',\n  '𐲓' => '𐳓',\n  '𐲔' => '𐳔',\n  '𐲕' => '𐳕',\n  '𐲖' => '𐳖',\n  '𐲗' => '𐳗',\n  '𐲘' => '𐳘',\n  '𐲙' => '𐳙',\n  '𐲚' => '𐳚',\n  '𐲛' => '𐳛',\n  '𐲜' => '𐳜',\n  '𐲝' => '𐳝',\n  '𐲞' => '𐳞',\n  '𐲟' => '𐳟',\n  '𐲠' => '𐳠',\n  '𐲡' => '𐳡',\n  '𐲢' => '𐳢',\n  '𐲣' => '𐳣',\n  '𐲤' => '𐳤',\n  '𐲥' => '𐳥',\n  '𐲦' => '𐳦',\n  '𐲧' => '𐳧',\n  '𐲨' => '𐳨',\n  '𐲩' => '𐳩',\n  '𐲪' => '𐳪',\n  '𐲫' => '𐳫',\n  '𐲬' => '𐳬',\n  '𐲭' => '𐳭',\n  '𐲮' => '𐳮',\n  '𐲯' => '𐳯',\n  '𐲰' => '𐳰',\n  '𐲱' => '𐳱',\n  '𐲲' => '𐳲',\n  '𑢠' => '𑣀',\n  '𑢡' => '𑣁',\n  '𑢢' => '𑣂',\n  '𑢣' => '𑣃',\n  '𑢤' => '𑣄',\n  '𑢥' => '𑣅',\n  '𑢦' => '𑣆',\n  '𑢧' => '𑣇',\n  '𑢨' => '𑣈',\n  '𑢩' => '𑣉',\n  '𑢪' => '𑣊',\n  '𑢫' => '𑣋',\n  '𑢬' => '𑣌',\n  '𑢭' => '𑣍',\n  '𑢮' => '𑣎',\n  '𑢯' => '𑣏',\n  '𑢰' => '𑣐',\n  '𑢱' => '𑣑',\n  '𑢲' => '𑣒',\n  '𑢳' => '𑣓',\n  '𑢴' => '𑣔',\n  '𑢵' => '𑣕',\n  '𑢶' => '𑣖',\n  '𑢷' => '𑣗',\n  '𑢸' => '𑣘',\n  '𑢹' => '𑣙',\n  '𑢺' => '𑣚',\n  '𑢻' => '𑣛',\n  '𑢼' => '𑣜',\n  '𑢽' => '𑣝',\n  '𑢾' => '𑣞',\n  '𑢿' => '𑣟',\n  '𖹀' => '𖹠',\n  '𖹁' => '𖹡',\n  '𖹂' => '𖹢',\n  '𖹃' => '𖹣',\n  '𖹄' => '𖹤',\n  '𖹅' => '𖹥',\n  '𖹆' => '𖹦',\n  '𖹇' => '𖹧',\n  '𖹈' => '𖹨',\n  '𖹉' => '𖹩',\n  '𖹊' => '𖹪',\n  '𖹋' => '𖹫',\n  '𖹌' => '𖹬',\n  '𖹍' => '𖹭',\n  '𖹎' => '𖹮',\n  '𖹏' => '𖹯',\n  '𖹐' => '𖹰',\n  '𖹑' => '𖹱',\n  '𖹒' => '𖹲',\n  '𖹓' => '𖹳',\n  '𖹔' => '𖹴',\n  '𖹕' => '𖹵',\n  '𖹖' => '𖹶',\n  '𖹗' => '𖹷',\n  '𖹘' => '𖹸',\n  '𖹙' => '𖹹',\n  '𖹚' => '𖹺',\n  '𖹛' => '𖹻',\n  '𖹜' => '𖹼',\n  '𖹝' => '𖹽',\n  '𖹞' => '𖹾',\n  '𖹟' => '𖹿',\n  '𞤀' => '𞤢',\n  '𞤁' => '𞤣',\n  '𞤂' => '𞤤',\n  '𞤃' => '𞤥',\n  '𞤄' => '𞤦',\n  '𞤅' => '𞤧',\n  '𞤆' => '𞤨',\n  '𞤇' => '𞤩',\n  '𞤈' => '𞤪',\n  '𞤉' => '𞤫',\n  '𞤊' => '𞤬',\n  '𞤋' => '𞤭',\n  '𞤌' => '𞤮',\n  '𞤍' => '𞤯',\n  '𞤎' => '𞤰',\n  '𞤏' => '𞤱',\n  '𞤐' => '𞤲',\n  '𞤑' => '𞤳',\n  '𞤒' => '𞤴',\n  '𞤓' => '𞤵',\n  '𞤔' => '𞤶',\n  '𞤕' => '𞤷',\n  '𞤖' => '𞤸',\n  '𞤗' => '𞤹',\n  '𞤘' => '𞤺',\n  '𞤙' => '𞤻',\n  '𞤚' => '𞤼',\n  '𞤛' => '𞤽',\n  '𞤜' => '𞤾',\n  '𞤝' => '𞤿',\n  '𞤞' => '𞥀',\n  '𞤟' => '𞥁',\n  '𞤠' => '𞥂',\n  '𞤡' => '𞥃',\n);\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/polyfill-mbstring/Resources/unidata/titleCaseRegexp.php',
    "<?php\n\n// from Case_Ignorable in https://unicode.org/Public/UNIDATA/DerivedCoreProperties.txt\n\nreturn '/(?<![\\x{0027}\\x{002E}\\x{003A}\\x{005E}\\x{0060}\\x{00A8}\\x{00AD}\\x{00AF}\\x{00B4}\\x{00B7}\\x{00B8}\\x{02B0}-\\x{02C1}\\x{02C2}-\\x{02C5}\\x{02C6}-\\x{02D1}\\x{02D2}-\\x{02DF}\\x{02E0}-\\x{02E4}\\x{02E5}-\\x{02EB}\\x{02EC}\\x{02ED}\\x{02EE}\\x{02EF}-\\x{02FF}\\x{0300}-\\x{036F}\\x{0374}\\x{0375}\\x{037A}\\x{0384}-\\x{0385}\\x{0387}\\x{0483}-\\x{0487}\\x{0488}-\\x{0489}\\x{0559}\\x{0591}-\\x{05BD}\\x{05BF}\\x{05C1}-\\x{05C2}\\x{05C4}-\\x{05C5}\\x{05C7}\\x{05F4}\\x{0600}-\\x{0605}\\x{0610}-\\x{061A}\\x{061C}\\x{0640}\\x{064B}-\\x{065F}\\x{0670}\\x{06D6}-\\x{06DC}\\x{06DD}\\x{06DF}-\\x{06E4}\\x{06E5}-\\x{06E6}\\x{06E7}-\\x{06E8}\\x{06EA}-\\x{06ED}\\x{070F}\\x{0711}\\x{0730}-\\x{074A}\\x{07A6}-\\x{07B0}\\x{07EB}-\\x{07F3}\\x{07F4}-\\x{07F5}\\x{07FA}\\x{07FD}\\x{0816}-\\x{0819}\\x{081A}\\x{081B}-\\x{0823}\\x{0824}\\x{0825}-\\x{0827}\\x{0828}\\x{0829}-\\x{082D}\\x{0859}-\\x{085B}\\x{08D3}-\\x{08E1}\\x{08E2}\\x{08E3}-\\x{0902}\\x{093A}\\x{093C}\\x{0941}-\\x{0948}\\x{094D}\\x{0951}-\\x{0957}\\x{0962}-\\x{0963}\\x{0971}\\x{0981}\\x{09BC}\\x{09C1}-\\x{09C4}\\x{09CD}\\x{09E2}-\\x{09E3}\\x{09FE}\\x{0A01}-\\x{0A02}\\x{0A3C}\\x{0A41}-\\x{0A42}\\x{0A47}-\\x{0A48}\\x{0A4B}-\\x{0A4D}\\x{0A51}\\x{0A70}-\\x{0A71}\\x{0A75}\\x{0A81}-\\x{0A82}\\x{0ABC}\\x{0AC1}-\\x{0AC5}\\x{0AC7}-\\x{0AC8}\\x{0ACD}\\x{0AE2}-\\x{0AE3}\\x{0AFA}-\\x{0AFF}\\x{0B01}\\x{0B3C}\\x{0B3F}\\x{0B41}-\\x{0B44}\\x{0B4D}\\x{0B56}\\x{0B62}-\\x{0B63}\\x{0B82}\\x{0BC0}\\x{0BCD}\\x{0C00}\\x{0C04}\\x{0C3E}-\\x{0C40}\\x{0C46}-\\x{0C48}\\x{0C4A}-\\x{0C4D}\\x{0C55}-\\x{0C56}\\x{0C62}-\\x{0C63}\\x{0C81}\\x{0CBC}\\x{0CBF}\\x{0CC6}\\x{0CCC}-\\x{0CCD}\\x{0CE2}-\\x{0CE3}\\x{0D00}-\\x{0D01}\\x{0D3B}-\\x{0D3C}\\x{0D41}-\\x{0D44}\\x{0D4D}\\x{0D62}-\\x{0D63}\\x{0DCA}\\x{0DD2}-\\x{0DD4}\\x{0DD6}\\x{0E31}\\x{0E34}-\\x{0E3A}\\x{0E46}\\x{0E47}-\\x{0E4E}\\x{0EB1}\\x{0EB4}-\\x{0EB9}\\x{0EBB}-\\x{0EBC}\\x{0EC6}\\x{0EC8}-\\x{0ECD}\\x{0F18}-\\x{0F19}\\x{0F35}\\x{0F37}\\x{0F39}\\x{0F71}-\\x{0F7E}\\x{0F80}-\\x{0F84}\\x{0F86}-\\x{0F87}\\x{0F8D}-\\x{0F97}\\x{0F99}-\\x{0FBC}\\x{0FC6}\\x{102D}-\\x{1030}\\x{1032}-\\x{1037}\\x{1039}-\\x{103A}\\x{103D}-\\x{103E}\\x{1058}-\\x{1059}\\x{105E}-\\x{1060}\\x{1071}-\\x{1074}\\x{1082}\\x{1085}-\\x{1086}\\x{108D}\\x{109D}\\x{10FC}\\x{135D}-\\x{135F}\\x{1712}-\\x{1714}\\x{1732}-\\x{1734}\\x{1752}-\\x{1753}\\x{1772}-\\x{1773}\\x{17B4}-\\x{17B5}\\x{17B7}-\\x{17BD}\\x{17C6}\\x{17C9}-\\x{17D3}\\x{17D7}\\x{17DD}\\x{180B}-\\x{180D}\\x{180E}\\x{1843}\\x{1885}-\\x{1886}\\x{18A9}\\x{1920}-\\x{1922}\\x{1927}-\\x{1928}\\x{1932}\\x{1939}-\\x{193B}\\x{1A17}-\\x{1A18}\\x{1A1B}\\x{1A56}\\x{1A58}-\\x{1A5E}\\x{1A60}\\x{1A62}\\x{1A65}-\\x{1A6C}\\x{1A73}-\\x{1A7C}\\x{1A7F}\\x{1AA7}\\x{1AB0}-\\x{1ABD}\\x{1ABE}\\x{1B00}-\\x{1B03}\\x{1B34}\\x{1B36}-\\x{1B3A}\\x{1B3C}\\x{1B42}\\x{1B6B}-\\x{1B73}\\x{1B80}-\\x{1B81}\\x{1BA2}-\\x{1BA5}\\x{1BA8}-\\x{1BA9}\\x{1BAB}-\\x{1BAD}\\x{1BE6}\\x{1BE8}-\\x{1BE9}\\x{1BED}\\x{1BEF}-\\x{1BF1}\\x{1C2C}-\\x{1C33}\\x{1C36}-\\x{1C37}\\x{1C78}-\\x{1C7D}\\x{1CD0}-\\x{1CD2}\\x{1CD4}-\\x{1CE0}\\x{1CE2}-\\x{1CE8}\\x{1CED}\\x{1CF4}\\x{1CF8}-\\x{1CF9}\\x{1D2C}-\\x{1D6A}\\x{1D78}\\x{1D9B}-\\x{1DBF}\\x{1DC0}-\\x{1DF9}\\x{1DFB}-\\x{1DFF}\\x{1FBD}\\x{1FBF}-\\x{1FC1}\\x{1FCD}-\\x{1FCF}\\x{1FDD}-\\x{1FDF}\\x{1FED}-\\x{1FEF}\\x{1FFD}-\\x{1FFE}\\x{200B}-\\x{200F}\\x{2018}\\x{2019}\\x{2024}\\x{2027}\\x{202A}-\\x{202E}\\x{2060}-\\x{2064}\\x{2066}-\\x{206F}\\x{2071}\\x{207F}\\x{2090}-\\x{209C}\\x{20D0}-\\x{20DC}\\x{20DD}-\\x{20E0}\\x{20E1}\\x{20E2}-\\x{20E4}\\x{20E5}-\\x{20F0}\\x{2C7C}-\\x{2C7D}\\x{2CEF}-\\x{2CF1}\\x{2D6F}\\x{2D7F}\\x{2DE0}-\\x{2DFF}\\x{2E2F}\\x{3005}\\x{302A}-\\x{302D}\\x{3031}-\\x{3035}\\x{303B}\\x{3099}-\\x{309A}\\x{309B}-\\x{309C}\\x{309D}-\\x{309E}\\x{30FC}-\\x{30FE}\\x{A015}\\x{A4F8}-\\x{A4FD}\\x{A60C}\\x{A66F}\\x{A670}-\\x{A672}\\x{A674}-\\x{A67D}\\x{A67F}\\x{A69C}-\\x{A69D}\\x{A69E}-\\x{A69F}\\x{A6F0}-\\x{A6F1}\\x{A700}-\\x{A716}\\x{A717}-\\x{A71F}\\x{A720}-\\x{A721}\\x{A770}\\x{A788}\\x{A789}-\\x{A78A}\\x{A7F8}-\\x{A7F9}\\x{A802}\\x{A806}\\x{A80B}\\x{A825}-\\x{A826}\\x{A8C4}-\\x{A8C5}\\x{A8E0}-\\x{A8F1}\\x{A8FF}\\x{A926}-\\x{A92D}\\x{A947}-\\x{A951}\\x{A980}-\\x{A982}\\x{A9B3}\\x{A9B6}-\\x{A9B9}\\x{A9BC}\\x{A9CF}\\x{A9E5}\\x{A9E6}\\x{AA29}-\\x{AA2E}\\x{AA31}-\\x{AA32}\\x{AA35}-\\x{AA36}\\x{AA43}\\x{AA4C}\\x{AA70}\\x{AA7C}\\x{AAB0}\\x{AAB2}-\\x{AAB4}\\x{AAB7}-\\x{AAB8}\\x{AABE}-\\x{AABF}\\x{AAC1}\\x{AADD}\\x{AAEC}-\\x{AAED}\\x{AAF3}-\\x{AAF4}\\x{AAF6}\\x{AB5B}\\x{AB5C}-\\x{AB5F}\\x{ABE5}\\x{ABE8}\\x{ABED}\\x{FB1E}\\x{FBB2}-\\x{FBC1}\\x{FE00}-\\x{FE0F}\\x{FE13}\\x{FE20}-\\x{FE2F}\\x{FE52}\\x{FE55}\\x{FEFF}\\x{FF07}\\x{FF0E}\\x{FF1A}\\x{FF3E}\\x{FF40}\\x{FF70}\\x{FF9E}-\\x{FF9F}\\x{FFE3}\\x{FFF9}-\\x{FFFB}\\x{101FD}\\x{102E0}\\x{10376}-\\x{1037A}\\x{10A01}-\\x{10A03}\\x{10A05}-\\x{10A06}\\x{10A0C}-\\x{10A0F}\\x{10A38}-\\x{10A3A}\\x{10A3F}\\x{10AE5}-\\x{10AE6}\\x{10D24}-\\x{10D27}\\x{10F46}-\\x{10F50}\\x{11001}\\x{11038}-\\x{11046}\\x{1107F}-\\x{11081}\\x{110B3}-\\x{110B6}\\x{110B9}-\\x{110BA}\\x{110BD}\\x{110CD}\\x{11100}-\\x{11102}\\x{11127}-\\x{1112B}\\x{1112D}-\\x{11134}\\x{11173}\\x{11180}-\\x{11181}\\x{111B6}-\\x{111BE}\\x{111C9}-\\x{111CC}\\x{1122F}-\\x{11231}\\x{11234}\\x{11236}-\\x{11237}\\x{1123E}\\x{112DF}\\x{112E3}-\\x{112EA}\\x{11300}-\\x{11301}\\x{1133B}-\\x{1133C}\\x{11340}\\x{11366}-\\x{1136C}\\x{11370}-\\x{11374}\\x{11438}-\\x{1143F}\\x{11442}-\\x{11444}\\x{11446}\\x{1145E}\\x{114B3}-\\x{114B8}\\x{114BA}\\x{114BF}-\\x{114C0}\\x{114C2}-\\x{114C3}\\x{115B2}-\\x{115B5}\\x{115BC}-\\x{115BD}\\x{115BF}-\\x{115C0}\\x{115DC}-\\x{115DD}\\x{11633}-\\x{1163A}\\x{1163D}\\x{1163F}-\\x{11640}\\x{116AB}\\x{116AD}\\x{116B0}-\\x{116B5}\\x{116B7}\\x{1171D}-\\x{1171F}\\x{11722}-\\x{11725}\\x{11727}-\\x{1172B}\\x{1182F}-\\x{11837}\\x{11839}-\\x{1183A}\\x{11A01}-\\x{11A0A}\\x{11A33}-\\x{11A38}\\x{11A3B}-\\x{11A3E}\\x{11A47}\\x{11A51}-\\x{11A56}\\x{11A59}-\\x{11A5B}\\x{11A8A}-\\x{11A96}\\x{11A98}-\\x{11A99}\\x{11C30}-\\x{11C36}\\x{11C38}-\\x{11C3D}\\x{11C3F}\\x{11C92}-\\x{11CA7}\\x{11CAA}-\\x{11CB0}\\x{11CB2}-\\x{11CB3}\\x{11CB5}-\\x{11CB6}\\x{11D31}-\\x{11D36}\\x{11D3A}\\x{11D3C}-\\x{11D3D}\\x{11D3F}-\\x{11D45}\\x{11D47}\\x{11D90}-\\x{11D91}\\x{11D95}\\x{11D97}\\x{11EF3}-\\x{11EF4}\\x{16AF0}-\\x{16AF4}\\x{16B30}-\\x{16B36}\\x{16B40}-\\x{16B43}\\x{16F8F}-\\x{16F92}\\x{16F93}-\\x{16F9F}\\x{16FE0}-\\x{16FE1}\\x{1BC9D}-\\x{1BC9E}\\x{1BCA0}-\\x{1BCA3}\\x{1D167}-\\x{1D169}\\x{1D173}-\\x{1D17A}\\x{1D17B}-\\x{1D182}\\x{1D185}-\\x{1D18B}\\x{1D1AA}-\\x{1D1AD}\\x{1D242}-\\x{1D244}\\x{1DA00}-\\x{1DA36}\\x{1DA3B}-\\x{1DA6C}\\x{1DA75}\\x{1DA84}\\x{1DA9B}-\\x{1DA9F}\\x{1DAA1}-\\x{1DAAF}\\x{1E000}-\\x{1E006}\\x{1E008}-\\x{1E018}\\x{1E01B}-\\x{1E021}\\x{1E023}-\\x{1E024}\\x{1E026}-\\x{1E02A}\\x{1E8D0}-\\x{1E8D6}\\x{1E944}-\\x{1E94A}\\x{1F3FB}-\\x{1F3FF}\\x{E0001}\\x{E0020}-\\x{E007F}\\x{E0100}-\\x{E01EF}])(\\pL)(\\pL*+)/u';\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/polyfill-mbstring/Resources/unidata/upperCase.php',
    "<?php\n\nreturn array (\n  'a' => 'A',\n  'b' => 'B',\n  'c' => 'C',\n  'd' => 'D',\n  'e' => 'E',\n  'f' => 'F',\n  'g' => 'G',\n  'h' => 'H',\n  'i' => 'I',\n  'j' => 'J',\n  'k' => 'K',\n  'l' => 'L',\n  'm' => 'M',\n  'n' => 'N',\n  'o' => 'O',\n  'p' => 'P',\n  'q' => 'Q',\n  'r' => 'R',\n  's' => 'S',\n  't' => 'T',\n  'u' => 'U',\n  'v' => 'V',\n  'w' => 'W',\n  'x' => 'X',\n  'y' => 'Y',\n  'z' => 'Z',\n  'µ' => 'Μ',\n  'à' => 'À',\n  'á' => 'Á',\n  'â' => 'Â',\n  'ã' => 'Ã',\n  'ä' => 'Ä',\n  'å' => 'Å',\n  'æ' => 'Æ',\n  'ç' => 'Ç',\n  'è' => 'È',\n  'é' => 'É',\n  'ê' => 'Ê',\n  'ë' => 'Ë',\n  'ì' => 'Ì',\n  'í' => 'Í',\n  'î' => 'Î',\n  'ï' => 'Ï',\n  'ð' => 'Ð',\n  'ñ' => 'Ñ',\n  'ò' => 'Ò',\n  'ó' => 'Ó',\n  'ô' => 'Ô',\n  'õ' => 'Õ',\n  'ö' => 'Ö',\n  'ø' => 'Ø',\n  'ù' => 'Ù',\n  'ú' => 'Ú',\n  'û' => 'Û',\n  'ü' => 'Ü',\n  'ý' => 'Ý',\n  'þ' => 'Þ',\n  'ÿ' => 'Ÿ',\n  'ā' => 'Ā',\n  'ă' => 'Ă',\n  'ą' => 'Ą',\n  'ć' => 'Ć',\n  'ĉ' => 'Ĉ',\n  'ċ' => 'Ċ',\n  'č' => 'Č',\n  'ď' => 'Ď',\n  'đ' => 'Đ',\n  'ē' => 'Ē',\n  'ĕ' => 'Ĕ',\n  'ė' => 'Ė',\n  'ę' => 'Ę',\n  'ě' => 'Ě',\n  'ĝ' => 'Ĝ',\n  'ğ' => 'Ğ',\n  'ġ' => 'Ġ',\n  'ģ' => 'Ģ',\n  'ĥ' => 'Ĥ',\n  'ħ' => 'Ħ',\n  'ĩ' => 'Ĩ',\n  'ī' => 'Ī',\n  'ĭ' => 'Ĭ',\n  'į' => 'Į',\n  'ı' => 'I',\n  'ĳ' => 'Ĳ',\n  'ĵ' => 'Ĵ',\n  'ķ' => 'Ķ',\n  'ĺ' => 'Ĺ',\n  'ļ' => 'Ļ',\n  'ľ' => 'Ľ',\n  'ŀ' => 'Ŀ',\n  'ł' => 'Ł',\n  'ń' => 'Ń',\n  'ņ' => 'Ņ',\n  'ň' => 'Ň',\n  'ŋ' => 'Ŋ',\n  'ō' => 'Ō',\n  'ŏ' => 'Ŏ',\n  'ő' => 'Ő',\n  'œ' => 'Œ',\n  'ŕ' => 'Ŕ',\n  'ŗ' => 'Ŗ',\n  'ř' => 'Ř',\n  'ś' => 'Ś',\n  'ŝ' => 'Ŝ',\n  'ş' => 'Ş',\n  'š' => 'Š',\n  'ţ' => 'Ţ',\n  'ť' => 'Ť',\n  'ŧ' => 'Ŧ',\n  'ũ' => 'Ũ',\n  'ū' => 'Ū',\n  'ŭ' => 'Ŭ',\n  'ů' => 'Ů',\n  'ű' => 'Ű',\n  'ų' => 'Ų',\n  'ŵ' => 'Ŵ',\n  'ŷ' => 'Ŷ',\n  'ź' => 'Ź',\n  'ż' => 'Ż',\n  'ž' => 'Ž',\n  'ſ' => 'S',\n  'ƀ' => 'Ƀ',\n  'ƃ' => 'Ƃ',\n  'ƅ' => 'Ƅ',\n  'ƈ' => 'Ƈ',\n  'ƌ' => 'Ƌ',\n  'ƒ' => 'Ƒ',\n  'ƕ' => 'Ƕ',\n  'ƙ' => 'Ƙ',\n  'ƚ' => 'Ƚ',\n  'ƞ' => 'Ƞ',\n  'ơ' => 'Ơ',\n  'ƣ' => 'Ƣ',\n  'ƥ' => 'Ƥ',\n  'ƨ' => 'Ƨ',\n  'ƭ' => 'Ƭ',\n  'ư' => 'Ư',\n  'ƴ' => 'Ƴ',\n  'ƶ' => 'Ƶ',\n  'ƹ' => 'Ƹ',\n  'ƽ' => 'Ƽ',\n  'ƿ' => 'Ƿ',\n  'ǅ' => 'Ǆ',\n  'ǆ' => 'Ǆ',\n  'ǈ' => 'Ǉ',\n  'ǉ' => 'Ǉ',\n  'ǋ' => 'Ǌ',\n  'ǌ' => 'Ǌ',\n  'ǎ' => 'Ǎ',\n  'ǐ' => 'Ǐ',\n  'ǒ' => 'Ǒ',\n  'ǔ' => 'Ǔ',\n  'ǖ' => 'Ǖ',\n  'ǘ' => 'Ǘ',\n  'ǚ' => 'Ǚ',\n  'ǜ' => 'Ǜ',\n  'ǝ' => 'Ǝ',\n  'ǟ' => 'Ǟ',\n  'ǡ' => 'Ǡ',\n  'ǣ' => 'Ǣ',\n  'ǥ' => 'Ǥ',\n  'ǧ' => 'Ǧ',\n  'ǩ' => 'Ǩ',\n  'ǫ' => 'Ǫ',\n  'ǭ' => 'Ǭ',\n  'ǯ' => 'Ǯ',\n  'ǲ' => 'Ǳ',\n  'ǳ' => 'Ǳ',\n  'ǵ' => 'Ǵ',\n  'ǹ' => 'Ǹ',\n  'ǻ' => 'Ǻ',\n  'ǽ' => 'Ǽ',\n  'ǿ' => 'Ǿ',\n  'ȁ' => 'Ȁ',\n  'ȃ' => 'Ȃ',\n  'ȅ' => 'Ȅ',\n  'ȇ' => 'Ȇ',\n  'ȉ' => 'Ȉ',\n  'ȋ' => 'Ȋ',\n  'ȍ' => 'Ȍ',\n  'ȏ' => 'Ȏ',\n  'ȑ' => 'Ȑ',\n  'ȓ' => 'Ȓ',\n  'ȕ' => 'Ȕ',\n  'ȗ' => 'Ȗ',\n  'ș' => 'Ș',\n  'ț' => 'Ț',\n  'ȝ' => 'Ȝ',\n  'ȟ' => 'Ȟ',\n  'ȣ' => 'Ȣ',\n  'ȥ' => 'Ȥ',\n  'ȧ' => 'Ȧ',\n  'ȩ' => 'Ȩ',\n  'ȫ' => 'Ȫ',\n  'ȭ' => 'Ȭ',\n  'ȯ' => 'Ȯ',\n  'ȱ' => 'Ȱ',\n  'ȳ' => 'Ȳ',\n  'ȼ' => 'Ȼ',\n  'ȿ' => 'Ȿ',\n  'ɀ' => 'Ɀ',\n  'ɂ' => 'Ɂ',\n  'ɇ' => 'Ɇ',\n  'ɉ' => 'Ɉ',\n  'ɋ' => 'Ɋ',\n  'ɍ' => 'Ɍ',\n  'ɏ' => 'Ɏ',\n  'ɐ' => 'Ɐ',\n  'ɑ' => 'Ɑ',\n  'ɒ' => 'Ɒ',\n  'ɓ' => 'Ɓ',\n  'ɔ' => 'Ɔ',\n  'ɖ' => 'Ɖ',\n  'ɗ' => 'Ɗ',\n  'ə' => 'Ə',\n  'ɛ' => 'Ɛ',\n  'ɜ' => 'Ɜ',\n  'ɠ' => 'Ɠ',\n  'ɡ' => 'Ɡ',\n  'ɣ' => 'Ɣ',\n  'ɥ' => 'Ɥ',\n  'ɦ' => 'Ɦ',\n  'ɨ' => 'Ɨ',\n  'ɩ' => 'Ɩ',\n  'ɪ' => 'Ɪ',\n  'ɫ' => 'Ɫ',\n  'ɬ' => 'Ɬ',\n  'ɯ' => 'Ɯ',\n  'ɱ' => 'Ɱ',\n  'ɲ' => 'Ɲ',\n  'ɵ' => 'Ɵ',\n  'ɽ' => 'Ɽ',\n  'ʀ' => 'Ʀ',\n  'ʂ' => 'Ʂ',\n  'ʃ' => 'Ʃ',\n  'ʇ' => 'Ʇ',\n  'ʈ' => 'Ʈ',\n  'ʉ' => 'Ʉ',\n  'ʊ' => 'Ʊ',\n  'ʋ' => 'Ʋ',\n  'ʌ' => 'Ʌ',\n  'ʒ' => 'Ʒ',\n  'ʝ' => 'Ʝ',\n  'ʞ' => 'Ʞ',\n  'ͅ' => 'Ι',\n  'ͱ' => 'Ͱ',\n  'ͳ' => 'Ͳ',\n  'ͷ' => 'Ͷ',\n  'ͻ' => 'Ͻ',\n  'ͼ' => 'Ͼ',\n  'ͽ' => 'Ͽ',\n  'ά' => 'Ά',\n  'έ' => 'Έ',\n  'ή' => 'Ή',\n  'ί' => 'Ί',\n  'α' => 'Α',\n  'β' => 'Β',\n  'γ' => 'Γ',\n  'δ' => 'Δ',\n  'ε' => 'Ε',\n  'ζ' => 'Ζ',\n  'η' => 'Η',\n  'θ' => 'Θ',\n  'ι' => 'Ι',\n  'κ' => 'Κ',\n  'λ' => 'Λ',\n  'μ' => 'Μ',\n  'ν' => 'Ν',\n  'ξ' => 'Ξ',\n  'ο' => 'Ο',\n  'π' => 'Π',\n  'ρ' => 'Ρ',\n  'ς' => 'Σ',\n  'σ' => 'Σ',\n  'τ' => 'Τ',\n  'υ' => 'Υ',\n  'φ' => 'Φ',\n  'χ' => 'Χ',\n  'ψ' => 'Ψ',\n  'ω' => 'Ω',\n  'ϊ' => 'Ϊ',\n  'ϋ' => 'Ϋ',\n  'ό' => 'Ό',\n  'ύ' => 'Ύ',\n  'ώ' => 'Ώ',\n  'ϐ' => 'Β',\n  'ϑ' => 'Θ',\n  'ϕ' => 'Φ',\n  'ϖ' => 'Π',\n  'ϗ' => 'Ϗ',\n  'ϙ' => 'Ϙ',\n  'ϛ' => 'Ϛ',\n  'ϝ' => 'Ϝ',\n  'ϟ' => 'Ϟ',\n  'ϡ' => 'Ϡ',\n  'ϣ' => 'Ϣ',\n  'ϥ' => 'Ϥ',\n  'ϧ' => 'Ϧ',\n  'ϩ' => 'Ϩ',\n  'ϫ' => 'Ϫ',\n  'ϭ' => 'Ϭ',\n  'ϯ' => 'Ϯ',\n  'ϰ' => 'Κ',\n  'ϱ' => 'Ρ',\n  'ϲ' => 'Ϲ',\n  'ϳ' => 'Ϳ',\n  'ϵ' => 'Ε',\n  'ϸ' => 'Ϸ',\n  'ϻ' => 'Ϻ',\n  'а' => 'А',\n  'б' => 'Б',\n  'в' => 'В',\n  'г' => 'Г',\n  'д' => 'Д',\n  'е' => 'Е',\n  'ж' => 'Ж',\n  'з' => 'З',\n  'и' => 'И',\n  'й' => 'Й',\n  'к' => 'К',\n  'л' => 'Л',\n  'м' => 'М',\n  'н' => 'Н',\n  'о' => 'О',\n  'п' => 'П',\n  'р' => 'Р',\n  'с' => 'С',\n  'т' => 'Т',\n  'у' => 'У',\n  'ф' => 'Ф',\n  'х' => 'Х',\n  'ц' => 'Ц',\n  'ч' => 'Ч',\n  'ш' => 'Ш',\n  'щ' => 'Щ',\n  'ъ' => 'Ъ',\n  'ы' => 'Ы',\n  'ь' => 'Ь',\n  'э' => 'Э',\n  'ю' => 'Ю',\n  'я' => 'Я',\n  'ѐ' => 'Ѐ',\n  'ё' => 'Ё',\n  'ђ' => 'Ђ',\n  'ѓ' => 'Ѓ',\n  'є' => 'Є',\n  'ѕ' => 'Ѕ',\n  'і' => 'І',\n  'ї' => 'Ї',\n  'ј' => 'Ј',\n  'љ' => 'Љ',\n  'њ' => 'Њ',\n  'ћ' => 'Ћ',\n  'ќ' => 'Ќ',\n  'ѝ' => 'Ѝ',\n  'ў' => 'Ў',\n  'џ' => 'Џ',\n  'ѡ' => 'Ѡ',\n  'ѣ' => 'Ѣ',\n  'ѥ' => 'Ѥ',\n  'ѧ' => 'Ѧ',\n  'ѩ' => 'Ѩ',\n  'ѫ' => 'Ѫ',\n  'ѭ' => 'Ѭ',\n  'ѯ' => 'Ѯ',\n  'ѱ' => 'Ѱ',\n  'ѳ' => 'Ѳ',\n  'ѵ' => 'Ѵ',\n  'ѷ' => 'Ѷ',\n  'ѹ' => 'Ѹ',\n  'ѻ' => 'Ѻ',\n  'ѽ' => 'Ѽ',\n  'ѿ' => 'Ѿ',\n  'ҁ' => 'Ҁ',\n  'ҋ' => 'Ҋ',\n  'ҍ' => 'Ҍ',\n  'ҏ' => 'Ҏ',\n  'ґ' => 'Ґ',\n  'ғ' => 'Ғ',\n  'ҕ' => 'Ҕ',\n  'җ' => 'Җ',\n  'ҙ' => 'Ҙ',\n  'қ' => 'Қ',\n  'ҝ' => 'Ҝ',\n  'ҟ' => 'Ҟ',\n  'ҡ' => 'Ҡ',\n  'ң' => 'Ң',\n  'ҥ' => 'Ҥ',\n  'ҧ' => 'Ҧ',\n  'ҩ' => 'Ҩ',\n  'ҫ' => 'Ҫ',\n  'ҭ' => 'Ҭ',\n  'ү' => 'Ү',\n  'ұ' => 'Ұ',\n  'ҳ' => 'Ҳ',\n  'ҵ' => 'Ҵ',\n  'ҷ' => 'Ҷ',\n  'ҹ' => 'Ҹ',\n  'һ' => 'Һ',\n  'ҽ' => 'Ҽ',\n  'ҿ' => 'Ҿ',\n  'ӂ' => 'Ӂ',\n  'ӄ' => 'Ӄ',\n  'ӆ' => 'Ӆ',\n  'ӈ' => 'Ӈ',\n  'ӊ' => 'Ӊ',\n  'ӌ' => 'Ӌ',\n  'ӎ' => 'Ӎ',\n  'ӏ' => 'Ӏ',\n  'ӑ' => 'Ӑ',\n  'ӓ' => 'Ӓ',\n  'ӕ' => 'Ӕ',\n  'ӗ' => 'Ӗ',\n  'ә' => 'Ә',\n  'ӛ' => 'Ӛ',\n  'ӝ' => 'Ӝ',\n  'ӟ' => 'Ӟ',\n  'ӡ' => 'Ӡ',\n  'ӣ' => 'Ӣ',\n  'ӥ' => 'Ӥ',\n  'ӧ' => 'Ӧ',\n  'ө' => 'Ө',\n  'ӫ' => 'Ӫ',\n  'ӭ' => 'Ӭ',\n  'ӯ' => 'Ӯ',\n  'ӱ' => 'Ӱ',\n  'ӳ' => 'Ӳ',\n  'ӵ' => 'Ӵ',\n  'ӷ' => 'Ӷ',\n  'ӹ' => 'Ӹ',\n  'ӻ' => 'Ӻ',\n  'ӽ' => 'Ӽ',\n  'ӿ' => 'Ӿ',\n  'ԁ' => 'Ԁ',\n  'ԃ' => 'Ԃ',\n  'ԅ' => 'Ԅ',\n  'ԇ' => 'Ԇ',\n  'ԉ' => 'Ԉ',\n  'ԋ' => 'Ԋ',\n  'ԍ' => 'Ԍ',\n  'ԏ' => 'Ԏ',\n  'ԑ' => 'Ԑ',\n  'ԓ' => 'Ԓ',\n  'ԕ' => 'Ԕ',\n  'ԗ' => 'Ԗ',\n  'ԙ' => 'Ԙ',\n  'ԛ' => 'Ԛ',\n  'ԝ' => 'Ԝ',\n  'ԟ' => 'Ԟ',\n  'ԡ' => 'Ԡ',\n  'ԣ' => 'Ԣ',\n  'ԥ' => 'Ԥ',\n  'ԧ' => 'Ԧ',\n  'ԩ' => 'Ԩ',\n  'ԫ' => 'Ԫ',\n  'ԭ' => 'Ԭ',\n  'ԯ' => 'Ԯ',\n  'ա' => 'Ա',\n  'բ' => 'Բ',\n  'գ' => 'Գ',\n  'դ' => 'Դ',\n  'ե' => 'Ե',\n  'զ' => 'Զ',\n  'է' => 'Է',\n  'ը' => 'Ը',\n  'թ' => 'Թ',\n  'ժ' => 'Ժ',\n  'ի' => 'Ի',\n  'լ' => 'Լ',\n  'խ' => 'Խ',\n  'ծ' => 'Ծ',\n  'կ' => 'Կ',\n  'հ' => 'Հ',\n  'ձ' => 'Ձ',\n  'ղ' => 'Ղ',\n  'ճ' => 'Ճ',\n  'մ' => 'Մ',\n  'յ' => 'Յ',\n  'ն' => 'Ն',\n  'շ' => 'Շ',\n  'ո' => 'Ո',\n  'չ' => 'Չ',\n  'պ' => 'Պ',\n  'ջ' => 'Ջ',\n  'ռ' => 'Ռ',\n  'ս' => 'Ս',\n  'վ' => 'Վ',\n  'տ' => 'Տ',\n  'ր' => 'Ր',\n  'ց' => 'Ց',\n  'ւ' => 'Ւ',\n  'փ' => 'Փ',\n  'ք' => 'Ք',\n  'օ' => 'Օ',\n  'ֆ' => 'Ֆ',\n  'ა' => 'Ა',\n  'ბ' => 'Ბ',\n  'გ' => 'Გ',\n  'დ' => 'Დ',\n  'ე' => 'Ე',\n  'ვ' => 'Ვ',\n  'ზ' => 'Ზ',\n  'თ' => 'Თ',\n  'ი' => 'Ი',\n  'კ' => 'Კ',\n  'ლ' => 'Ლ',\n  'მ' => 'Მ',\n  'ნ' => 'Ნ',\n  'ო' => 'Ო',\n  'პ' => 'Პ',\n  'ჟ' => 'Ჟ',\n  'რ' => 'Რ',\n  'ს' => 'Ს',\n  'ტ' => 'Ტ',\n  'უ' => 'Უ',\n  'ფ' => 'Ფ',\n  'ქ' => 'Ქ',\n  'ღ' => 'Ღ',\n  'ყ' => 'Ყ',\n  'შ' => 'Შ',\n  'ჩ' => 'Ჩ',\n  'ც' => 'Ც',\n  'ძ' => 'Ძ',\n  'წ' => 'Წ',\n  'ჭ' => 'Ჭ',\n  'ხ' => 'Ხ',\n  'ჯ' => 'Ჯ',\n  'ჰ' => 'Ჰ',\n  'ჱ' => 'Ჱ',\n  'ჲ' => 'Ჲ',\n  'ჳ' => 'Ჳ',\n  'ჴ' => 'Ჴ',\n  'ჵ' => 'Ჵ',\n  'ჶ' => 'Ჶ',\n  'ჷ' => 'Ჷ',\n  'ჸ' => 'Ჸ',\n  'ჹ' => 'Ჹ',\n  'ჺ' => 'Ჺ',\n  'ჽ' => 'Ჽ',\n  'ჾ' => 'Ჾ',\n  'ჿ' => 'Ჿ',\n  'ᏸ' => 'Ᏸ',\n  'ᏹ' => 'Ᏹ',\n  'ᏺ' => 'Ᏺ',\n  'ᏻ' => 'Ᏻ',\n  'ᏼ' => 'Ᏼ',\n  'ᏽ' => 'Ᏽ',\n  'ᲀ' => 'В',\n  'ᲁ' => 'Д',\n  'ᲂ' => 'О',\n  'ᲃ' => 'С',\n  'ᲄ' => 'Т',\n  'ᲅ' => 'Т',\n  'ᲆ' => 'Ъ',\n  'ᲇ' => 'Ѣ',\n  'ᲈ' => 'Ꙋ',\n  'ᵹ' => 'Ᵹ',\n  'ᵽ' => 'Ᵽ',\n  'ᶎ' => 'Ᶎ',\n  'ḁ' => 'Ḁ',\n  'ḃ' => 'Ḃ',\n  'ḅ' => 'Ḅ',\n  'ḇ' => 'Ḇ',\n  'ḉ' => 'Ḉ',\n  'ḋ' => 'Ḋ',\n  'ḍ' => 'Ḍ',\n  'ḏ' => 'Ḏ',\n  'ḑ' => 'Ḑ',\n  'ḓ' => 'Ḓ',\n  'ḕ' => 'Ḕ',\n  'ḗ' => 'Ḗ',\n  'ḙ' => 'Ḙ',\n  'ḛ' => 'Ḛ',\n  'ḝ' => 'Ḝ',\n  'ḟ' => 'Ḟ',\n  'ḡ' => 'Ḡ',\n  'ḣ' => 'Ḣ',\n  'ḥ' => 'Ḥ',\n  'ḧ' => 'Ḧ',\n  'ḩ' => 'Ḩ',\n  'ḫ' => 'Ḫ',\n  'ḭ' => 'Ḭ',\n  'ḯ' => 'Ḯ',\n  'ḱ' => 'Ḱ',\n  'ḳ' => 'Ḳ',\n  'ḵ' => 'Ḵ',\n  'ḷ' => 'Ḷ',\n  'ḹ' => 'Ḹ',\n  'ḻ' => 'Ḻ',\n  'ḽ' => 'Ḽ',\n  'ḿ' => 'Ḿ',\n  'ṁ' => 'Ṁ',\n  'ṃ' => 'Ṃ',\n  'ṅ' => 'Ṅ',\n  'ṇ' => 'Ṇ',\n  'ṉ' => 'Ṉ',\n  'ṋ' => 'Ṋ',\n  'ṍ' => 'Ṍ',\n  'ṏ' => 'Ṏ',\n  'ṑ' => 'Ṑ',\n  'ṓ' => 'Ṓ',\n  'ṕ' => 'Ṕ',\n  'ṗ' => 'Ṗ',\n  'ṙ' => 'Ṙ',\n  'ṛ' => 'Ṛ',\n  'ṝ' => 'Ṝ',\n  'ṟ' => 'Ṟ',\n  'ṡ' => 'Ṡ',\n  'ṣ' => 'Ṣ',\n  'ṥ' => 'Ṥ',\n  'ṧ' => 'Ṧ',\n  'ṩ' => 'Ṩ',\n  'ṫ' => 'Ṫ',\n  'ṭ' => 'Ṭ',\n  'ṯ' => 'Ṯ',\n  'ṱ' => 'Ṱ',\n  'ṳ' => 'Ṳ',\n  'ṵ' => 'Ṵ',\n  'ṷ' => 'Ṷ',\n  'ṹ' => 'Ṹ',\n  'ṻ' => 'Ṻ',\n  'ṽ' => 'Ṽ',\n  'ṿ' => 'Ṿ',\n  'ẁ' => 'Ẁ',\n  'ẃ' => 'Ẃ',\n  'ẅ' => 'Ẅ',\n  'ẇ' => 'Ẇ',\n  'ẉ' => 'Ẉ',\n  'ẋ' => 'Ẋ',\n  'ẍ' => 'Ẍ',\n  'ẏ' => 'Ẏ',\n  'ẑ' => 'Ẑ',\n  'ẓ' => 'Ẓ',\n  'ẕ' => 'Ẕ',\n  'ẛ' => 'Ṡ',\n  'ạ' => 'Ạ',\n  'ả' => 'Ả',\n  'ấ' => 'Ấ',\n  'ầ' => 'Ầ',\n  'ẩ' => 'Ẩ',\n  'ẫ' => 'Ẫ',\n  'ậ' => 'Ậ',\n  'ắ' => 'Ắ',\n  'ằ' => 'Ằ',\n  'ẳ' => 'Ẳ',\n  'ẵ' => 'Ẵ',\n  'ặ' => 'Ặ',\n  'ẹ' => 'Ẹ',\n  'ẻ' => 'Ẻ',\n  'ẽ' => 'Ẽ',\n  'ế' => 'Ế',\n  'ề' => 'Ề',\n  'ể' => 'Ể',\n  'ễ' => 'Ễ',\n  'ệ' => 'Ệ',\n  'ỉ' => 'Ỉ',\n  'ị' => 'Ị',\n  'ọ' => 'Ọ',\n  'ỏ' => 'Ỏ',\n  'ố' => 'Ố',\n  'ồ' => 'Ồ',\n  'ổ' => 'Ổ',\n  'ỗ' => 'Ỗ',\n  'ộ' => 'Ộ',\n  'ớ' => 'Ớ',\n  'ờ' => 'Ờ',\n  'ở' => 'Ở',\n  'ỡ' => 'Ỡ',\n  'ợ' => 'Ợ',\n  'ụ' => 'Ụ',\n  'ủ' => 'Ủ',\n  'ứ' => 'Ứ',\n  'ừ' => 'Ừ',\n  'ử' => 'Ử',\n  'ữ' => 'Ữ',\n  'ự' => 'Ự',\n  'ỳ' => 'Ỳ',\n  'ỵ' => 'Ỵ',\n  'ỷ' => 'Ỷ',\n  'ỹ' => 'Ỹ',\n  'ỻ' => 'Ỻ',\n  'ỽ' => 'Ỽ',\n  'ỿ' => 'Ỿ',\n  'ἀ' => 'Ἀ',\n  'ἁ' => 'Ἁ',\n  'ἂ' => 'Ἂ',\n  'ἃ' => 'Ἃ',\n  'ἄ' => 'Ἄ',\n  'ἅ' => 'Ἅ',\n  'ἆ' => 'Ἆ',\n  'ἇ' => 'Ἇ',\n  'ἐ' => 'Ἐ',\n  'ἑ' => 'Ἑ',\n  'ἒ' => 'Ἒ',\n  'ἓ' => 'Ἓ',\n  'ἔ' => 'Ἔ',\n  'ἕ' => 'Ἕ',\n  'ἠ' => 'Ἠ',\n  'ἡ' => 'Ἡ',\n  'ἢ' => 'Ἢ',\n  'ἣ' => 'Ἣ',\n  'ἤ' => 'Ἤ',\n  'ἥ' => 'Ἥ',\n  'ἦ' => 'Ἦ',\n  'ἧ' => 'Ἧ',\n  'ἰ' => 'Ἰ',\n  'ἱ' => 'Ἱ',\n  'ἲ' => 'Ἲ',\n  'ἳ' => 'Ἳ',\n  'ἴ' => 'Ἴ',\n  'ἵ' => 'Ἵ',\n  'ἶ' => 'Ἶ',\n  'ἷ' => 'Ἷ',\n  'ὀ' => 'Ὀ',\n  'ὁ' => 'Ὁ',\n  'ὂ' => 'Ὂ',\n  'ὃ' => 'Ὃ',\n  'ὄ' => 'Ὄ',\n  'ὅ' => 'Ὅ',\n  'ὑ' => 'Ὑ',\n  'ὓ' => 'Ὓ',\n  'ὕ' => 'Ὕ',\n  'ὗ' => 'Ὗ',\n  'ὠ' => 'Ὠ',\n  'ὡ' => 'Ὡ',\n  'ὢ' => 'Ὢ',\n  'ὣ' => 'Ὣ',\n  'ὤ' => 'Ὤ',\n  'ὥ' => 'Ὥ',\n  'ὦ' => 'Ὦ',\n  'ὧ' => 'Ὧ',\n  'ὰ' => 'Ὰ',\n  'ά' => 'Ά',\n  'ὲ' => 'Ὲ',\n  'έ' => 'Έ',\n  'ὴ' => 'Ὴ',\n  'ή' => 'Ή',\n  'ὶ' => 'Ὶ',\n  'ί' => 'Ί',\n  'ὸ' => 'Ὸ',\n  'ό' => 'Ό',\n  'ὺ' => 'Ὺ',\n  'ύ' => 'Ύ',\n  'ὼ' => 'Ὼ',\n  'ώ' => 'Ώ',\n  'ᾀ' => 'ᾈ',\n  'ᾁ' => 'ᾉ',\n  'ᾂ' => 'ᾊ',\n  'ᾃ' => 'ᾋ',\n  'ᾄ' => 'ᾌ',\n  'ᾅ' => 'ᾍ',\n  'ᾆ' => 'ᾎ',\n  'ᾇ' => 'ᾏ',\n  'ᾐ' => 'ᾘ',\n  'ᾑ' => 'ᾙ',\n  'ᾒ' => 'ᾚ',\n  'ᾓ' => 'ᾛ',\n  'ᾔ' => 'ᾜ',\n  'ᾕ' => 'ᾝ',\n  'ᾖ' => 'ᾞ',\n  'ᾗ' => 'ᾟ',\n  'ᾠ' => 'ᾨ',\n  'ᾡ' => 'ᾩ',\n  'ᾢ' => 'ᾪ',\n  'ᾣ' => 'ᾫ',\n  'ᾤ' => 'ᾬ',\n  'ᾥ' => 'ᾭ',\n  'ᾦ' => 'ᾮ',\n  'ᾧ' => 'ᾯ',\n  'ᾰ' => 'Ᾰ',\n  'ᾱ' => 'Ᾱ',\n  'ᾳ' => 'ᾼ',\n  'ι' => 'Ι',\n  'ῃ' => 'ῌ',\n  'ῐ' => 'Ῐ',\n  'ῑ' => 'Ῑ',\n  'ῠ' => 'Ῠ',\n  'ῡ' => 'Ῡ',\n  'ῥ' => 'Ῥ',\n  'ῳ' => 'ῼ',\n  'ⅎ' => 'Ⅎ',\n  'ⅰ' => 'Ⅰ',\n  'ⅱ' => 'Ⅱ',\n  'ⅲ' => 'Ⅲ',\n  'ⅳ' => 'Ⅳ',\n  'ⅴ' => 'Ⅴ',\n  'ⅵ' => 'Ⅵ',\n  'ⅶ' => 'Ⅶ',\n  'ⅷ' => 'Ⅷ',\n  'ⅸ' => 'Ⅸ',\n  'ⅹ' => 'Ⅹ',\n  'ⅺ' => 'Ⅺ',\n  'ⅻ' => 'Ⅻ',\n  'ⅼ' => 'Ⅼ',\n  'ⅽ' => 'Ⅽ',\n  'ⅾ' => 'Ⅾ',\n  'ⅿ' => 'Ⅿ',\n  'ↄ' => 'Ↄ',\n  'ⓐ' => 'Ⓐ',\n  'ⓑ' => 'Ⓑ',\n  'ⓒ' => 'Ⓒ',\n  'ⓓ' => 'Ⓓ',\n  'ⓔ' => 'Ⓔ',\n  'ⓕ' => 'Ⓕ',\n  'ⓖ' => 'Ⓖ',\n  'ⓗ' => 'Ⓗ',\n  'ⓘ' => 'Ⓘ',\n  'ⓙ' => 'Ⓙ',\n  'ⓚ' => 'Ⓚ',\n  'ⓛ' => 'Ⓛ',\n  'ⓜ' => 'Ⓜ',\n  'ⓝ' => 'Ⓝ',\n  'ⓞ' => 'Ⓞ',\n  'ⓟ' => 'Ⓟ',\n  'ⓠ' => 'Ⓠ',\n  'ⓡ' => 'Ⓡ',\n  'ⓢ' => 'Ⓢ',\n  'ⓣ' => 'Ⓣ',\n  'ⓤ' => 'Ⓤ',\n  'ⓥ' => 'Ⓥ',\n  'ⓦ' => 'Ⓦ',\n  'ⓧ' => 'Ⓧ',\n  'ⓨ' => 'Ⓨ',\n  'ⓩ' => 'Ⓩ',\n  'ⰰ' => 'Ⰰ',\n  'ⰱ' => 'Ⰱ',\n  'ⰲ' => 'Ⰲ',\n  'ⰳ' => 'Ⰳ',\n  'ⰴ' => 'Ⰴ',\n  'ⰵ' => 'Ⰵ',\n  'ⰶ' => 'Ⰶ',\n  'ⰷ' => 'Ⰷ',\n  'ⰸ' => 'Ⰸ',\n  'ⰹ' => 'Ⰹ',\n  'ⰺ' => 'Ⰺ',\n  'ⰻ' => 'Ⰻ',\n  'ⰼ' => 'Ⰼ',\n  'ⰽ' => 'Ⰽ',\n  'ⰾ' => 'Ⰾ',\n  'ⰿ' => 'Ⰿ',\n  'ⱀ' => 'Ⱀ',\n  'ⱁ' => 'Ⱁ',\n  'ⱂ' => 'Ⱂ',\n  'ⱃ' => 'Ⱃ',\n  'ⱄ' => 'Ⱄ',\n  'ⱅ' => 'Ⱅ',\n  'ⱆ' => 'Ⱆ',\n  'ⱇ' => 'Ⱇ',\n  'ⱈ' => 'Ⱈ',\n  'ⱉ' => 'Ⱉ',\n  'ⱊ' => 'Ⱊ',\n  'ⱋ' => 'Ⱋ',\n  'ⱌ' => 'Ⱌ',\n  'ⱍ' => 'Ⱍ',\n  'ⱎ' => 'Ⱎ',\n  'ⱏ' => 'Ⱏ',\n  'ⱐ' => 'Ⱐ',\n  'ⱑ' => 'Ⱑ',\n  'ⱒ' => 'Ⱒ',\n  'ⱓ' => 'Ⱓ',\n  'ⱔ' => 'Ⱔ',\n  'ⱕ' => 'Ⱕ',\n  'ⱖ' => 'Ⱖ',\n  'ⱗ' => 'Ⱗ',\n  'ⱘ' => 'Ⱘ',\n  'ⱙ' => 'Ⱙ',\n  'ⱚ' => 'Ⱚ',\n  'ⱛ' => 'Ⱛ',\n  'ⱜ' => 'Ⱜ',\n  'ⱝ' => 'Ⱝ',\n  'ⱞ' => 'Ⱞ',\n  'ⱡ' => 'Ⱡ',\n  'ⱥ' => 'Ⱥ',\n  'ⱦ' => 'Ⱦ',\n  'ⱨ' => 'Ⱨ',\n  'ⱪ' => 'Ⱪ',\n  'ⱬ' => 'Ⱬ',\n  'ⱳ' => 'Ⱳ',\n  'ⱶ' => 'Ⱶ',\n  'ⲁ' => 'Ⲁ',\n  'ⲃ' => 'Ⲃ',\n  'ⲅ' => 'Ⲅ',\n  'ⲇ' => 'Ⲇ',\n  'ⲉ' => 'Ⲉ',\n  'ⲋ' => 'Ⲋ',\n  'ⲍ' => 'Ⲍ',\n  'ⲏ' => 'Ⲏ',\n  'ⲑ' => 'Ⲑ',\n  'ⲓ' => 'Ⲓ',\n  'ⲕ' => 'Ⲕ',\n  'ⲗ' => 'Ⲗ',\n  'ⲙ' => 'Ⲙ',\n  'ⲛ' => 'Ⲛ',\n  'ⲝ' => 'Ⲝ',\n  'ⲟ' => 'Ⲟ',\n  'ⲡ' => 'Ⲡ',\n  'ⲣ' => 'Ⲣ',\n  'ⲥ' => 'Ⲥ',\n  'ⲧ' => 'Ⲧ',\n  'ⲩ' => 'Ⲩ',\n  'ⲫ' => 'Ⲫ',\n  'ⲭ' => 'Ⲭ',\n  'ⲯ' => 'Ⲯ',\n  'ⲱ' => 'Ⲱ',\n  'ⲳ' => 'Ⲳ',\n  'ⲵ' => 'Ⲵ',\n  'ⲷ' => 'Ⲷ',\n  'ⲹ' => 'Ⲹ',\n  'ⲻ' => 'Ⲻ',\n  'ⲽ' => 'Ⲽ',\n  'ⲿ' => 'Ⲿ',\n  'ⳁ' => 'Ⳁ',\n  'ⳃ' => 'Ⳃ',\n  'ⳅ' => 'Ⳅ',\n  'ⳇ' => 'Ⳇ',\n  'ⳉ' => 'Ⳉ',\n  'ⳋ' => 'Ⳋ',\n  'ⳍ' => 'Ⳍ',\n  'ⳏ' => 'Ⳏ',\n  'ⳑ' => 'Ⳑ',\n  'ⳓ' => 'Ⳓ',\n  'ⳕ' => 'Ⳕ',\n  'ⳗ' => 'Ⳗ',\n  'ⳙ' => 'Ⳙ',\n  'ⳛ' => 'Ⳛ',\n  'ⳝ' => 'Ⳝ',\n  'ⳟ' => 'Ⳟ',\n  'ⳡ' => 'Ⳡ',\n  'ⳣ' => 'Ⳣ',\n  'ⳬ' => 'Ⳬ',\n  'ⳮ' => 'Ⳮ',\n  'ⳳ' => 'Ⳳ',\n  'ⴀ' => 'Ⴀ',\n  'ⴁ' => 'Ⴁ',\n  'ⴂ' => 'Ⴂ',\n  'ⴃ' => 'Ⴃ',\n  'ⴄ' => 'Ⴄ',\n  'ⴅ' => 'Ⴅ',\n  'ⴆ' => 'Ⴆ',\n  'ⴇ' => 'Ⴇ',\n  'ⴈ' => 'Ⴈ',\n  'ⴉ' => 'Ⴉ',\n  'ⴊ' => 'Ⴊ',\n  'ⴋ' => 'Ⴋ',\n  'ⴌ' => 'Ⴌ',\n  'ⴍ' => 'Ⴍ',\n  'ⴎ' => 'Ⴎ',\n  'ⴏ' => 'Ⴏ',\n  'ⴐ' => 'Ⴐ',\n  'ⴑ' => 'Ⴑ',\n  'ⴒ' => 'Ⴒ',\n  'ⴓ' => 'Ⴓ',\n  'ⴔ' => 'Ⴔ',\n  'ⴕ' => 'Ⴕ',\n  'ⴖ' => 'Ⴖ',\n  'ⴗ' => 'Ⴗ',\n  'ⴘ' => 'Ⴘ',\n  'ⴙ' => 'Ⴙ',\n  'ⴚ' => 'Ⴚ',\n  'ⴛ' => 'Ⴛ',\n  'ⴜ' => 'Ⴜ',\n  'ⴝ' => 'Ⴝ',\n  'ⴞ' => 'Ⴞ',\n  'ⴟ' => 'Ⴟ',\n  'ⴠ' => 'Ⴠ',\n  'ⴡ' => 'Ⴡ',\n  'ⴢ' => 'Ⴢ',\n  'ⴣ' => 'Ⴣ',\n  'ⴤ' => 'Ⴤ',\n  'ⴥ' => 'Ⴥ',\n  'ⴧ' => 'Ⴧ',\n  'ⴭ' => 'Ⴭ',\n  'ꙁ' => 'Ꙁ',\n  'ꙃ' => 'Ꙃ',\n  'ꙅ' => 'Ꙅ',\n  'ꙇ' => 'Ꙇ',\n  'ꙉ' => 'Ꙉ',\n  'ꙋ' => 'Ꙋ',\n  'ꙍ' => 'Ꙍ',\n  'ꙏ' => 'Ꙏ',\n  'ꙑ' => 'Ꙑ',\n  'ꙓ' => 'Ꙓ',\n  'ꙕ' => 'Ꙕ',\n  'ꙗ' => 'Ꙗ',\n  'ꙙ' => 'Ꙙ',\n  'ꙛ' => 'Ꙛ',\n  'ꙝ' => 'Ꙝ',\n  'ꙟ' => 'Ꙟ',\n  'ꙡ' => 'Ꙡ',\n  'ꙣ' => 'Ꙣ',\n  'ꙥ' => 'Ꙥ',\n  'ꙧ' => 'Ꙧ',\n  'ꙩ' => 'Ꙩ',\n  'ꙫ' => 'Ꙫ',\n  'ꙭ' => 'Ꙭ',\n  'ꚁ' => 'Ꚁ',\n  'ꚃ' => 'Ꚃ',\n  'ꚅ' => 'Ꚅ',\n  'ꚇ' => 'Ꚇ',\n  'ꚉ' => 'Ꚉ',\n  'ꚋ' => 'Ꚋ',\n  'ꚍ' => 'Ꚍ',\n  'ꚏ' => 'Ꚏ',\n  'ꚑ' => 'Ꚑ',\n  'ꚓ' => 'Ꚓ',\n  'ꚕ' => 'Ꚕ',\n  'ꚗ' => 'Ꚗ',\n  'ꚙ' => 'Ꚙ',\n  'ꚛ' => 'Ꚛ',\n  'ꜣ' => 'Ꜣ',\n  'ꜥ' => 'Ꜥ',\n  'ꜧ' => 'Ꜧ',\n  'ꜩ' => 'Ꜩ',\n  'ꜫ' => 'Ꜫ',\n  'ꜭ' => 'Ꜭ',\n  'ꜯ' => 'Ꜯ',\n  'ꜳ' => 'Ꜳ',\n  'ꜵ' => 'Ꜵ',\n  'ꜷ' => 'Ꜷ',\n  'ꜹ' => 'Ꜹ',\n  'ꜻ' => 'Ꜻ',\n  'ꜽ' => 'Ꜽ',\n  'ꜿ' => 'Ꜿ',\n  'ꝁ' => 'Ꝁ',\n  'ꝃ' => 'Ꝃ',\n  'ꝅ' => 'Ꝅ',\n  'ꝇ' => 'Ꝇ',\n  'ꝉ' => 'Ꝉ',\n  'ꝋ' => 'Ꝋ',\n  'ꝍ' => 'Ꝍ',\n  'ꝏ' => 'Ꝏ',\n  'ꝑ' => 'Ꝑ',\n  'ꝓ' => 'Ꝓ',\n  'ꝕ' => 'Ꝕ',\n  'ꝗ' => 'Ꝗ',\n  'ꝙ' => 'Ꝙ',\n  'ꝛ' => 'Ꝛ',\n  'ꝝ' => 'Ꝝ',\n  'ꝟ' => 'Ꝟ',\n  'ꝡ' => 'Ꝡ',\n  'ꝣ' => 'Ꝣ',\n  'ꝥ' => 'Ꝥ',\n  'ꝧ' => 'Ꝧ',\n  'ꝩ' => 'Ꝩ',\n  'ꝫ' => 'Ꝫ',\n  'ꝭ' => 'Ꝭ',\n  'ꝯ' => 'Ꝯ',\n  'ꝺ' => 'Ꝺ',\n  'ꝼ' => 'Ꝼ',\n  'ꝿ' => 'Ꝿ',\n  'ꞁ' => 'Ꞁ',\n  'ꞃ' => 'Ꞃ',\n  'ꞅ' => 'Ꞅ',\n  'ꞇ' => 'Ꞇ',\n  'ꞌ' => 'Ꞌ',\n  'ꞑ' => 'Ꞑ',\n  'ꞓ' => 'Ꞓ',\n  'ꞔ' => 'Ꞔ',\n  'ꞗ' => 'Ꞗ',\n  'ꞙ' => 'Ꞙ',\n  'ꞛ' => 'Ꞛ',\n  'ꞝ' => 'Ꞝ',\n  'ꞟ' => 'Ꞟ',\n  'ꞡ' => 'Ꞡ',\n  'ꞣ' => 'Ꞣ',\n  'ꞥ' => 'Ꞥ',\n  'ꞧ' => 'Ꞧ',\n  'ꞩ' => 'Ꞩ',\n  'ꞵ' => 'Ꞵ',\n  'ꞷ' => 'Ꞷ',\n  'ꞹ' => 'Ꞹ',\n  'ꞻ' => 'Ꞻ',\n  'ꞽ' => 'Ꞽ',\n  'ꞿ' => 'Ꞿ',\n  'ꟃ' => 'Ꟃ',\n  'ꟈ' => 'Ꟈ',\n  'ꟊ' => 'Ꟊ',\n  'ꟶ' => 'Ꟶ',\n  'ꭓ' => 'Ꭓ',\n  'ꭰ' => 'Ꭰ',\n  'ꭱ' => 'Ꭱ',\n  'ꭲ' => 'Ꭲ',\n  'ꭳ' => 'Ꭳ',\n  'ꭴ' => 'Ꭴ',\n  'ꭵ' => 'Ꭵ',\n  'ꭶ' => 'Ꭶ',\n  'ꭷ' => 'Ꭷ',\n  'ꭸ' => 'Ꭸ',\n  'ꭹ' => 'Ꭹ',\n  'ꭺ' => 'Ꭺ',\n  'ꭻ' => 'Ꭻ',\n  'ꭼ' => 'Ꭼ',\n  'ꭽ' => 'Ꭽ',\n  'ꭾ' => 'Ꭾ',\n  'ꭿ' => 'Ꭿ',\n  'ꮀ' => 'Ꮀ',\n  'ꮁ' => 'Ꮁ',\n  'ꮂ' => 'Ꮂ',\n  'ꮃ' => 'Ꮃ',\n  'ꮄ' => 'Ꮄ',\n  'ꮅ' => 'Ꮅ',\n  'ꮆ' => 'Ꮆ',\n  'ꮇ' => 'Ꮇ',\n  'ꮈ' => 'Ꮈ',\n  'ꮉ' => 'Ꮉ',\n  'ꮊ' => 'Ꮊ',\n  'ꮋ' => 'Ꮋ',\n  'ꮌ' => 'Ꮌ',\n  'ꮍ' => 'Ꮍ',\n  'ꮎ' => 'Ꮎ',\n  'ꮏ' => 'Ꮏ',\n  'ꮐ' => 'Ꮐ',\n  'ꮑ' => 'Ꮑ',\n  'ꮒ' => 'Ꮒ',\n  'ꮓ' => 'Ꮓ',\n  'ꮔ' => 'Ꮔ',\n  'ꮕ' => 'Ꮕ',\n  'ꮖ' => 'Ꮖ',\n  'ꮗ' => 'Ꮗ',\n  'ꮘ' => 'Ꮘ',\n  'ꮙ' => 'Ꮙ',\n  'ꮚ' => 'Ꮚ',\n  'ꮛ' => 'Ꮛ',\n  'ꮜ' => 'Ꮜ',\n  'ꮝ' => 'Ꮝ',\n  'ꮞ' => 'Ꮞ',\n  'ꮟ' => 'Ꮟ',\n  'ꮠ' => 'Ꮠ',\n  'ꮡ' => 'Ꮡ',\n  'ꮢ' => 'Ꮢ',\n  'ꮣ' => 'Ꮣ',\n  'ꮤ' => 'Ꮤ',\n  'ꮥ' => 'Ꮥ',\n  'ꮦ' => 'Ꮦ',\n  'ꮧ' => 'Ꮧ',\n  'ꮨ' => 'Ꮨ',\n  'ꮩ' => 'Ꮩ',\n  'ꮪ' => 'Ꮪ',\n  'ꮫ' => 'Ꮫ',\n  'ꮬ' => 'Ꮬ',\n  'ꮭ' => 'Ꮭ',\n  'ꮮ' => 'Ꮮ',\n  'ꮯ' => 'Ꮯ',\n  'ꮰ' => 'Ꮰ',\n  'ꮱ' => 'Ꮱ',\n  'ꮲ' => 'Ꮲ',\n  'ꮳ' => 'Ꮳ',\n  'ꮴ' => 'Ꮴ',\n  'ꮵ' => 'Ꮵ',\n  'ꮶ' => 'Ꮶ',\n  'ꮷ' => 'Ꮷ',\n  'ꮸ' => 'Ꮸ',\n  'ꮹ' => 'Ꮹ',\n  'ꮺ' => 'Ꮺ',\n  'ꮻ' => 'Ꮻ',\n  'ꮼ' => 'Ꮼ',\n  'ꮽ' => 'Ꮽ',\n  'ꮾ' => 'Ꮾ',\n  'ꮿ' => 'Ꮿ',\n  'ａ' => 'Ａ',\n  'ｂ' => 'Ｂ',\n  'ｃ' => 'Ｃ',\n  'ｄ' => 'Ｄ',\n  'ｅ' => 'Ｅ',\n  'ｆ' => 'Ｆ',\n  'ｇ' => 'Ｇ',\n  'ｈ' => 'Ｈ',\n  'ｉ' => 'Ｉ',\n  'ｊ' => 'Ｊ',\n  'ｋ' => 'Ｋ',\n  'ｌ' => 'Ｌ',\n  'ｍ' => 'Ｍ',\n  'ｎ' => 'Ｎ',\n  'ｏ' => 'Ｏ',\n  'ｐ' => 'Ｐ',\n  'ｑ' => 'Ｑ',\n  'ｒ' => 'Ｒ',\n  'ｓ' => 'Ｓ',\n  'ｔ' => 'Ｔ',\n  'ｕ' => 'Ｕ',\n  'ｖ' => 'Ｖ',\n  'ｗ' => 'Ｗ',\n  'ｘ' => 'Ｘ',\n  'ｙ' => 'Ｙ',\n  'ｚ' => 'Ｚ',\n  '𐐨' => '𐐀',\n  '𐐩' => '𐐁',\n  '𐐪' => '𐐂',\n  '𐐫' => '𐐃',\n  '𐐬' => '𐐄',\n  '𐐭' => '𐐅',\n  '𐐮' => '𐐆',\n  '𐐯' => '𐐇',\n  '𐐰' => '𐐈',\n  '𐐱' => '𐐉',\n  '𐐲' => '𐐊',\n  '𐐳' => '𐐋',\n  '𐐴' => '𐐌',\n  '𐐵' => '𐐍',\n  '𐐶' => '𐐎',\n  '𐐷' => '𐐏',\n  '𐐸' => '𐐐',\n  '𐐹' => '𐐑',\n  '𐐺' => '𐐒',\n  '𐐻' => '𐐓',\n  '𐐼' => '𐐔',\n  '𐐽' => '𐐕',\n  '𐐾' => '𐐖',\n  '𐐿' => '𐐗',\n  '𐑀' => '𐐘',\n  '𐑁' => '𐐙',\n  '𐑂' => '𐐚',\n  '𐑃' => '𐐛',\n  '𐑄' => '𐐜',\n  '𐑅' => '𐐝',\n  '𐑆' => '𐐞',\n  '𐑇' => '𐐟',\n  '𐑈' => '𐐠',\n  '𐑉' => '𐐡',\n  '𐑊' => '𐐢',\n  '𐑋' => '𐐣',\n  '𐑌' => '𐐤',\n  '𐑍' => '𐐥',\n  '𐑎' => '𐐦',\n  '𐑏' => '𐐧',\n  '𐓘' => '𐒰',\n  '𐓙' => '𐒱',\n  '𐓚' => '𐒲',\n  '𐓛' => '𐒳',\n  '𐓜' => '𐒴',\n  '𐓝' => '𐒵',\n  '𐓞' => '𐒶',\n  '𐓟' => '𐒷',\n  '𐓠' => '𐒸',\n  '𐓡' => '𐒹',\n  '𐓢' => '𐒺',\n  '𐓣' => '𐒻',\n  '𐓤' => '𐒼',\n  '𐓥' => '𐒽',\n  '𐓦' => '𐒾',\n  '𐓧' => '𐒿',\n  '𐓨' => '𐓀',\n  '𐓩' => '𐓁',\n  '𐓪' => '𐓂',\n  '𐓫' => '𐓃',\n  '𐓬' => '𐓄',\n  '𐓭' => '𐓅',\n  '𐓮' => '𐓆',\n  '𐓯' => '𐓇',\n  '𐓰' => '𐓈',\n  '𐓱' => '𐓉',\n  '𐓲' => '𐓊',\n  '𐓳' => '𐓋',\n  '𐓴' => '𐓌',\n  '𐓵' => '𐓍',\n  '𐓶' => '𐓎',\n  '𐓷' => '𐓏',\n  '𐓸' => '𐓐',\n  '𐓹' => '𐓑',\n  '𐓺' => '𐓒',\n  '𐓻' => '𐓓',\n  '𐳀' => '𐲀',\n  '𐳁' => '𐲁',\n  '𐳂' => '𐲂',\n  '𐳃' => '𐲃',\n  '𐳄' => '𐲄',\n  '𐳅' => '𐲅',\n  '𐳆' => '𐲆',\n  '𐳇' => '𐲇',\n  '𐳈' => '𐲈',\n  '𐳉' => '𐲉',\n  '𐳊' => '𐲊',\n  '𐳋' => '𐲋',\n  '𐳌' => '𐲌',\n  '𐳍' => '𐲍',\n  '𐳎' => '𐲎',\n  '𐳏' => '𐲏',\n  '𐳐' => '𐲐',\n  '𐳑' => '𐲑',\n  '𐳒' => '𐲒',\n  '𐳓' => '𐲓',\n  '𐳔' => '𐲔',\n  '𐳕' => '𐲕',\n  '𐳖' => '𐲖',\n  '𐳗' => '𐲗',\n  '𐳘' => '𐲘',\n  '𐳙' => '𐲙',\n  '𐳚' => '𐲚',\n  '𐳛' => '𐲛',\n  '𐳜' => '𐲜',\n  '𐳝' => '𐲝',\n  '𐳞' => '𐲞',\n  '𐳟' => '𐲟',\n  '𐳠' => '𐲠',\n  '𐳡' => '𐲡',\n  '𐳢' => '𐲢',\n  '𐳣' => '𐲣',\n  '𐳤' => '𐲤',\n  '𐳥' => '𐲥',\n  '𐳦' => '𐲦',\n  '𐳧' => '𐲧',\n  '𐳨' => '𐲨',\n  '𐳩' => '𐲩',\n  '𐳪' => '𐲪',\n  '𐳫' => '𐲫',\n  '𐳬' => '𐲬',\n  '𐳭' => '𐲭',\n  '𐳮' => '𐲮',\n  '𐳯' => '𐲯',\n  '𐳰' => '𐲰',\n  '𐳱' => '𐲱',\n  '𐳲' => '𐲲',\n  '𑣀' => '𑢠',\n  '𑣁' => '𑢡',\n  '𑣂' => '𑢢',\n  '𑣃' => '𑢣',\n  '𑣄' => '𑢤',\n  '𑣅' => '𑢥',\n  '𑣆' => '𑢦',\n  '𑣇' => '𑢧',\n  '𑣈' => '𑢨',\n  '𑣉' => '𑢩',\n  '𑣊' => '𑢪',\n  '𑣋' => '𑢫',\n  '𑣌' => '𑢬',\n  '𑣍' => '𑢭',\n  '𑣎' => '𑢮',\n  '𑣏' => '𑢯',\n  '𑣐' => '𑢰',\n  '𑣑' => '𑢱',\n  '𑣒' => '𑢲',\n  '𑣓' => '𑢳',\n  '𑣔' => '𑢴',\n  '𑣕' => '𑢵',\n  '𑣖' => '𑢶',\n  '𑣗' => '𑢷',\n  '𑣘' => '𑢸',\n  '𑣙' => '𑢹',\n  '𑣚' => '𑢺',\n  '𑣛' => '𑢻',\n  '𑣜' => '𑢼',\n  '𑣝' => '𑢽',\n  '𑣞' => '𑢾',\n  '𑣟' => '𑢿',\n  '𖹠' => '𖹀',\n  '𖹡' => '𖹁',\n  '𖹢' => '𖹂',\n  '𖹣' => '𖹃',\n  '𖹤' => '𖹄',\n  '𖹥' => '𖹅',\n  '𖹦' => '𖹆',\n  '𖹧' => '𖹇',\n  '𖹨' => '𖹈',\n  '𖹩' => '𖹉',\n  '𖹪' => '𖹊',\n  '𖹫' => '𖹋',\n  '𖹬' => '𖹌',\n  '𖹭' => '𖹍',\n  '𖹮' => '𖹎',\n  '𖹯' => '𖹏',\n  '𖹰' => '𖹐',\n  '𖹱' => '𖹑',\n  '𖹲' => '𖹒',\n  '𖹳' => '𖹓',\n  '𖹴' => '𖹔',\n  '𖹵' => '𖹕',\n  '𖹶' => '𖹖',\n  '𖹷' => '𖹗',\n  '𖹸' => '𖹘',\n  '𖹹' => '𖹙',\n  '𖹺' => '𖹚',\n  '𖹻' => '𖹛',\n  '𖹼' => '𖹜',\n  '𖹽' => '𖹝',\n  '𖹾' => '𖹞',\n  '𖹿' => '𖹟',\n  '𞤢' => '𞤀',\n  '𞤣' => '𞤁',\n  '𞤤' => '𞤂',\n  '𞤥' => '𞤃',\n  '𞤦' => '𞤄',\n  '𞤧' => '𞤅',\n  '𞤨' => '𞤆',\n  '𞤩' => '𞤇',\n  '𞤪' => '𞤈',\n  '𞤫' => '𞤉',\n  '𞤬' => '𞤊',\n  '𞤭' => '𞤋',\n  '𞤮' => '𞤌',\n  '𞤯' => '𞤍',\n  '𞤰' => '𞤎',\n  '𞤱' => '𞤏',\n  '𞤲' => '𞤐',\n  '𞤳' => '𞤑',\n  '𞤴' => '𞤒',\n  '𞤵' => '𞤓',\n  '𞤶' => '𞤔',\n  '𞤷' => '𞤕',\n  '𞤸' => '𞤖',\n  '𞤹' => '𞤗',\n  '𞤺' => '𞤘',\n  '𞤻' => '𞤙',\n  '𞤼' => '𞤚',\n  '𞤽' => '𞤛',\n  '𞤾' => '𞤜',\n  '𞤿' => '𞤝',\n  '𞥀' => '𞤞',\n  '𞥁' => '𞤟',\n  '𞥂' => '𞤠',\n  '𞥃' => '𞤡',\n);\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/.gitignore',
    'composer.lock\nphpunit.xml\nvendor/\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/AmqpCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Casts Amqp related classes to array representation.\n *\n * @author Grégoire Pineau <lyrixx@lyrixx.info>\n */\nclass AmqpCaster\n{\n    private static $flags = [\n        \\AMQP_DURABLE => 'AMQP_DURABLE',\n        \\AMQP_PASSIVE => 'AMQP_PASSIVE',\n        \\AMQP_EXCLUSIVE => 'AMQP_EXCLUSIVE',\n        \\AMQP_AUTODELETE => 'AMQP_AUTODELETE',\n        \\AMQP_INTERNAL => 'AMQP_INTERNAL',\n        \\AMQP_NOLOCAL => 'AMQP_NOLOCAL',\n        \\AMQP_AUTOACK => 'AMQP_AUTOACK',\n        \\AMQP_IFEMPTY => 'AMQP_IFEMPTY',\n        \\AMQP_IFUNUSED => 'AMQP_IFUNUSED',\n        \\AMQP_MANDATORY => 'AMQP_MANDATORY',\n        \\AMQP_IMMEDIATE => 'AMQP_IMMEDIATE',\n        \\AMQP_MULTIPLE => 'AMQP_MULTIPLE',\n        \\AMQP_NOWAIT => 'AMQP_NOWAIT',\n        \\AMQP_REQUEUE => 'AMQP_REQUEUE',\n    ];\n\n    private static $exchangeTypes = [\n        \\AMQP_EX_TYPE_DIRECT => 'AMQP_EX_TYPE_DIRECT',\n        \\AMQP_EX_TYPE_FANOUT => 'AMQP_EX_TYPE_FANOUT',\n        \\AMQP_EX_TYPE_TOPIC => 'AMQP_EX_TYPE_TOPIC',\n        \\AMQP_EX_TYPE_HEADERS => 'AMQP_EX_TYPE_HEADERS',\n    ];\n\n    public static function castConnection(\\AMQPConnection $c, array $a, Stub $stub, $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        $a += [\n            $prefix.'is_connected' => $c->isConnected(),\n        ];\n\n        // Recent version of the extension already expose private properties\n        if (isset($a[\"\\x00AMQPConnection\\x00login\"])) {\n            return $a;\n        }\n\n        // BC layer in the amqp lib\n        if (method_exists($c, 'getReadTimeout')) {\n            $timeout = $c->getReadTimeout();\n        } else {\n            $timeout = $c->getTimeout();\n        }\n\n        $a += [\n            $prefix.'is_connected' => $c->isConnected(),\n            $prefix.'login' => $c->getLogin(),\n            $prefix.'password' => $c->getPassword(),\n            $prefix.'host' => $c->getHost(),\n            $prefix.'vhost' => $c->getVhost(),\n            $prefix.'port' => $c->getPort(),\n            $prefix.'read_timeout' => $timeout,\n        ];\n\n        return $a;\n    }\n\n    public static function castChannel(\\AMQPChannel $c, array $a, Stub $stub, $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        $a += [\n            $prefix.'is_connected' => $c->isConnected(),\n            $prefix.'channel_id' => $c->getChannelId(),\n        ];\n\n        // Recent version of the extension already expose private properties\n        if (isset($a[\"\\x00AMQPChannel\\x00connection\"])) {\n            return $a;\n        }\n\n        $a += [\n            $prefix.'connection' => $c->getConnection(),\n            $prefix.'prefetch_size' => $c->getPrefetchSize(),\n            $prefix.'prefetch_count' => $c->getPrefetchCount(),\n        ];\n\n        return $a;\n    }\n\n    public static function castQueue(\\AMQPQueue $c, array $a, Stub $stub, $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        $a += [\n            $prefix.'flags' => self::extractFlags($c->getFlags()),\n        ];\n\n        // Recent version of the extension already expose private properties\n        if (isset($a[\"\\x00AMQPQueue\\x00name\"])) {\n            return $a;\n        }\n\n        $a += [\n            $prefix.'connection' => $c->getConnection(),\n            $prefix.'channel' => $c->getChannel(),\n            $prefix.'name' => $c->getName(),\n            $prefix.'arguments' => $c->getArguments(),\n        ];\n\n        return $a;\n    }\n\n    public static function castExchange(\\AMQPExchange $c, array $a, Stub $stub, $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        $a += [\n            $prefix.'flags' => self::extractFlags($c->getFlags()),\n        ];\n\n        $type = isset(self::$exchangeTypes[$c->getType()]) ? new ConstStub(self::$exchangeTypes[$c->getType()], $c->getType()) : $c->getType();\n\n        // Recent version of the extension already expose private properties\n        if (isset($a[\"\\x00AMQPExchange\\x00name\"])) {\n            $a[\"\\x00AMQPExchange\\x00type\"] = $type;\n\n            return $a;\n        }\n\n        $a += [\n            $prefix.'connection' => $c->getConnection(),\n            $prefix.'channel' => $c->getChannel(),\n            $prefix.'name' => $c->getName(),\n            $prefix.'type' => $type,\n            $prefix.'arguments' => $c->getArguments(),\n        ];\n\n        return $a;\n    }\n\n    public static function castEnvelope(\\AMQPEnvelope $c, array $a, Stub $stub, $isNested, $filter = 0)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        $deliveryMode = new ConstStub($c->getDeliveryMode().(2 === $c->getDeliveryMode() ? ' (persistent)' : ' (non-persistent)'), $c->getDeliveryMode());\n\n        // Recent version of the extension already expose private properties\n        if (isset($a[\"\\x00AMQPEnvelope\\x00body\"])) {\n            $a[\"\\0AMQPEnvelope\\0delivery_mode\"] = $deliveryMode;\n\n            return $a;\n        }\n\n        if (!($filter & Caster::EXCLUDE_VERBOSE)) {\n            $a += [$prefix.'body' => $c->getBody()];\n        }\n\n        $a += [\n            $prefix.'delivery_tag' => $c->getDeliveryTag(),\n            $prefix.'is_redelivery' => $c->isRedelivery(),\n            $prefix.'exchange_name' => $c->getExchangeName(),\n            $prefix.'routing_key' => $c->getRoutingKey(),\n            $prefix.'content_type' => $c->getContentType(),\n            $prefix.'content_encoding' => $c->getContentEncoding(),\n            $prefix.'headers' => $c->getHeaders(),\n            $prefix.'delivery_mode' => $deliveryMode,\n            $prefix.'priority' => $c->getPriority(),\n            $prefix.'correlation_id' => $c->getCorrelationId(),\n            $prefix.'reply_to' => $c->getReplyTo(),\n            $prefix.'expiration' => $c->getExpiration(),\n            $prefix.'message_id' => $c->getMessageId(),\n            $prefix.'timestamp' => $c->getTimeStamp(),\n            $prefix.'type' => $c->getType(),\n            $prefix.'user_id' => $c->getUserId(),\n            $prefix.'app_id' => $c->getAppId(),\n        ];\n\n        return $a;\n    }\n\n    private static function extractFlags($flags)\n    {\n        $flagsArray = [];\n\n        foreach (self::$flags as $value => $name) {\n            if ($flags & $value) {\n                $flagsArray[] = $name;\n            }\n        }\n\n        if (!$flagsArray) {\n            $flagsArray = ['AMQP_NOPARAM'];\n        }\n\n        return new ConstStub(implode('|', $flagsArray), $flags);\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/ArgsStub.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Represents a list of function arguments.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass ArgsStub extends EnumStub\n{\n    private static $parameters = [];\n\n    public function __construct(array $args, $function, $class)\n    {\n        list($variadic, $params) = self::getParameters($function, $class);\n\n        $values = [];\n        foreach ($args as $k => $v) {\n            $values[$k] = !is_scalar($v) && !$v instanceof Stub ? new CutStub($v) : $v;\n        }\n        if (null === $params) {\n            parent::__construct($values, false);\n\n            return;\n        }\n        if (\\count($values) < \\count($params)) {\n            $params = \\array_slice($params, 0, \\count($values));\n        } elseif (\\count($values) > \\count($params)) {\n            $values[] = new EnumStub(array_splice($values, \\count($params)), false);\n            $params[] = $variadic;\n        }\n        if (['...'] === $params) {\n            $this->dumpKeys = false;\n            $this->value = $values[0]->value;\n        } else {\n            $this->value = array_combine($params, $values);\n        }\n    }\n\n    private static function getParameters($function, $class)\n    {\n        if (isset(self::$parameters[$k = $class.'::'.$function])) {\n            return self::$parameters[$k];\n        }\n\n        try {\n            $r = null !== $class ? new \\ReflectionMethod($class, $function) : new \\ReflectionFunction($function);\n        } catch (\\ReflectionException $e) {\n            return [null, null];\n        }\n\n        $variadic = '...';\n        $params = [];\n        foreach ($r->getParameters() as $v) {\n            $k = '$'.$v->name;\n            if ($v->isPassedByReference()) {\n                $k = '&'.$k;\n            }\n            if (method_exists($v, 'isVariadic') && $v->isVariadic()) {\n                $variadic .= $k;\n            } else {\n                $params[] = $k;\n            }\n        }\n\n        return self::$parameters[$k] = [$variadic, $params];\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/Caster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Helper for filtering out properties in casters.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n *\n * @final\n */\nclass Caster\n{\n    const EXCLUDE_VERBOSE = 1;\n    const EXCLUDE_VIRTUAL = 2;\n    const EXCLUDE_DYNAMIC = 4;\n    const EXCLUDE_PUBLIC = 8;\n    const EXCLUDE_PROTECTED = 16;\n    const EXCLUDE_PRIVATE = 32;\n    const EXCLUDE_NULL = 64;\n    const EXCLUDE_EMPTY = 128;\n    const EXCLUDE_NOT_IMPORTANT = 256;\n    const EXCLUDE_STRICT = 512;\n\n    const PREFIX_VIRTUAL = \"\\0~\\0\";\n    const PREFIX_DYNAMIC = \"\\0+\\0\";\n    const PREFIX_PROTECTED = \"\\0*\\0\";\n\n    /**\n     * Casts objects to arrays and adds the dynamic property prefix.\n     *\n     * @param object $obj          The object to cast\n     * @param string $class        The class of the object\n     * @param bool   $hasDebugInfo Whether the __debugInfo method exists on $obj or not\n     *\n     * @return array The array-cast of the object, with prefixed dynamic properties\n     */\n    public static function castObject($obj, $class, $hasDebugInfo = false, $debugClass = null)\n    {\n        if ($class instanceof \\ReflectionClass) {\n            @trigger_error(sprintf('Passing a ReflectionClass to \"%s()\" is deprecated since Symfony 3.3 and will be unsupported in 4.0. Pass the class name as string instead.', __METHOD__), \\E_USER_DEPRECATED);\n            $hasDebugInfo = $class->hasMethod('__debugInfo');\n            $class = $class->name;\n        }\n\n        if ($hasDebugInfo) {\n            try {\n                $debugInfo = $obj->__debugInfo();\n            } catch (\\Exception $e) {\n                // ignore failing __debugInfo()\n                $hasDebugInfo = false;\n            }\n        }\n\n        $a = $obj instanceof \\Closure ? [] : (array) $obj;\n\n        if ($obj instanceof \\__PHP_Incomplete_Class) {\n            return $a;\n        }\n\n        if ($a) {\n            static $publicProperties = [];\n            if (null === $debugClass) {\n                if (\\PHP_VERSION_ID >= 80000) {\n                    $debugClass = get_debug_type($obj);\n                } else {\n                    $debugClass = $class;\n\n                    if (isset($debugClass[15]) && \"\\0\" === $debugClass[15]) {\n                        $debugClass = (get_parent_class($debugClass) ?: key(class_implements($debugClass)) ?: 'class').'@anonymous';\n                    }\n                }\n            }\n\n            $i = 0;\n            $prefixedKeys = [];\n            foreach ($a as $k => $v) {\n                if (isset($k[0]) ? \"\\0\" !== $k[0] : \\PHP_VERSION_ID >= 70200) {\n                    if (!isset($publicProperties[$class])) {\n                        foreach ((new \\ReflectionClass($class))->getProperties(\\ReflectionProperty::IS_PUBLIC) as $prop) {\n                            $publicProperties[$class][$prop->name] = true;\n                        }\n                    }\n                    if (!isset($publicProperties[$class][$k])) {\n                        $prefixedKeys[$i] = self::PREFIX_DYNAMIC.$k;\n                    }\n                } elseif ($debugClass !== $class && 1 === strpos($k, $class)) {\n                    $prefixedKeys[$i] = \"\\0\".$debugClass.strrchr($k, \"\\0\");\n                }\n                ++$i;\n            }\n            if ($prefixedKeys) {\n                $keys = array_keys($a);\n                foreach ($prefixedKeys as $i => $k) {\n                    $keys[$i] = $k;\n                }\n                $a = array_combine($keys, $a);\n            }\n        }\n\n        if ($hasDebugInfo && \\is_array($debugInfo)) {\n            foreach ($debugInfo as $k => $v) {\n                if (!isset($k[0]) || \"\\0\" !== $k[0]) {\n                    if (\\array_key_exists(self::PREFIX_DYNAMIC.$k, $a)) {\n                        continue;\n                    }\n                    $k = self::PREFIX_VIRTUAL.$k;\n                }\n\n                unset($a[$k]);\n                $a[$k] = $v;\n            }\n        }\n\n        return $a;\n    }\n\n    /**\n     * Filters out the specified properties.\n     *\n     * By default, a single match in the $filter bit field filters properties out, following an \"or\" logic.\n     * When EXCLUDE_STRICT is set, an \"and\" logic is applied: all bits must match for a property to be removed.\n     *\n     * @param array    $a                The array containing the properties to filter\n     * @param int      $filter           A bit field of Caster::EXCLUDE_* constants specifying which properties to filter out\n     * @param string[] $listedProperties List of properties to exclude when Caster::EXCLUDE_VERBOSE is set, and to preserve when Caster::EXCLUDE_NOT_IMPORTANT is set\n     * @param int      &$count           Set to the number of removed properties\n     *\n     * @return array The filtered array\n     */\n    public static function filter(array $a, $filter, array $listedProperties = [], &$count = 0)\n    {\n        $count = 0;\n\n        foreach ($a as $k => $v) {\n            $type = self::EXCLUDE_STRICT & $filter;\n\n            if (null === $v) {\n                $type |= self::EXCLUDE_NULL & $filter;\n                $type |= self::EXCLUDE_EMPTY & $filter;\n            } elseif (false === $v || '' === $v || '0' === $v || 0 === $v || 0.0 === $v || [] === $v) {\n                $type |= self::EXCLUDE_EMPTY & $filter;\n            }\n            if ((self::EXCLUDE_NOT_IMPORTANT & $filter) && !\\in_array($k, $listedProperties, true)) {\n                $type |= self::EXCLUDE_NOT_IMPORTANT;\n            }\n            if ((self::EXCLUDE_VERBOSE & $filter) && \\in_array($k, $listedProperties, true)) {\n                $type |= self::EXCLUDE_VERBOSE;\n            }\n\n            if (!isset($k[1]) || \"\\0\" !== $k[0]) {\n                $type |= self::EXCLUDE_PUBLIC & $filter;\n            } elseif ('~' === $k[1]) {\n                $type |= self::EXCLUDE_VIRTUAL & $filter;\n            } elseif ('+' === $k[1]) {\n                $type |= self::EXCLUDE_DYNAMIC & $filter;\n            } elseif ('*' === $k[1]) {\n                $type |= self::EXCLUDE_PROTECTED & $filter;\n            } else {\n                $type |= self::EXCLUDE_PRIVATE & $filter;\n            }\n\n            if ((self::EXCLUDE_STRICT & $filter) ? $type === $filter : $type) {\n                unset($a[$k]);\n                ++$count;\n            }\n        }\n\n        return $a;\n    }\n\n    public static function castPhpIncompleteClass(\\__PHP_Incomplete_Class $c, array $a, Stub $stub, $isNested)\n    {\n        if (isset($a['__PHP_Incomplete_Class_Name'])) {\n            $stub->class .= '('.$a['__PHP_Incomplete_Class_Name'].')';\n            unset($a['__PHP_Incomplete_Class_Name']);\n        }\n\n        return $a;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/ClassStub.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\n/**\n * Represents a PHP class identifier.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass ClassStub extends ConstStub\n{\n    /**\n     * @param string   $identifier A PHP identifier, e.g. a class, method, interface, etc. name\n     * @param callable $callable   The callable targeted by the identifier when it is ambiguous or not a real PHP identifier\n     */\n    public function __construct($identifier, $callable = null)\n    {\n        $this->value = $identifier;\n\n        if (0 < $i = strrpos($identifier, '\\\\')) {\n            $this->attr['ellipsis'] = \\strlen($identifier) - $i;\n            $this->attr['ellipsis-type'] = 'class';\n            $this->attr['ellipsis-tail'] = 1;\n        }\n\n        try {\n            if (null !== $callable) {\n                if ($callable instanceof \\Closure) {\n                    $r = new \\ReflectionFunction($callable);\n                } elseif (\\is_object($callable)) {\n                    $r = [$callable, '__invoke'];\n                } elseif (\\is_array($callable)) {\n                    $r = $callable;\n                } elseif (false !== $i = strpos($callable, '::')) {\n                    $r = [substr($callable, 0, $i), substr($callable, 2 + $i)];\n                } else {\n                    $r = new \\ReflectionFunction($callable);\n                }\n            } elseif (0 < $i = strpos($identifier, '::') ?: strpos($identifier, '->')) {\n                $r = [substr($identifier, 0, $i), substr($identifier, 2 + $i)];\n            } else {\n                $r = new \\ReflectionClass($identifier);\n            }\n\n            if (\\is_array($r)) {\n                try {\n                    $r = new \\ReflectionMethod($r[0], $r[1]);\n                } catch (\\ReflectionException $e) {\n                    $r = new \\ReflectionClass($r[0]);\n                }\n            }\n        } catch (\\ReflectionException $e) {\n            return;\n        }\n\n        if ($f = $r->getFileName()) {\n            $this->attr['file'] = $f;\n            $this->attr['line'] = $r->getStartLine();\n        }\n    }\n\n    public static function wrapCallable($callable)\n    {\n        if (\\is_object($callable) || !\\is_callable($callable)) {\n            return $callable;\n        }\n\n        if (!\\is_array($callable)) {\n            $callable = new static($callable);\n        } elseif (\\is_string($callable[0])) {\n            $callable[0] = new static($callable[0]);\n        } else {\n            $callable[1] = new static($callable[1], $callable);\n        }\n\n        return $callable;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/ConstStub.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Represents a PHP constant and its value.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass ConstStub extends Stub\n{\n    public function __construct($name, $value)\n    {\n        $this->class = $name;\n        $this->value = $value;\n    }\n\n    public function __toString()\n    {\n        return (string) $this->value;\n    }\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/CutArrayStub.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\n/**\n * Represents a cut array.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass CutArrayStub extends CutStub\n{\n    public $preservedSubset;\n\n    public function __construct(array $value, array $preservedKeys)\n    {\n        parent::__construct($value);\n\n        $this->preservedSubset = array_intersect_key($value, array_flip($preservedKeys));\n        $this->cut -= \\count($this->preservedSubset);\n    }\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/CutStub.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Represents the main properties of a PHP variable, pre-casted by a caster.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass CutStub extends Stub\n{\n    public function __construct($value)\n    {\n        $this->value = $value;\n\n        switch (\\gettype($value)) {\n            case 'object':\n                $this->type = self::TYPE_OBJECT;\n                $this->class = \\get_class($value);\n                $this->cut = -1;\n                break;\n\n            case 'array':\n                $this->type = self::TYPE_ARRAY;\n                $this->class = self::ARRAY_ASSOC;\n                $this->cut = $this->value = \\count($value);\n                break;\n\n            case 'resource':\n            case 'unknown type':\n            case 'resource (closed)':\n                $this->type = self::TYPE_RESOURCE;\n                $this->handle = (int) $value;\n                if ('Unknown' === $this->class = @get_resource_type($value)) {\n                    $this->class = 'Closed';\n                }\n                $this->cut = -1;\n                break;\n\n            case 'string':\n                $this->type = self::TYPE_STRING;\n                $this->class = preg_match('//u', $value) ? self::STRING_UTF8 : self::STRING_BINARY;\n                $this->cut = self::STRING_BINARY === $this->class ? \\strlen($value) : mb_strlen($value, 'UTF-8');\n                $this->value = '';\n                break;\n        }\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/DateCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Casts DateTimeInterface related classes to array representation.\n *\n * @author Dany Maillard <danymaillard93b@gmail.com>\n */\nclass DateCaster\n{\n    public static function castDateTime(\\DateTimeInterface $d, array $a, Stub $stub, $isNested, $filter)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n        $location = $d->getTimezone()->getLocation();\n        $fromNow = (new \\DateTime())->diff($d);\n\n        $title = $d->format('l, F j, Y')\n            .\"\\n\".self::formatInterval($fromNow).' from now'\n            .($location ? ($d->format('I') ? \"\\nDST On\" : \"\\nDST Off\") : '')\n        ;\n\n        unset(\n            $a[Caster::PREFIX_DYNAMIC.'date'],\n            $a[Caster::PREFIX_DYNAMIC.'timezone'],\n            $a[Caster::PREFIX_DYNAMIC.'timezone_type']\n        );\n        $a[$prefix.'date'] = new ConstStub(self::formatDateTime($d, $location ? ' e (P)' : ' P'), $title);\n\n        $stub->class .= $d->format(' @U');\n\n        return $a;\n    }\n\n    public static function castInterval(\\DateInterval $interval, array $a, Stub $stub, $isNested, $filter)\n    {\n        $now = new \\DateTimeImmutable();\n        $numberOfSeconds = $now->add($interval)->getTimestamp() - $now->getTimestamp();\n        $title = number_format($numberOfSeconds, 0, '.', ' ').'s';\n\n        $i = [Caster::PREFIX_VIRTUAL.'interval' => new ConstStub(self::formatInterval($interval), $title)];\n\n        return $filter & Caster::EXCLUDE_VERBOSE ? $i : $i + $a;\n    }\n\n    private static function formatInterval(\\DateInterval $i)\n    {\n        $format = '%R ';\n\n        if (0 === $i->y && 0 === $i->m && ($i->h >= 24 || $i->i >= 60 || $i->s >= 60)) {\n            $i = date_diff($d = new \\DateTime(), date_add(clone $d, $i)); // recalculate carry over points\n            $format .= 0 < $i->days ? '%ad ' : '';\n        } else {\n            $format .= ($i->y ? '%yy ' : '').($i->m ? '%mm ' : '').($i->d ? '%dd ' : '');\n        }\n\n        if (\\PHP_VERSION_ID >= 70100 && isset($i->f)) {\n            $format .= $i->h || $i->i || $i->s || $i->f ? '%H:%I:'.self::formatSeconds($i->s, substr($i->f, 2)) : '';\n        } else {\n            $format .= $i->h || $i->i || $i->s ? '%H:%I:%S' : '';\n        }\n\n        $format = '%R ' === $format ? '0s' : $format;\n\n        return $i->format(rtrim($format));\n    }\n\n    public static function castTimeZone(\\DateTimeZone $timeZone, array $a, Stub $stub, $isNested, $filter)\n    {\n        $location = $timeZone->getLocation();\n        $formatted = (new \\DateTime('now', $timeZone))->format($location ? 'e (P)' : 'P');\n        $title = $location && \\extension_loaded('intl') ? \\Locale::getDisplayRegion('-'.$location['country_code'], \\Locale::getDefault()) : '';\n\n        $z = [Caster::PREFIX_VIRTUAL.'timezone' => new ConstStub($formatted, $title)];\n\n        return $filter & Caster::EXCLUDE_VERBOSE ? $z : $z + $a;\n    }\n\n    public static function castPeriod(\\DatePeriod $p, array $a, Stub $stub, $isNested, $filter)\n    {\n        if (\\defined('HHVM_VERSION_ID') || \\PHP_VERSION_ID < 50620 || (\\PHP_VERSION_ID >= 70000 && \\PHP_VERSION_ID < 70005)) { // see https://bugs.php.net/71635\n            return $a;\n        }\n\n        $dates = [];\n        if (\\PHP_VERSION_ID >= 70107) { // see https://bugs.php.net/74639\n            foreach (clone $p as $i => $d) {\n                if (3 === $i) {\n                    $now = new \\DateTimeImmutable();\n                    $dates[] = sprintf('%s more', ($end = $p->getEndDate())\n                        ? ceil(($end->format('U.u') - $d->format('U.u')) / ((int) $now->add($p->getDateInterval())->format('U.u') - (int) $now->format('U.u')))\n                        : $p->recurrences - $i\n                    );\n                    break;\n                }\n                $dates[] = sprintf('%s) %s', $i + 1, self::formatDateTime($d));\n            }\n        }\n\n        $period = sprintf(\n            'every %s, from %s (%s) %s',\n            self::formatInterval($p->getDateInterval()),\n            self::formatDateTime($p->getStartDate()),\n            $p->include_start_date ? 'included' : 'excluded',\n            ($end = $p->getEndDate()) ? 'to '.self::formatDateTime($end) : 'recurring '.$p->recurrences.' time/s'\n        );\n\n        $p = [Caster::PREFIX_VIRTUAL.'period' => new ConstStub($period, implode(\"\\n\", $dates))];\n\n        return $filter & Caster::EXCLUDE_VERBOSE ? $p : $p + $a;\n    }\n\n    private static function formatDateTime(\\DateTimeInterface $d, $extra = '')\n    {\n        return $d->format('Y-m-d H:i:'.self::formatSeconds($d->format('s'), $d->format('u')).$extra);\n    }\n\n    private static function formatSeconds($s, $us)\n    {\n        return sprintf('%02d.%s', $s, 0 === ($len = \\strlen($t = rtrim($us, '0'))) ? '0' : ($len <= 3 ? str_pad($t, 3, '0') : $us));\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/DoctrineCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Doctrine\\Common\\Proxy\\Proxy as CommonProxy;\nuse Doctrine\\ORM\\PersistentCollection;\nuse Doctrine\\ORM\\Proxy\\Proxy as OrmProxy;\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Casts Doctrine related classes to array representation.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass DoctrineCaster\n{\n    public static function castCommonProxy(CommonProxy $proxy, array $a, Stub $stub, $isNested)\n    {\n        foreach (['__cloner__', '__initializer__'] as $k) {\n            if (\\array_key_exists($k, $a)) {\n                unset($a[$k]);\n                ++$stub->cut;\n            }\n        }\n\n        return $a;\n    }\n\n    public static function castOrmProxy(OrmProxy $proxy, array $a, Stub $stub, $isNested)\n    {\n        foreach (['_entityPersister', '_identifier'] as $k) {\n            if (\\array_key_exists($k = \"\\0Doctrine\\\\ORM\\\\Proxy\\\\Proxy\\0\".$k, $a)) {\n                unset($a[$k]);\n                ++$stub->cut;\n            }\n        }\n\n        return $a;\n    }\n\n    public static function castPersistentCollection(PersistentCollection $coll, array $a, Stub $stub, $isNested)\n    {\n        foreach (['snapshot', 'association', 'typeClass'] as $k) {\n            if (\\array_key_exists($k = \"\\0Doctrine\\\\ORM\\\\PersistentCollection\\0\".$k, $a)) {\n                $a[$k] = new CutStub($a[$k]);\n            }\n        }\n\n        return $a;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/DOMCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Casts DOM related classes to array representation.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass DOMCaster\n{\n    private static $errorCodes = [\n        \\DOM_PHP_ERR => 'DOM_PHP_ERR',\n        \\DOM_INDEX_SIZE_ERR => 'DOM_INDEX_SIZE_ERR',\n        \\DOMSTRING_SIZE_ERR => 'DOMSTRING_SIZE_ERR',\n        \\DOM_HIERARCHY_REQUEST_ERR => 'DOM_HIERARCHY_REQUEST_ERR',\n        \\DOM_WRONG_DOCUMENT_ERR => 'DOM_WRONG_DOCUMENT_ERR',\n        \\DOM_INVALID_CHARACTER_ERR => 'DOM_INVALID_CHARACTER_ERR',\n        \\DOM_NO_DATA_ALLOWED_ERR => 'DOM_NO_DATA_ALLOWED_ERR',\n        \\DOM_NO_MODIFICATION_ALLOWED_ERR => 'DOM_NO_MODIFICATION_ALLOWED_ERR',\n        \\DOM_NOT_FOUND_ERR => 'DOM_NOT_FOUND_ERR',\n        \\DOM_NOT_SUPPORTED_ERR => 'DOM_NOT_SUPPORTED_ERR',\n        \\DOM_INUSE_ATTRIBUTE_ERR => 'DOM_INUSE_ATTRIBUTE_ERR',\n        \\DOM_INVALID_STATE_ERR => 'DOM_INVALID_STATE_ERR',\n        \\DOM_SYNTAX_ERR => 'DOM_SYNTAX_ERR',\n        \\DOM_INVALID_MODIFICATION_ERR => 'DOM_INVALID_MODIFICATION_ERR',\n        \\DOM_NAMESPACE_ERR => 'DOM_NAMESPACE_ERR',\n        \\DOM_INVALID_ACCESS_ERR => 'DOM_INVALID_ACCESS_ERR',\n        \\DOM_VALIDATION_ERR => 'DOM_VALIDATION_ERR',\n    ];\n\n    private static $nodeTypes = [\n        \\XML_ELEMENT_NODE => 'XML_ELEMENT_NODE',\n        \\XML_ATTRIBUTE_NODE => 'XML_ATTRIBUTE_NODE',\n        \\XML_TEXT_NODE => 'XML_TEXT_NODE',\n        \\XML_CDATA_SECTION_NODE => 'XML_CDATA_SECTION_NODE',\n        \\XML_ENTITY_REF_NODE => 'XML_ENTITY_REF_NODE',\n        \\XML_ENTITY_NODE => 'XML_ENTITY_NODE',\n        \\XML_PI_NODE => 'XML_PI_NODE',\n        \\XML_COMMENT_NODE => 'XML_COMMENT_NODE',\n        \\XML_DOCUMENT_NODE => 'XML_DOCUMENT_NODE',\n        \\XML_DOCUMENT_TYPE_NODE => 'XML_DOCUMENT_TYPE_NODE',\n        \\XML_DOCUMENT_FRAG_NODE => 'XML_DOCUMENT_FRAG_NODE',\n        \\XML_NOTATION_NODE => 'XML_NOTATION_NODE',\n        \\XML_HTML_DOCUMENT_NODE => 'XML_HTML_DOCUMENT_NODE',\n        \\XML_DTD_NODE => 'XML_DTD_NODE',\n        \\XML_ELEMENT_DECL_NODE => 'XML_ELEMENT_DECL_NODE',\n        \\XML_ATTRIBUTE_DECL_NODE => 'XML_ATTRIBUTE_DECL_NODE',\n        \\XML_ENTITY_DECL_NODE => 'XML_ENTITY_DECL_NODE',\n        \\XML_NAMESPACE_DECL_NODE => 'XML_NAMESPACE_DECL_NODE',\n    ];\n\n    public static function castException(\\DOMException $e, array $a, Stub $stub, $isNested)\n    {\n        $k = Caster::PREFIX_PROTECTED.'code';\n        if (isset($a[$k], self::$errorCodes[$a[$k]])) {\n            $a[$k] = new ConstStub(self::$errorCodes[$a[$k]], $a[$k]);\n        }\n\n        return $a;\n    }\n\n    public static function castLength($dom, array $a, Stub $stub, $isNested)\n    {\n        $a += [\n            'length' => $dom->length,\n        ];\n\n        return $a;\n    }\n\n    public static function castImplementation($dom, array $a, Stub $stub, $isNested)\n    {\n        $a += [\n            Caster::PREFIX_VIRTUAL.'Core' => '1.0',\n            Caster::PREFIX_VIRTUAL.'XML' => '2.0',\n        ];\n\n        return $a;\n    }\n\n    public static function castNode(\\DOMNode $dom, array $a, Stub $stub, $isNested)\n    {\n        $a += [\n            'nodeName' => $dom->nodeName,\n            'nodeValue' => new CutStub($dom->nodeValue),\n            'nodeType' => new ConstStub(self::$nodeTypes[$dom->nodeType], $dom->nodeType),\n            'parentNode' => new CutStub($dom->parentNode),\n            'childNodes' => $dom->childNodes,\n            'firstChild' => new CutStub($dom->firstChild),\n            'lastChild' => new CutStub($dom->lastChild),\n            'previousSibling' => new CutStub($dom->previousSibling),\n            'nextSibling' => new CutStub($dom->nextSibling),\n            'attributes' => $dom->attributes,\n            'ownerDocument' => new CutStub($dom->ownerDocument),\n            'namespaceURI' => $dom->namespaceURI,\n            'prefix' => $dom->prefix,\n            'localName' => $dom->localName,\n            'baseURI' => $dom->baseURI ? new LinkStub($dom->baseURI) : $dom->baseURI,\n            'textContent' => new CutStub($dom->textContent),\n        ];\n\n        return $a;\n    }\n\n    public static function castNameSpaceNode(\\DOMNameSpaceNode $dom, array $a, Stub $stub, $isNested)\n    {\n        $a += [\n            'nodeName' => $dom->nodeName,\n            'nodeValue' => new CutStub($dom->nodeValue),\n            'nodeType' => new ConstStub(self::$nodeTypes[$dom->nodeType], $dom->nodeType),\n            'prefix' => $dom->prefix,\n            'localName' => $dom->localName,\n            'namespaceURI' => $dom->namespaceURI,\n            'ownerDocument' => new CutStub($dom->ownerDocument),\n            'parentNode' => new CutStub($dom->parentNode),\n        ];\n\n        return $a;\n    }\n\n    public static function castDocument(\\DOMDocument $dom, array $a, Stub $stub, $isNested, $filter = 0)\n    {\n        $a += [\n            'doctype' => $dom->doctype,\n            'implementation' => $dom->implementation,\n            'documentElement' => new CutStub($dom->documentElement),\n            'actualEncoding' => $dom->actualEncoding,\n            'encoding' => $dom->encoding,\n            'xmlEncoding' => $dom->xmlEncoding,\n            'standalone' => $dom->standalone,\n            'xmlStandalone' => $dom->xmlStandalone,\n            'version' => $dom->version,\n            'xmlVersion' => $dom->xmlVersion,\n            'strictErrorChecking' => $dom->strictErrorChecking,\n            'documentURI' => $dom->documentURI ? new LinkStub($dom->documentURI) : $dom->documentURI,\n            'config' => $dom->config,\n            'formatOutput' => $dom->formatOutput,\n            'validateOnParse' => $dom->validateOnParse,\n            'resolveExternals' => $dom->resolveExternals,\n            'preserveWhiteSpace' => $dom->preserveWhiteSpace,\n            'recover' => $dom->recover,\n            'substituteEntities' => $dom->substituteEntities,\n        ];\n\n        if (!($filter & Caster::EXCLUDE_VERBOSE)) {\n            $formatOutput = $dom->formatOutput;\n            $dom->formatOutput = true;\n            $a += [Caster::PREFIX_VIRTUAL.'xml' => $dom->saveXML()];\n            $dom->formatOutput = $formatOutput;\n        }\n\n        return $a;\n    }\n\n    public static function castCharacterData(\\DOMCharacterData $dom, array $a, Stub $stub, $isNested)\n    {\n        $a += [\n            'data' => $dom->data,\n            'length' => $dom->length,\n        ];\n\n        return $a;\n    }\n\n    public static function castAttr(\\DOMAttr $dom, array $a, Stub $stub, $isNested)\n    {\n        $a += [\n            'name' => $dom->name,\n            'specified' => $dom->specified,\n            'value' => $dom->value,\n            'ownerElement' => $dom->ownerElement,\n            'schemaTypeInfo' => $dom->schemaTypeInfo,\n        ];\n\n        return $a;\n    }\n\n    public static function castElement(\\DOMElement $dom, array $a, Stub $stub, $isNested)\n    {\n        $a += [\n            'tagName' => $dom->tagName,\n            'schemaTypeInfo' => $dom->schemaTypeInfo,\n        ];\n\n        return $a;\n    }\n\n    public static function castText(\\DOMText $dom, array $a, Stub $stub, $isNested)\n    {\n        $a += [\n            'wholeText' => $dom->wholeText,\n        ];\n\n        return $a;\n    }\n\n    public static function castTypeinfo(\\DOMTypeinfo $dom, array $a, Stub $stub, $isNested)\n    {\n        $a += [\n            'typeName' => $dom->typeName,\n            'typeNamespace' => $dom->typeNamespace,\n        ];\n\n        return $a;\n    }\n\n    public static function castDomError(\\DOMDomError $dom, array $a, Stub $stub, $isNested)\n    {\n        $a += [\n            'severity' => $dom->severity,\n            'message' => $dom->message,\n            'type' => $dom->type,\n            'relatedException' => $dom->relatedException,\n            'related_data' => $dom->related_data,\n            'location' => $dom->location,\n        ];\n\n        return $a;\n    }\n\n    public static function castLocator(\\DOMLocator $dom, array $a, Stub $stub, $isNested)\n    {\n        $a += [\n            'lineNumber' => $dom->lineNumber,\n            'columnNumber' => $dom->columnNumber,\n            'offset' => $dom->offset,\n            'relatedNode' => $dom->relatedNode,\n            'uri' => $dom->uri ? new LinkStub($dom->uri, $dom->lineNumber) : $dom->uri,\n        ];\n\n        return $a;\n    }\n\n    public static function castDocumentType(\\DOMDocumentType $dom, array $a, Stub $stub, $isNested)\n    {\n        $a += [\n            'name' => $dom->name,\n            'entities' => $dom->entities,\n            'notations' => $dom->notations,\n            'publicId' => $dom->publicId,\n            'systemId' => $dom->systemId,\n            'internalSubset' => $dom->internalSubset,\n        ];\n\n        return $a;\n    }\n\n    public static function castNotation(\\DOMNotation $dom, array $a, Stub $stub, $isNested)\n    {\n        $a += [\n            'publicId' => $dom->publicId,\n            'systemId' => $dom->systemId,\n        ];\n\n        return $a;\n    }\n\n    public static function castEntity(\\DOMEntity $dom, array $a, Stub $stub, $isNested)\n    {\n        $a += [\n            'publicId' => $dom->publicId,\n            'systemId' => $dom->systemId,\n            'notationName' => $dom->notationName,\n            'actualEncoding' => $dom->actualEncoding,\n            'encoding' => $dom->encoding,\n            'version' => $dom->version,\n        ];\n\n        return $a;\n    }\n\n    public static function castProcessingInstruction(\\DOMProcessingInstruction $dom, array $a, Stub $stub, $isNested)\n    {\n        $a += [\n            'target' => $dom->target,\n            'data' => $dom->data,\n        ];\n\n        return $a;\n    }\n\n    public static function castXPath(\\DOMXPath $dom, array $a, Stub $stub, $isNested)\n    {\n        $a += [\n            'document' => $dom->document,\n        ];\n\n        return $a;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/EnumStub.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Represents an enumeration of values.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass EnumStub extends Stub\n{\n    public $dumpKeys = true;\n\n    public function __construct(array $values, $dumpKeys = true)\n    {\n        $this->value = $values;\n        $this->dumpKeys = $dumpKeys;\n    }\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/ExceptionCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\Debug\\Exception\\SilencedErrorContext;\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\nuse Symfony\\Component\\VarDumper\\Exception\\ThrowingCasterException;\n\n/**\n * Casts common Exception classes to array representation.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass ExceptionCaster\n{\n    public static $srcContext = 1;\n    public static $traceArgs = true;\n    public static $errorTypes = [\n        \\E_DEPRECATED => 'E_DEPRECATED',\n        \\E_USER_DEPRECATED => 'E_USER_DEPRECATED',\n        \\E_RECOVERABLE_ERROR => 'E_RECOVERABLE_ERROR',\n        \\E_ERROR => 'E_ERROR',\n        \\E_WARNING => 'E_WARNING',\n        \\E_PARSE => 'E_PARSE',\n        \\E_NOTICE => 'E_NOTICE',\n        \\E_CORE_ERROR => 'E_CORE_ERROR',\n        \\E_CORE_WARNING => 'E_CORE_WARNING',\n        \\E_COMPILE_ERROR => 'E_COMPILE_ERROR',\n        \\E_COMPILE_WARNING => 'E_COMPILE_WARNING',\n        \\E_USER_ERROR => 'E_USER_ERROR',\n        \\E_USER_WARNING => 'E_USER_WARNING',\n        \\E_USER_NOTICE => 'E_USER_NOTICE',\n        \\E_STRICT => 'E_STRICT',\n    ];\n\n    private static $framesCache = [];\n\n    public static function castError(\\Error $e, array $a, Stub $stub, $isNested, $filter = 0)\n    {\n        return self::filterExceptionArray($stub->class, $a, \"\\0Error\\0\", $filter);\n    }\n\n    public static function castException(\\Exception $e, array $a, Stub $stub, $isNested, $filter = 0)\n    {\n        return self::filterExceptionArray($stub->class, $a, \"\\0Exception\\0\", $filter);\n    }\n\n    public static function castErrorException(\\ErrorException $e, array $a, Stub $stub, $isNested)\n    {\n        if (isset($a[$s = Caster::PREFIX_PROTECTED.'severity'], self::$errorTypes[$a[$s]])) {\n            $a[$s] = new ConstStub(self::$errorTypes[$a[$s]], $a[$s]);\n        }\n\n        return $a;\n    }\n\n    public static function castThrowingCasterException(ThrowingCasterException $e, array $a, Stub $stub, $isNested)\n    {\n        $trace = Caster::PREFIX_VIRTUAL.'trace';\n        $prefix = Caster::PREFIX_PROTECTED;\n        $xPrefix = \"\\0Exception\\0\";\n\n        if (isset($a[$xPrefix.'previous'], $a[$trace]) && $a[$xPrefix.'previous'] instanceof \\Exception) {\n            $b = (array) $a[$xPrefix.'previous'];\n            self::traceUnshift($b[$xPrefix.'trace'], \\get_class($a[$xPrefix.'previous']), $b[$prefix.'file'], $b[$prefix.'line']);\n            $a[$trace] = new TraceStub($b[$xPrefix.'trace'], false, 0, -\\count($a[$trace]->value));\n        }\n\n        unset($a[$xPrefix.'previous'], $a[$prefix.'code'], $a[$prefix.'file'], $a[$prefix.'line']);\n\n        return $a;\n    }\n\n    public static function castSilencedErrorContext(SilencedErrorContext $e, array $a, Stub $stub, $isNested)\n    {\n        $sPrefix = \"\\0\".SilencedErrorContext::class.\"\\0\";\n\n        if (!isset($a[$s = $sPrefix.'severity'])) {\n            return $a;\n        }\n\n        if (isset(self::$errorTypes[$a[$s]])) {\n            $a[$s] = new ConstStub(self::$errorTypes[$a[$s]], $a[$s]);\n        }\n\n        $trace = [[\n            'file' => $a[$sPrefix.'file'],\n            'line' => $a[$sPrefix.'line'],\n        ]];\n\n        if (isset($a[$sPrefix.'trace'])) {\n            $trace = array_merge($trace, $a[$sPrefix.'trace']);\n        }\n\n        unset($a[$sPrefix.'file'], $a[$sPrefix.'line'], $a[$sPrefix.'trace']);\n        $a[Caster::PREFIX_VIRTUAL.'trace'] = new TraceStub($trace, self::$traceArgs);\n\n        return $a;\n    }\n\n    public static function castTraceStub(TraceStub $trace, array $a, Stub $stub, $isNested)\n    {\n        if (!$isNested) {\n            return $a;\n        }\n        $stub->class = '';\n        $stub->handle = 0;\n        $frames = $trace->value;\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        $a = [];\n        $j = \\count($frames);\n        if (0 > $i = $trace->sliceOffset) {\n            $i = max(0, $j + $i);\n        }\n        if (!isset($trace->value[$i])) {\n            return [];\n        }\n        $lastCall = isset($frames[$i]['function']) ? (isset($frames[$i]['class']) ? $frames[0]['class'].$frames[$i]['type'] : '').$frames[$i]['function'].'()' : '';\n        $frames[] = ['function' => ''];\n        $collapse = false;\n\n        for ($j += $trace->numberingOffset - $i++; isset($frames[$i]); ++$i, --$j) {\n            $f = $frames[$i];\n            $call = isset($f['function']) ? (isset($f['class']) ? $f['class'].$f['type'] : '').$f['function'] : '???';\n\n            $frame = new FrameStub(\n                [\n                    'object' => isset($f['object']) ? $f['object'] : null,\n                    'class' => isset($f['class']) ? $f['class'] : null,\n                    'type' => isset($f['type']) ? $f['type'] : null,\n                    'function' => isset($f['function']) ? $f['function'] : null,\n                ] + $frames[$i - 1],\n                false,\n                true\n            );\n            $f = self::castFrameStub($frame, [], $frame, true);\n            if (isset($f[$prefix.'src'])) {\n                foreach ($f[$prefix.'src']->value as $label => $frame) {\n                    if (0 === strpos($label, \"\\0~collapse=0\")) {\n                        if ($collapse) {\n                            $label = substr_replace($label, '1', 11, 1);\n                        } else {\n                            $collapse = true;\n                        }\n                    }\n                    $label = substr_replace($label, \"title=Stack level $j.&\", 2, 0);\n                }\n                $f = $frames[$i - 1];\n                if ($trace->keepArgs && !empty($f['args']) && $frame instanceof EnumStub) {\n                    $frame->value['arguments'] = new ArgsStub($f['args'], isset($f['function']) ? $f['function'] : null, isset($f['class']) ? $f['class'] : null);\n                }\n            } elseif ('???' !== $lastCall) {\n                $label = new ClassStub($lastCall);\n                if (isset($label->attr['ellipsis'])) {\n                    $label->attr['ellipsis'] += 2;\n                    $label = substr_replace($prefix, \"ellipsis-type=class&ellipsis={$label->attr['ellipsis']}&ellipsis-tail=1&title=Stack level $j.\", 2, 0).$label->value.'()';\n                } else {\n                    $label = substr_replace($prefix, \"title=Stack level $j.\", 2, 0).$label->value.'()';\n                }\n            } else {\n                $label = substr_replace($prefix, \"title=Stack level $j.\", 2, 0).$lastCall;\n            }\n            $a[substr_replace($label, sprintf('separator=%s&', $frame instanceof EnumStub ? ' ' : ':'), 2, 0)] = $frame;\n\n            $lastCall = $call;\n        }\n        if (null !== $trace->sliceLength) {\n            $a = \\array_slice($a, 0, $trace->sliceLength, true);\n        }\n\n        return $a;\n    }\n\n    public static function castFrameStub(FrameStub $frame, array $a, Stub $stub, $isNested)\n    {\n        if (!$isNested) {\n            return $a;\n        }\n        $f = $frame->value;\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        if (isset($f['file'], $f['line'])) {\n            $cacheKey = $f;\n            unset($cacheKey['object'], $cacheKey['args']);\n            $cacheKey[] = self::$srcContext;\n            $cacheKey = implode('-', $cacheKey);\n\n            if (isset(self::$framesCache[$cacheKey])) {\n                $a[$prefix.'src'] = self::$framesCache[$cacheKey];\n            } else {\n                if (preg_match('/\\((\\d+)\\)(?:\\([\\da-f]{32}\\))? : (?:eval\\(\\)\\'d code|runtime-created function)$/', $f['file'], $match)) {\n                    $f['file'] = substr($f['file'], 0, -\\strlen($match[0]));\n                    $f['line'] = (int) $match[1];\n                }\n                $caller = isset($f['function']) ? sprintf('in %s() on line %d', (isset($f['class']) ? $f['class'].$f['type'] : '').$f['function'], $f['line']) : null;\n                $src = $f['line'];\n                $srcKey = $f['file'];\n                $ellipsis = new LinkStub($srcKey, 0);\n                $srcAttr = 'collapse='.(int) $ellipsis->inVendor;\n                $ellipsisTail = isset($ellipsis->attr['ellipsis-tail']) ? $ellipsis->attr['ellipsis-tail'] : 0;\n                $ellipsis = isset($ellipsis->attr['ellipsis']) ? $ellipsis->attr['ellipsis'] : 0;\n\n                if (file_exists($f['file']) && 0 <= self::$srcContext) {\n                    if (!empty($f['class']) && (is_subclass_of($f['class'], 'Twig\\Template') || is_subclass_of($f['class'], 'Twig_Template')) && method_exists($f['class'], 'getDebugInfo')) {\n                        $template = isset($f['object']) ? $f['object'] : unserialize(sprintf('O:%d:\"%s\":0:{}', \\strlen($f['class']), $f['class']));\n\n                        $ellipsis = 0;\n                        $templateSrc = method_exists($template, 'getSourceContext') ? $template->getSourceContext()->getCode() : (method_exists($template, 'getSource') ? $template->getSource() : '');\n                        $templateInfo = $template->getDebugInfo();\n                        if (isset($templateInfo[$f['line']])) {\n                            if (!method_exists($template, 'getSourceContext') || !file_exists($templatePath = $template->getSourceContext()->getPath())) {\n                                $templatePath = null;\n                            }\n                            if ($templateSrc) {\n                                $src = self::extractSource($templateSrc, $templateInfo[$f['line']], self::$srcContext, $caller, 'twig', $templatePath);\n                                $srcKey = ($templatePath ?: $template->getTemplateName()).':'.$templateInfo[$f['line']];\n                            }\n                        }\n                    }\n                    if ($srcKey == $f['file']) {\n                        $src = self::extractSource(file_get_contents($f['file']), $f['line'], self::$srcContext, $caller, 'php', $f['file']);\n                        $srcKey .= ':'.$f['line'];\n                        if ($ellipsis) {\n                            $ellipsis += 1 + \\strlen($f['line']);\n                        }\n                    }\n                    $srcAttr .= '&separator= ';\n                } else {\n                    $srcAttr .= '&separator=:';\n                }\n                $srcAttr .= $ellipsis ? '&ellipsis-type=path&ellipsis='.$ellipsis.'&ellipsis-tail='.$ellipsisTail : '';\n                self::$framesCache[$cacheKey] = $a[$prefix.'src'] = new EnumStub([\"\\0~$srcAttr\\0$srcKey\" => $src]);\n            }\n        }\n\n        unset($a[$prefix.'args'], $a[$prefix.'line'], $a[$prefix.'file']);\n        if ($frame->inTraceStub) {\n            unset($a[$prefix.'class'], $a[$prefix.'type'], $a[$prefix.'function']);\n        }\n        foreach ($a as $k => $v) {\n            if (!$v) {\n                unset($a[$k]);\n            }\n        }\n        if ($frame->keepArgs && !empty($f['args'])) {\n            $a[$prefix.'arguments'] = new ArgsStub($f['args'], $f['function'], $f['class']);\n        }\n\n        return $a;\n    }\n\n    private static function filterExceptionArray($xClass, array $a, $xPrefix, $filter)\n    {\n        if (isset($a[$xPrefix.'trace'])) {\n            $trace = $a[$xPrefix.'trace'];\n            unset($a[$xPrefix.'trace']); // Ensures the trace is always last\n        } else {\n            $trace = [];\n        }\n\n        if (!($filter & Caster::EXCLUDE_VERBOSE) && $trace) {\n            if (isset($a[Caster::PREFIX_PROTECTED.'file'], $a[Caster::PREFIX_PROTECTED.'line'])) {\n                self::traceUnshift($trace, $xClass, $a[Caster::PREFIX_PROTECTED.'file'], $a[Caster::PREFIX_PROTECTED.'line']);\n            }\n            $a[Caster::PREFIX_VIRTUAL.'trace'] = new TraceStub($trace, self::$traceArgs);\n        }\n        if (empty($a[$xPrefix.'previous'])) {\n            unset($a[$xPrefix.'previous']);\n        }\n        unset($a[$xPrefix.'string'], $a[Caster::PREFIX_DYNAMIC.'xdebug_message'], $a[Caster::PREFIX_DYNAMIC.'__destructorException']);\n\n        if (isset($a[Caster::PREFIX_PROTECTED.'file'], $a[Caster::PREFIX_PROTECTED.'line'])) {\n            $a[Caster::PREFIX_PROTECTED.'file'] = new LinkStub($a[Caster::PREFIX_PROTECTED.'file'], $a[Caster::PREFIX_PROTECTED.'line']);\n        }\n\n        return $a;\n    }\n\n    private static function traceUnshift(&$trace, $class, $file, $line)\n    {\n        if (isset($trace[0]['file'], $trace[0]['line']) && $trace[0]['file'] === $file && $trace[0]['line'] === $line) {\n            return;\n        }\n        array_unshift($trace, [\n            'function' => $class ? 'new '.$class : null,\n            'file' => $file,\n            'line' => $line,\n        ]);\n    }\n\n    private static function extractSource($srcLines, $line, $srcContext, $title, $lang, $file = null)\n    {\n        $srcLines = explode(\"\\n\", $srcLines);\n        $src = [];\n\n        for ($i = $line - 1 - $srcContext; $i <= $line - 1 + $srcContext; ++$i) {\n            $src[] = (isset($srcLines[$i]) ? $srcLines[$i] : '').\"\\n\";\n        }\n\n        $srcLines = [];\n        $ltrim = 0;\n        do {\n            $pad = null;\n            for ($i = $srcContext << 1; $i >= 0; --$i) {\n                if (isset($src[$i][$ltrim]) && \"\\r\" !== ($c = $src[$i][$ltrim]) && \"\\n\" !== $c) {\n                    if (null === $pad) {\n                        $pad = $c;\n                    }\n                    if ((' ' !== $c && \"\\t\" !== $c) || $pad !== $c) {\n                        break;\n                    }\n                }\n            }\n            ++$ltrim;\n        } while (0 > $i && null !== $pad);\n\n        --$ltrim;\n\n        foreach ($src as $i => $c) {\n            if ($ltrim) {\n                $c = isset($c[$ltrim]) && \"\\r\" !== $c[$ltrim] ? substr($c, $ltrim) : ltrim($c, \" \\t\");\n            }\n            $c = substr($c, 0, -1);\n            if ($i !== $srcContext) {\n                $c = new ConstStub('default', $c);\n            } else {\n                $c = new ConstStub($c, $title);\n                if (null !== $file) {\n                    $c->attr['file'] = $file;\n                    $c->attr['line'] = $line;\n                }\n            }\n            $c->attr['lang'] = $lang;\n            $srcLines[sprintf(\"\\0~separator=› &%d\\0\", $i + $line - $srcContext)] = $c;\n        }\n\n        return new EnumStub($srcLines);\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/FrameStub.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\n/**\n * Represents a single backtrace frame as returned by debug_backtrace() or Exception->getTrace().\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass FrameStub extends EnumStub\n{\n    public $keepArgs;\n    public $inTraceStub;\n\n    public function __construct(array $frame, $keepArgs = true, $inTraceStub = false)\n    {\n        $this->value = $frame;\n        $this->keepArgs = $keepArgs;\n        $this->inTraceStub = $inTraceStub;\n    }\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/LinkStub.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\n/**\n * Represents a file or a URL.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass LinkStub extends ConstStub\n{\n    public $inVendor = false;\n\n    private static $vendorRoots;\n    private static $composerRoots;\n\n    public function __construct($label, $line = 0, $href = null)\n    {\n        $this->value = $label;\n\n        if (null === $href) {\n            $href = $label;\n        }\n        if (!\\is_string($href)) {\n            return;\n        }\n        if (0 === strpos($href, 'file://')) {\n            if ($href === $label) {\n                $label = substr($label, 7);\n            }\n            $href = substr($href, 7);\n        } elseif (false !== strpos($href, '://')) {\n            $this->attr['href'] = $href;\n\n            return;\n        }\n        if (!file_exists($href)) {\n            return;\n        }\n        if ($line) {\n            $this->attr['line'] = $line;\n        }\n        if ($label !== $this->attr['file'] = realpath($href) ?: $href) {\n            return;\n        }\n        if ($composerRoot = $this->getComposerRoot($href, $this->inVendor)) {\n            $this->attr['ellipsis'] = \\strlen($href) - \\strlen($composerRoot) + 1;\n            $this->attr['ellipsis-type'] = 'path';\n            $this->attr['ellipsis-tail'] = 1 + ($this->inVendor ? 2 + \\strlen(implode('', \\array_slice(explode(\\DIRECTORY_SEPARATOR, substr($href, 1 - $this->attr['ellipsis'])), 0, 2))) : 0);\n        } elseif (3 < \\count($ellipsis = explode(\\DIRECTORY_SEPARATOR, $href))) {\n            $this->attr['ellipsis'] = 2 + \\strlen(implode('', \\array_slice($ellipsis, -2)));\n            $this->attr['ellipsis-type'] = 'path';\n            $this->attr['ellipsis-tail'] = 1;\n        }\n    }\n\n    private function getComposerRoot($file, &$inVendor)\n    {\n        if (null === self::$vendorRoots) {\n            self::$vendorRoots = [];\n\n            foreach (get_declared_classes() as $class) {\n                if ('C' === $class[0] && 0 === strpos($class, 'ComposerAutoloaderInit')) {\n                    $r = new \\ReflectionClass($class);\n                    $v = \\dirname(\\dirname($r->getFileName()));\n                    if (file_exists($v.'/composer/installed.json')) {\n                        self::$vendorRoots[] = $v.\\DIRECTORY_SEPARATOR;\n                    }\n                }\n            }\n        }\n        $inVendor = false;\n\n        if (isset(self::$composerRoots[$dir = \\dirname($file)])) {\n            return self::$composerRoots[$dir];\n        }\n\n        foreach (self::$vendorRoots as $root) {\n            if ($inVendor = 0 === strpos($file, $root)) {\n                return $root;\n            }\n        }\n\n        $parent = $dir;\n        while (!@file_exists($parent.'/composer.json')) {\n            if (!@file_exists($parent)) {\n                // open_basedir restriction in effect\n                break;\n            }\n            if ($parent === \\dirname($parent)) {\n                return self::$composerRoots[$dir] = false;\n            }\n\n            $parent = \\dirname($parent);\n        }\n\n        return self::$composerRoots[$dir] = $parent.\\DIRECTORY_SEPARATOR;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/MongoCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n@trigger_error('The '.__NAMESPACE__.'\\MongoCaster class is deprecated since Symfony 3.4 and will be removed in 4.0.', \\E_USER_DEPRECATED);\n\n/**\n * Casts classes from the MongoDb extension to array representation.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n *\n * @deprecated since version 3.4, to be removed in 4.0.\n */\nclass MongoCaster\n{\n    public static function castCursor(\\MongoCursorInterface $cursor, array $a, Stub $stub, $isNested)\n    {\n        if ($info = $cursor->info()) {\n            foreach ($info as $k => $v) {\n                $a[Caster::PREFIX_VIRTUAL.$k] = $v;\n            }\n        }\n        $a[Caster::PREFIX_VIRTUAL.'dead'] = $cursor->dead();\n\n        return $a;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/PdoCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Casts PDO related classes to array representation.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass PdoCaster\n{\n    private static $pdoAttributes = [\n        'CASE' => [\n            \\PDO::CASE_LOWER => 'LOWER',\n            \\PDO::CASE_NATURAL => 'NATURAL',\n            \\PDO::CASE_UPPER => 'UPPER',\n        ],\n        'ERRMODE' => [\n            \\PDO::ERRMODE_SILENT => 'SILENT',\n            \\PDO::ERRMODE_WARNING => 'WARNING',\n            \\PDO::ERRMODE_EXCEPTION => 'EXCEPTION',\n        ],\n        'TIMEOUT',\n        'PREFETCH',\n        'AUTOCOMMIT',\n        'PERSISTENT',\n        'DRIVER_NAME',\n        'SERVER_INFO',\n        'ORACLE_NULLS' => [\n            \\PDO::NULL_NATURAL => 'NATURAL',\n            \\PDO::NULL_EMPTY_STRING => 'EMPTY_STRING',\n            \\PDO::NULL_TO_STRING => 'TO_STRING',\n        ],\n        'CLIENT_VERSION',\n        'SERVER_VERSION',\n        'STATEMENT_CLASS',\n        'EMULATE_PREPARES',\n        'CONNECTION_STATUS',\n        'STRINGIFY_FETCHES',\n        'DEFAULT_FETCH_MODE' => [\n            \\PDO::FETCH_ASSOC => 'ASSOC',\n            \\PDO::FETCH_BOTH => 'BOTH',\n            \\PDO::FETCH_LAZY => 'LAZY',\n            \\PDO::FETCH_NUM => 'NUM',\n            \\PDO::FETCH_OBJ => 'OBJ',\n        ],\n    ];\n\n    public static function castPdo(\\PDO $c, array $a, Stub $stub, $isNested)\n    {\n        $attr = [];\n        $errmode = $c->getAttribute(\\PDO::ATTR_ERRMODE);\n        $c->setAttribute(\\PDO::ATTR_ERRMODE, \\PDO::ERRMODE_EXCEPTION);\n\n        foreach (self::$pdoAttributes as $k => $v) {\n            if (!isset($k[0])) {\n                $k = $v;\n                $v = [];\n            }\n\n            try {\n                $attr[$k] = 'ERRMODE' === $k ? $errmode : $c->getAttribute(\\constant('PDO::ATTR_'.$k));\n                if ($v && isset($v[$attr[$k]])) {\n                    $attr[$k] = new ConstStub($v[$attr[$k]], $attr[$k]);\n                }\n            } catch (\\Exception $e) {\n            }\n        }\n        if (isset($attr[$k = 'STATEMENT_CLASS'][1])) {\n            if ($attr[$k][1]) {\n                $attr[$k][1] = new ArgsStub($attr[$k][1], '__construct', $attr[$k][0]);\n            }\n            $attr[$k][0] = new ClassStub($attr[$k][0]);\n        }\n\n        $prefix = Caster::PREFIX_VIRTUAL;\n        $a += [\n            $prefix.'inTransaction' => method_exists($c, 'inTransaction'),\n            $prefix.'errorInfo' => $c->errorInfo(),\n            $prefix.'attributes' => new EnumStub($attr),\n        ];\n\n        if ($a[$prefix.'inTransaction']) {\n            $a[$prefix.'inTransaction'] = $c->inTransaction();\n        } else {\n            unset($a[$prefix.'inTransaction']);\n        }\n\n        if (!isset($a[$prefix.'errorInfo'][1], $a[$prefix.'errorInfo'][2])) {\n            unset($a[$prefix.'errorInfo']);\n        }\n\n        $c->setAttribute(\\PDO::ATTR_ERRMODE, $errmode);\n\n        return $a;\n    }\n\n    public static function castPdoStatement(\\PDOStatement $c, array $a, Stub $stub, $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n        $a[$prefix.'errorInfo'] = $c->errorInfo();\n\n        if (!isset($a[$prefix.'errorInfo'][1], $a[$prefix.'errorInfo'][2])) {\n            unset($a[$prefix.'errorInfo']);\n        }\n\n        return $a;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/PgSqlCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Casts pqsql resources to array representation.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass PgSqlCaster\n{\n    private static $paramCodes = [\n        'server_encoding',\n        'client_encoding',\n        'is_superuser',\n        'session_authorization',\n        'DateStyle',\n        'TimeZone',\n        'IntervalStyle',\n        'integer_datetimes',\n        'application_name',\n        'standard_conforming_strings',\n    ];\n\n    private static $transactionStatus = [\n        \\PGSQL_TRANSACTION_IDLE => 'PGSQL_TRANSACTION_IDLE',\n        \\PGSQL_TRANSACTION_ACTIVE => 'PGSQL_TRANSACTION_ACTIVE',\n        \\PGSQL_TRANSACTION_INTRANS => 'PGSQL_TRANSACTION_INTRANS',\n        \\PGSQL_TRANSACTION_INERROR => 'PGSQL_TRANSACTION_INERROR',\n        \\PGSQL_TRANSACTION_UNKNOWN => 'PGSQL_TRANSACTION_UNKNOWN',\n    ];\n\n    private static $resultStatus = [\n        \\PGSQL_EMPTY_QUERY => 'PGSQL_EMPTY_QUERY',\n        \\PGSQL_COMMAND_OK => 'PGSQL_COMMAND_OK',\n        \\PGSQL_TUPLES_OK => 'PGSQL_TUPLES_OK',\n        \\PGSQL_COPY_OUT => 'PGSQL_COPY_OUT',\n        \\PGSQL_COPY_IN => 'PGSQL_COPY_IN',\n        \\PGSQL_BAD_RESPONSE => 'PGSQL_BAD_RESPONSE',\n        \\PGSQL_NONFATAL_ERROR => 'PGSQL_NONFATAL_ERROR',\n        \\PGSQL_FATAL_ERROR => 'PGSQL_FATAL_ERROR',\n    ];\n\n    private static $diagCodes = [\n        'severity' => \\PGSQL_DIAG_SEVERITY,\n        'sqlstate' => \\PGSQL_DIAG_SQLSTATE,\n        'message' => \\PGSQL_DIAG_MESSAGE_PRIMARY,\n        'detail' => \\PGSQL_DIAG_MESSAGE_DETAIL,\n        'hint' => \\PGSQL_DIAG_MESSAGE_HINT,\n        'statement position' => \\PGSQL_DIAG_STATEMENT_POSITION,\n        'internal position' => \\PGSQL_DIAG_INTERNAL_POSITION,\n        'internal query' => \\PGSQL_DIAG_INTERNAL_QUERY,\n        'context' => \\PGSQL_DIAG_CONTEXT,\n        'file' => \\PGSQL_DIAG_SOURCE_FILE,\n        'line' => \\PGSQL_DIAG_SOURCE_LINE,\n        'function' => \\PGSQL_DIAG_SOURCE_FUNCTION,\n    ];\n\n    public static function castLargeObject($lo, array $a, Stub $stub, $isNested)\n    {\n        $a['seek position'] = pg_lo_tell($lo);\n\n        return $a;\n    }\n\n    public static function castLink($link, array $a, Stub $stub, $isNested)\n    {\n        $a['status'] = pg_connection_status($link);\n        $a['status'] = new ConstStub(\\PGSQL_CONNECTION_OK === $a['status'] ? 'PGSQL_CONNECTION_OK' : 'PGSQL_CONNECTION_BAD', $a['status']);\n        $a['busy'] = pg_connection_busy($link);\n\n        $a['transaction'] = pg_transaction_status($link);\n        if (isset(self::$transactionStatus[$a['transaction']])) {\n            $a['transaction'] = new ConstStub(self::$transactionStatus[$a['transaction']], $a['transaction']);\n        }\n\n        $a['pid'] = pg_get_pid($link);\n        $a['last error'] = pg_last_error($link);\n        $a['last notice'] = pg_last_notice($link);\n        $a['host'] = pg_host($link);\n        $a['port'] = pg_port($link);\n        $a['dbname'] = pg_dbname($link);\n        $a['options'] = pg_options($link);\n        $a['version'] = pg_version($link);\n\n        foreach (self::$paramCodes as $v) {\n            if (false !== $s = pg_parameter_status($link, $v)) {\n                $a['param'][$v] = $s;\n            }\n        }\n\n        $a['param']['client_encoding'] = pg_client_encoding($link);\n        $a['param'] = new EnumStub($a['param']);\n\n        return $a;\n    }\n\n    public static function castResult($result, array $a, Stub $stub, $isNested)\n    {\n        $a['num rows'] = pg_num_rows($result);\n        $a['status'] = pg_result_status($result);\n        if (isset(self::$resultStatus[$a['status']])) {\n            $a['status'] = new ConstStub(self::$resultStatus[$a['status']], $a['status']);\n        }\n        $a['command-completion tag'] = pg_result_status($result, \\PGSQL_STATUS_STRING);\n\n        if (-1 === $a['num rows']) {\n            foreach (self::$diagCodes as $k => $v) {\n                $a['error'][$k] = pg_result_error_field($result, $v);\n            }\n        }\n\n        $a['affected rows'] = pg_affected_rows($result);\n        $a['last OID'] = pg_last_oid($result);\n\n        $fields = pg_num_fields($result);\n\n        for ($i = 0; $i < $fields; ++$i) {\n            $field = [\n                'name' => pg_field_name($result, $i),\n                'table' => sprintf('%s (OID: %s)', pg_field_table($result, $i), pg_field_table($result, $i, true)),\n                'type' => sprintf('%s (OID: %s)', pg_field_type($result, $i), pg_field_type_oid($result, $i)),\n                'nullable' => (bool) pg_field_is_null($result, $i),\n                'storage' => pg_field_size($result, $i).' bytes',\n                'display' => pg_field_prtlen($result, $i).' chars',\n            ];\n            if (' (OID: )' === $field['table']) {\n                $field['table'] = null;\n            }\n            if ('-1 bytes' === $field['storage']) {\n                $field['storage'] = 'variable size';\n            } elseif ('1 bytes' === $field['storage']) {\n                $field['storage'] = '1 byte';\n            }\n            if ('1 chars' === $field['display']) {\n                $field['display'] = '1 char';\n            }\n            $a['fields'][] = new EnumStub($field);\n        }\n\n        return $a;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/RedisCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Casts Redis class from ext-redis to array representation.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass RedisCaster\n{\n    private static $serializer = [\n        \\Redis::SERIALIZER_NONE => 'NONE',\n        \\Redis::SERIALIZER_PHP => 'PHP',\n        2 => 'IGBINARY', // Optional Redis::SERIALIZER_IGBINARY\n    ];\n\n    public static function castRedis(\\Redis $c, array $a, Stub $stub, $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        if (\\defined('HHVM_VERSION_ID')) {\n            if (isset($a[Caster::PREFIX_PROTECTED.'serializer'])) {\n                $ser = $a[Caster::PREFIX_PROTECTED.'serializer'];\n                $a[Caster::PREFIX_PROTECTED.'serializer'] = isset(self::$serializer[$ser]) ? new ConstStub(self::$serializer[$ser], $ser) : $ser;\n            }\n\n            return $a;\n        }\n\n        if (!$connected = $c->isConnected()) {\n            return $a + [\n                $prefix.'isConnected' => $connected,\n            ];\n        }\n\n        $ser = $c->getOption(\\Redis::OPT_SERIALIZER);\n        $retry = \\defined('Redis::OPT_SCAN') ? $c->getOption(\\Redis::OPT_SCAN) : 0;\n\n        return $a + [\n            $prefix.'isConnected' => $connected,\n            $prefix.'host' => $c->getHost(),\n            $prefix.'port' => $c->getPort(),\n            $prefix.'auth' => $c->getAuth(),\n            $prefix.'dbNum' => $c->getDbNum(),\n            $prefix.'timeout' => $c->getTimeout(),\n            $prefix.'persistentId' => $c->getPersistentID(),\n            $prefix.'options' => new EnumStub([\n                'READ_TIMEOUT' => $c->getOption(\\Redis::OPT_READ_TIMEOUT),\n                'SERIALIZER' => isset(self::$serializer[$ser]) ? new ConstStub(self::$serializer[$ser], $ser) : $ser,\n                'PREFIX' => $c->getOption(\\Redis::OPT_PREFIX),\n                'SCAN' => new ConstStub($retry ? 'RETRY' : 'NORETRY', $retry),\n            ]),\n        ];\n    }\n\n    public static function castRedisArray(\\RedisArray $c, array $a, Stub $stub, $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        return $a + [\n            $prefix.'hosts' => $c->_hosts(),\n            $prefix.'function' => ClassStub::wrapCallable($c->_function()),\n        ];\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/ReflectionCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Casts Reflector related classes to array representation.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass ReflectionCaster\n{\n    private static $extraMap = [\n        'docComment' => 'getDocComment',\n        'extension' => 'getExtensionName',\n        'isDisabled' => 'isDisabled',\n        'isDeprecated' => 'isDeprecated',\n        'isInternal' => 'isInternal',\n        'isUserDefined' => 'isUserDefined',\n        'isGenerator' => 'isGenerator',\n        'isVariadic' => 'isVariadic',\n    ];\n\n    public static function castClosure(\\Closure $c, array $a, Stub $stub, $isNested, $filter = 0)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n        $c = new \\ReflectionFunction($c);\n\n        $stub->class = 'Closure'; // HHVM generates unique class names for closures\n        $a = static::castFunctionAbstract($c, $a, $stub, $isNested, $filter);\n\n        if (false === strpos($c->name, '{closure}')) {\n            $stub->class = isset($a[$prefix.'class']) ? $a[$prefix.'class']->value.'::'.$c->name : $c->name;\n            unset($a[$prefix.'class']);\n        }\n\n        if (isset($a[$prefix.'parameters'])) {\n            foreach ($a[$prefix.'parameters']->value as &$v) {\n                $param = $v;\n                $v = new EnumStub([]);\n                foreach (static::castParameter($param, [], $stub, true) as $k => $param) {\n                    if (\"\\0\" === $k[0]) {\n                        $v->value[substr($k, 3)] = $param;\n                    }\n                }\n                unset($v->value['position'], $v->value['isVariadic'], $v->value['byReference'], $v);\n            }\n        }\n\n        if (!($filter & Caster::EXCLUDE_VERBOSE) && $f = $c->getFileName()) {\n            $a[$prefix.'file'] = new LinkStub($f, $c->getStartLine());\n            $a[$prefix.'line'] = $c->getStartLine().' to '.$c->getEndLine();\n        }\n\n        $prefix = Caster::PREFIX_DYNAMIC;\n        unset($a['name'], $a[$prefix.'this'], $a[$prefix.'parameter'], $a[Caster::PREFIX_VIRTUAL.'extra']);\n\n        return $a;\n    }\n\n    public static function castGenerator(\\Generator $c, array $a, Stub $stub, $isNested)\n    {\n        if (!class_exists('ReflectionGenerator', false)) {\n            return $a;\n        }\n\n        // Cannot create ReflectionGenerator based on a terminated Generator\n        try {\n            $reflectionGenerator = new \\ReflectionGenerator($c);\n        } catch (\\Exception $e) {\n            $a[Caster::PREFIX_VIRTUAL.'closed'] = true;\n\n            return $a;\n        }\n\n        return self::castReflectionGenerator($reflectionGenerator, $a, $stub, $isNested);\n    }\n\n    public static function castType(\\ReflectionType $c, array $a, Stub $stub, $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        $a += [\n            $prefix.'name' => $c instanceof \\ReflectionNamedType ? $c->getName() : (string) $c,\n            $prefix.'allowsNull' => $c->allowsNull(),\n            $prefix.'isBuiltin' => $c->isBuiltin(),\n        ];\n\n        return $a;\n    }\n\n    public static function castReflectionGenerator(\\ReflectionGenerator $c, array $a, Stub $stub, $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        if ($c->getThis()) {\n            $a[$prefix.'this'] = new CutStub($c->getThis());\n        }\n        $function = $c->getFunction();\n        $frame = [\n            'class' => isset($function->class) ? $function->class : null,\n            'type' => isset($function->class) ? ($function->isStatic() ? '::' : '->') : null,\n            'function' => $function->name,\n            'file' => $c->getExecutingFile(),\n            'line' => $c->getExecutingLine(),\n        ];\n        if ($trace = $c->getTrace(\\DEBUG_BACKTRACE_IGNORE_ARGS)) {\n            $function = new \\ReflectionGenerator($c->getExecutingGenerator());\n            array_unshift($trace, [\n                'function' => 'yield',\n                'file' => $function->getExecutingFile(),\n                'line' => $function->getExecutingLine() - 1,\n            ]);\n            $trace[] = $frame;\n            $a[$prefix.'trace'] = new TraceStub($trace, false, 0, -1, -1);\n        } else {\n            $function = new FrameStub($frame, false, true);\n            $function = ExceptionCaster::castFrameStub($function, [], $function, true);\n            $a[$prefix.'executing'] = new EnumStub([\n                \"\\0~separator= \\0\".$frame['class'].$frame['type'].$frame['function'].'()' => $function[$prefix.'src'],\n            ]);\n        }\n\n        $a[Caster::PREFIX_VIRTUAL.'closed'] = false;\n\n        return $a;\n    }\n\n    public static function castClass(\\ReflectionClass $c, array $a, Stub $stub, $isNested, $filter = 0)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        if ($n = \\Reflection::getModifierNames($c->getModifiers())) {\n            $a[$prefix.'modifiers'] = implode(' ', $n);\n        }\n\n        self::addMap($a, $c, [\n            'extends' => 'getParentClass',\n            'implements' => 'getInterfaceNames',\n            'constants' => 'getConstants',\n        ]);\n\n        foreach ($c->getProperties() as $n) {\n            $a[$prefix.'properties'][$n->name] = $n;\n        }\n\n        foreach ($c->getMethods() as $n) {\n            $a[$prefix.'methods'][$n->name] = $n;\n        }\n\n        if (!($filter & Caster::EXCLUDE_VERBOSE) && !$isNested) {\n            self::addExtra($a, $c);\n        }\n\n        return $a;\n    }\n\n    public static function castFunctionAbstract(\\ReflectionFunctionAbstract $c, array $a, Stub $stub, $isNested, $filter = 0)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        self::addMap($a, $c, [\n            'returnsReference' => 'returnsReference',\n            'returnType' => 'getReturnType',\n            'class' => 'getClosureScopeClass',\n            'this' => 'getClosureThis',\n        ]);\n\n        if (isset($a[$prefix.'returnType'])) {\n            $v = $a[$prefix.'returnType'];\n            $v = $v instanceof \\ReflectionNamedType ? $v->getName() : (string) $v;\n            $a[$prefix.'returnType'] = new ClassStub($a[$prefix.'returnType']->allowsNull() ? '?'.$v : $v, [class_exists($v, false) || interface_exists($v, false) || trait_exists($v, false) ? $v : '', '']);\n        }\n        if (isset($a[$prefix.'class'])) {\n            $a[$prefix.'class'] = new ClassStub($a[$prefix.'class']);\n        }\n        if (isset($a[$prefix.'this'])) {\n            $a[$prefix.'this'] = new CutStub($a[$prefix.'this']);\n        }\n\n        foreach ($c->getParameters() as $v) {\n            $k = '$'.$v->name;\n            if (method_exists($v, 'isVariadic') && $v->isVariadic()) {\n                $k = '...'.$k;\n            }\n            if ($v->isPassedByReference()) {\n                $k = '&'.$k;\n            }\n            $a[$prefix.'parameters'][$k] = $v;\n        }\n        if (isset($a[$prefix.'parameters'])) {\n            $a[$prefix.'parameters'] = new EnumStub($a[$prefix.'parameters']);\n        }\n\n        if ($v = $c->getStaticVariables()) {\n            foreach ($v as $k => &$v) {\n                if (\\is_object($v)) {\n                    $a[$prefix.'use']['$'.$k] = new CutStub($v);\n                } else {\n                    $a[$prefix.'use']['$'.$k] = &$v;\n                }\n            }\n            unset($v);\n            $a[$prefix.'use'] = new EnumStub($a[$prefix.'use']);\n        }\n\n        if (!($filter & Caster::EXCLUDE_VERBOSE) && !$isNested) {\n            self::addExtra($a, $c);\n        }\n\n        // Added by HHVM\n        unset($a[Caster::PREFIX_DYNAMIC.'static']);\n\n        return $a;\n    }\n\n    public static function castMethod(\\ReflectionMethod $c, array $a, Stub $stub, $isNested)\n    {\n        $a[Caster::PREFIX_VIRTUAL.'modifiers'] = implode(' ', \\Reflection::getModifierNames($c->getModifiers()));\n\n        return $a;\n    }\n\n    public static function castParameter(\\ReflectionParameter $c, array $a, Stub $stub, $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        // Added by HHVM\n        unset($a['info']);\n\n        self::addMap($a, $c, [\n            'position' => 'getPosition',\n            'isVariadic' => 'isVariadic',\n            'byReference' => 'isPassedByReference',\n            'allowsNull' => 'allowsNull',\n        ]);\n\n        if (method_exists($c, 'getType')) {\n            if ($v = $c->getType()) {\n                $a[$prefix.'typeHint'] = $v instanceof \\ReflectionNamedType ? $v->getName() : (string) $v;\n            }\n        } elseif (preg_match('/^(?:[^ ]++ ){4}([a-zA-Z_\\x7F-\\xFF][^ ]++)/', $c, $v)) {\n            $a[$prefix.'typeHint'] = $v[1];\n        }\n\n        if (isset($a[$prefix.'typeHint'])) {\n            $v = $a[$prefix.'typeHint'];\n            $a[$prefix.'typeHint'] = new ClassStub($v, [class_exists($v, false) || interface_exists($v, false) || trait_exists($v, false) ? $v : '', '']);\n        } else {\n            unset($a[$prefix.'allowsNull']);\n        }\n\n        try {\n            $a[$prefix.'default'] = $v = $c->getDefaultValue();\n            if (method_exists($c, 'isDefaultValueConstant') && $c->isDefaultValueConstant()) {\n                $a[$prefix.'default'] = new ConstStub($c->getDefaultValueConstantName(), $v);\n            }\n            if (null === $v) {\n                unset($a[$prefix.'allowsNull']);\n            }\n        } catch (\\ReflectionException $e) {\n            if (isset($a[$prefix.'typeHint']) && $c->allowsNull() && !class_exists('ReflectionNamedType', false)) {\n                $a[$prefix.'default'] = null;\n                unset($a[$prefix.'allowsNull']);\n            }\n        }\n\n        return $a;\n    }\n\n    public static function castProperty(\\ReflectionProperty $c, array $a, Stub $stub, $isNested)\n    {\n        $a[Caster::PREFIX_VIRTUAL.'modifiers'] = implode(' ', \\Reflection::getModifierNames($c->getModifiers()));\n        self::addExtra($a, $c);\n\n        return $a;\n    }\n\n    public static function castExtension(\\ReflectionExtension $c, array $a, Stub $stub, $isNested)\n    {\n        self::addMap($a, $c, [\n            'version' => 'getVersion',\n            'dependencies' => 'getDependencies',\n            'iniEntries' => 'getIniEntries',\n            'isPersistent' => 'isPersistent',\n            'isTemporary' => 'isTemporary',\n            'constants' => 'getConstants',\n            'functions' => 'getFunctions',\n            'classes' => 'getClasses',\n        ]);\n\n        return $a;\n    }\n\n    public static function castZendExtension(\\ReflectionZendExtension $c, array $a, Stub $stub, $isNested)\n    {\n        self::addMap($a, $c, [\n            'version' => 'getVersion',\n            'author' => 'getAuthor',\n            'copyright' => 'getCopyright',\n            'url' => 'getURL',\n        ]);\n\n        return $a;\n    }\n\n    private static function addExtra(&$a, \\Reflector $c)\n    {\n        $x = isset($a[Caster::PREFIX_VIRTUAL.'extra']) ? $a[Caster::PREFIX_VIRTUAL.'extra']->value : [];\n\n        if (method_exists($c, 'getFileName') && $m = $c->getFileName()) {\n            $x['file'] = new LinkStub($m, $c->getStartLine());\n            $x['line'] = $c->getStartLine().' to '.$c->getEndLine();\n        }\n\n        self::addMap($x, $c, self::$extraMap, '');\n\n        if ($x) {\n            $a[Caster::PREFIX_VIRTUAL.'extra'] = new EnumStub($x);\n        }\n    }\n\n    private static function addMap(&$a, \\Reflector $c, $map, $prefix = Caster::PREFIX_VIRTUAL)\n    {\n        foreach ($map as $k => $m) {\n            if (\\PHP_VERSION_ID >= 80000 && 'isDisabled' === $k) {\n                continue;\n            }\n\n            if (method_exists($c, $m) && false !== ($m = $c->$m()) && null !== $m) {\n                $a[$prefix.$k] = $m instanceof \\Reflector ? $m->name : $m;\n            }\n        }\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/ResourceCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Casts common resource types to array representation.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass ResourceCaster\n{\n    /**\n     * @param \\CurlHandle|resource $h\n     *\n     * @return array\n     */\n    public static function castCurl($h, array $a, Stub $stub, $isNested)\n    {\n        return curl_getinfo($h);\n    }\n\n    public static function castDba($dba, array $a, Stub $stub, $isNested)\n    {\n        $list = dba_list();\n        $a['file'] = $list[(int) $dba];\n\n        return $a;\n    }\n\n    public static function castProcess($process, array $a, Stub $stub, $isNested)\n    {\n        return proc_get_status($process);\n    }\n\n    public static function castStream($stream, array $a, Stub $stub, $isNested)\n    {\n        $a = stream_get_meta_data($stream) + static::castStreamContext($stream, $a, $stub, $isNested);\n        if (isset($a['uri'])) {\n            $a['uri'] = new LinkStub($a['uri']);\n        }\n\n        return $a;\n    }\n\n    public static function castStreamContext($stream, array $a, Stub $stub, $isNested)\n    {\n        return @stream_context_get_params($stream) ?: $a;\n    }\n\n    public static function castGd($gd, array $a, Stub $stub, $isNested)\n    {\n        $a['size'] = imagesx($gd).'x'.imagesy($gd);\n        $a['trueColor'] = imageistruecolor($gd);\n\n        return $a;\n    }\n\n    public static function castMysqlLink($h, array $a, Stub $stub, $isNested)\n    {\n        $a['host'] = mysql_get_host_info($h);\n        $a['protocol'] = mysql_get_proto_info($h);\n        $a['server'] = mysql_get_server_info($h);\n\n        return $a;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/SplCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Casts SPL related classes to array representation.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass SplCaster\n{\n    private static $splFileObjectFlags = [\n        \\SplFileObject::DROP_NEW_LINE => 'DROP_NEW_LINE',\n        \\SplFileObject::READ_AHEAD => 'READ_AHEAD',\n        \\SplFileObject::SKIP_EMPTY => 'SKIP_EMPTY',\n        \\SplFileObject::READ_CSV => 'READ_CSV',\n    ];\n\n    public static function castArrayObject(\\ArrayObject $c, array $a, Stub $stub, $isNested)\n    {\n        return self::castSplArray($c, $a, $stub, $isNested);\n    }\n\n    public static function castArrayIterator(\\ArrayIterator $c, array $a, Stub $stub, $isNested)\n    {\n        return self::castSplArray($c, $a, $stub, $isNested);\n    }\n\n    public static function castHeap(\\Iterator $c, array $a, Stub $stub, $isNested)\n    {\n        $a += [\n            Caster::PREFIX_VIRTUAL.'heap' => iterator_to_array(clone $c),\n        ];\n\n        return $a;\n    }\n\n    public static function castDoublyLinkedList(\\SplDoublyLinkedList $c, array $a, Stub $stub, $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n        $mode = $c->getIteratorMode();\n        $c->setIteratorMode(\\SplDoublyLinkedList::IT_MODE_KEEP | $mode & ~\\SplDoublyLinkedList::IT_MODE_DELETE);\n\n        $a += [\n            $prefix.'mode' => new ConstStub((($mode & \\SplDoublyLinkedList::IT_MODE_LIFO) ? 'IT_MODE_LIFO' : 'IT_MODE_FIFO').' | '.(($mode & \\SplDoublyLinkedList::IT_MODE_DELETE) ? 'IT_MODE_DELETE' : 'IT_MODE_KEEP'), $mode),\n            $prefix.'dllist' => iterator_to_array($c),\n        ];\n        $c->setIteratorMode($mode);\n\n        return $a;\n    }\n\n    public static function castFileInfo(\\SplFileInfo $c, array $a, Stub $stub, $isNested)\n    {\n        static $map = [\n            'path' => 'getPath',\n            'filename' => 'getFilename',\n            'basename' => 'getBasename',\n            'pathname' => 'getPathname',\n            'extension' => 'getExtension',\n            'realPath' => 'getRealPath',\n            'aTime' => 'getATime',\n            'mTime' => 'getMTime',\n            'cTime' => 'getCTime',\n            'inode' => 'getInode',\n            'size' => 'getSize',\n            'perms' => 'getPerms',\n            'owner' => 'getOwner',\n            'group' => 'getGroup',\n            'type' => 'getType',\n            'writable' => 'isWritable',\n            'readable' => 'isReadable',\n            'executable' => 'isExecutable',\n            'file' => 'isFile',\n            'dir' => 'isDir',\n            'link' => 'isLink',\n            'linkTarget' => 'getLinkTarget',\n        ];\n\n        $prefix = Caster::PREFIX_VIRTUAL;\n        unset($a[\"\\0SplFileInfo\\0fileName\"]);\n        unset($a[\"\\0SplFileInfo\\0pathName\"]);\n\n        if (\\PHP_VERSION_ID < 80000) {\n            if (false === $c->getPathname()) {\n                $a[$prefix.'⚠'] = 'The parent constructor was not called: the object is in an invalid state';\n\n                return $a;\n            }\n        } else {\n            try {\n                $c->isReadable();\n            } catch (\\RuntimeException $e) {\n                if ('Object not initialized' !== $e->getMessage()) {\n                    throw $e;\n                }\n\n                $a[$prefix.'⚠'] = 'The parent constructor was not called: the object is in an invalid state';\n\n                return $a;\n            } catch (\\Error $e) {\n                if ('Object not initialized' !== $e->getMessage()) {\n                    throw $e;\n                }\n\n                $a[$prefix.'⚠'] = 'The parent constructor was not called: the object is in an invalid state';\n\n                return $a;\n            }\n        }\n\n        foreach ($map as $key => $accessor) {\n            try {\n                $a[$prefix.$key] = $c->$accessor();\n            } catch (\\Exception $e) {\n            }\n        }\n\n        if (isset($a[$prefix.'realPath'])) {\n            $a[$prefix.'realPath'] = new LinkStub($a[$prefix.'realPath']);\n        }\n\n        if (isset($a[$prefix.'perms'])) {\n            $a[$prefix.'perms'] = new ConstStub(sprintf('0%o', $a[$prefix.'perms']), $a[$prefix.'perms']);\n        }\n\n        static $mapDate = ['aTime', 'mTime', 'cTime'];\n        foreach ($mapDate as $key) {\n            if (isset($a[$prefix.$key])) {\n                $a[$prefix.$key] = new ConstStub(date('Y-m-d H:i:s', $a[$prefix.$key]), $a[$prefix.$key]);\n            }\n        }\n\n        return $a;\n    }\n\n    public static function castFileObject(\\SplFileObject $c, array $a, Stub $stub, $isNested)\n    {\n        static $map = [\n            'csvControl' => 'getCsvControl',\n            'flags' => 'getFlags',\n            'maxLineLen' => 'getMaxLineLen',\n            'fstat' => 'fstat',\n            'eof' => 'eof',\n            'key' => 'key',\n        ];\n\n        $prefix = Caster::PREFIX_VIRTUAL;\n\n        foreach ($map as $key => $accessor) {\n            try {\n                $a[$prefix.$key] = $c->$accessor();\n            } catch (\\Exception $e) {\n            }\n        }\n\n        if (isset($a[$prefix.'flags'])) {\n            $flagsArray = [];\n            foreach (self::$splFileObjectFlags as $value => $name) {\n                if ($a[$prefix.'flags'] & $value) {\n                    $flagsArray[] = $name;\n                }\n            }\n            $a[$prefix.'flags'] = new ConstStub(implode('|', $flagsArray), $a[$prefix.'flags']);\n        }\n\n        if (isset($a[$prefix.'fstat'])) {\n            $a[$prefix.'fstat'] = new CutArrayStub($a[$prefix.'fstat'], ['dev', 'ino', 'nlink', 'rdev', 'blksize', 'blocks']);\n        }\n\n        return $a;\n    }\n\n    public static function castObjectStorage(\\SplObjectStorage $c, array $a, Stub $stub, $isNested)\n    {\n        $storage = [];\n        unset($a[Caster::PREFIX_DYNAMIC.\"\\0gcdata\"]); // Don't hit https://bugs.php.net/65967\n        unset($a[\"\\0SplObjectStorage\\0storage\"]);\n\n        $clone = clone $c;\n        foreach ($clone as $obj) {\n            $storage[] = [\n                'object' => $obj,\n                'info' => $clone->getInfo(),\n             ];\n        }\n\n        $a += [\n            Caster::PREFIX_VIRTUAL.'storage' => $storage,\n        ];\n\n        return $a;\n    }\n\n    public static function castOuterIterator(\\OuterIterator $c, array $a, Stub $stub, $isNested)\n    {\n        $a[Caster::PREFIX_VIRTUAL.'innerIterator'] = $c->getInnerIterator();\n\n        return $a;\n    }\n\n    private static function castSplArray($c, array $a, Stub $stub, $isNested)\n    {\n        $prefix = Caster::PREFIX_VIRTUAL;\n        $flags = $c->getFlags();\n\n        if (!($flags & \\ArrayObject::STD_PROP_LIST)) {\n            $c->setFlags(\\ArrayObject::STD_PROP_LIST);\n            $a = Caster::castObject($c, \\get_class($c), method_exists($c, '__debugInfo'), $stub->class);\n            $c->setFlags($flags);\n        }\n        if (\\PHP_VERSION_ID < 70400) {\n            $a[$prefix.'storage'] = $c->getArrayCopy();\n        }\n        $a += [\n            $prefix.'flag::STD_PROP_LIST' => (bool) ($flags & \\ArrayObject::STD_PROP_LIST),\n            $prefix.'flag::ARRAY_AS_PROPS' => (bool) ($flags & \\ArrayObject::ARRAY_AS_PROPS),\n        ];\n        if ($c instanceof \\ArrayObject) {\n            $a[$prefix.'iteratorClass'] = new ClassStub($c->getIteratorClass());\n        }\n\n        return $a;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/StubCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Casts a caster's Stub.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass StubCaster\n{\n    public static function castStub(Stub $c, array $a, Stub $stub, $isNested)\n    {\n        if ($isNested) {\n            $stub->type = $c->type;\n            $stub->class = $c->class;\n            $stub->value = $c->value;\n            $stub->handle = $c->handle;\n            $stub->cut = $c->cut;\n            $stub->attr = $c->attr;\n\n            if (Stub::TYPE_REF === $c->type && !$c->class && \\is_string($c->value) && !preg_match('//u', $c->value)) {\n                $stub->type = Stub::TYPE_STRING;\n                $stub->class = Stub::STRING_BINARY;\n            }\n\n            $a = [];\n        }\n\n        return $a;\n    }\n\n    public static function castCutArray(CutArrayStub $c, array $a, Stub $stub, $isNested)\n    {\n        return $isNested ? $c->preservedSubset : $a;\n    }\n\n    public static function cutInternals($obj, array $a, Stub $stub, $isNested)\n    {\n        if ($isNested) {\n            $stub->cut += \\count($a);\n\n            return [];\n        }\n\n        return $a;\n    }\n\n    public static function castEnum(EnumStub $c, array $a, Stub $stub, $isNested)\n    {\n        if ($isNested) {\n            $stub->class = $c->dumpKeys ? '' : null;\n            $stub->handle = 0;\n            $stub->value = null;\n            $stub->cut = $c->cut;\n            $stub->attr = $c->attr;\n\n            $a = [];\n\n            if ($c->value) {\n                foreach (array_keys($c->value) as $k) {\n                    $keys[] = !isset($k[0]) || \"\\0\" !== $k[0] ? Caster::PREFIX_VIRTUAL.$k : $k;\n                }\n                // Preserve references with array_combine()\n                $a = array_combine($keys, $c->value);\n            }\n        }\n\n        return $a;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/SymfonyCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\nclass SymfonyCaster\n{\n    private static $requestGetters = [\n        'pathInfo' => 'getPathInfo',\n        'requestUri' => 'getRequestUri',\n        'baseUrl' => 'getBaseUrl',\n        'basePath' => 'getBasePath',\n        'method' => 'getMethod',\n        'format' => 'getRequestFormat',\n    ];\n\n    public static function castRequest(Request $request, array $a, Stub $stub, $isNested)\n    {\n        $clone = null;\n\n        foreach (self::$requestGetters as $prop => $getter) {\n            if (null === $a[Caster::PREFIX_PROTECTED.$prop]) {\n                if (null === $clone) {\n                    $clone = clone $request;\n                }\n                $a[Caster::PREFIX_VIRTUAL.$prop] = $clone->{$getter}();\n            }\n        }\n\n        return $a;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/TraceStub.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Represents a backtrace as returned by debug_backtrace() or Exception->getTrace().\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass TraceStub extends Stub\n{\n    public $keepArgs;\n    public $sliceOffset;\n    public $sliceLength;\n    public $numberingOffset;\n\n    public function __construct(array $trace, $keepArgs = true, $sliceOffset = 0, $sliceLength = null, $numberingOffset = 0)\n    {\n        $this->value = $trace;\n        $this->keepArgs = $keepArgs;\n        $this->sliceOffset = $sliceOffset;\n        $this->sliceLength = $sliceLength;\n        $this->numberingOffset = $numberingOffset;\n    }\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/XmlReaderCaster.php',
    "<?php\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Casts XmlReader class to array representation.\n *\n * @author Baptiste Clavié <clavie.b@gmail.com>\n */\nclass XmlReaderCaster\n{\n    private static $nodeTypes = [\n        \\XMLReader::NONE => 'NONE',\n        \\XMLReader::ELEMENT => 'ELEMENT',\n        \\XMLReader::ATTRIBUTE => 'ATTRIBUTE',\n        \\XMLReader::TEXT => 'TEXT',\n        \\XMLReader::CDATA => 'CDATA',\n        \\XMLReader::ENTITY_REF => 'ENTITY_REF',\n        \\XMLReader::ENTITY => 'ENTITY',\n        \\XMLReader::PI => 'PI (Processing Instruction)',\n        \\XMLReader::COMMENT => 'COMMENT',\n        \\XMLReader::DOC => 'DOC',\n        \\XMLReader::DOC_TYPE => 'DOC_TYPE',\n        \\XMLReader::DOC_FRAGMENT => 'DOC_FRAGMENT',\n        \\XMLReader::NOTATION => 'NOTATION',\n        \\XMLReader::WHITESPACE => 'WHITESPACE',\n        \\XMLReader::SIGNIFICANT_WHITESPACE => 'SIGNIFICANT_WHITESPACE',\n        \\XMLReader::END_ELEMENT => 'END_ELEMENT',\n        \\XMLReader::END_ENTITY => 'END_ENTITY',\n        \\XMLReader::XML_DECLARATION => 'XML_DECLARATION',\n    ];\n\n    public static function castXmlReader(\\XMLReader $reader, array $a, Stub $stub, $isNested)\n    {\n        $props = Caster::PREFIX_VIRTUAL.'parserProperties';\n        $info = [\n            'localName' => $reader->localName,\n            'prefix' => $reader->prefix,\n            'nodeType' => new ConstStub(self::$nodeTypes[$reader->nodeType], $reader->nodeType),\n            'depth' => $reader->depth,\n            'isDefault' => $reader->isDefault,\n            'isEmptyElement' => \\XMLReader::NONE === $reader->nodeType ? null : $reader->isEmptyElement,\n            'xmlLang' => $reader->xmlLang,\n            'attributeCount' => $reader->attributeCount,\n            'value' => $reader->value,\n            'namespaceURI' => $reader->namespaceURI,\n            'baseURI' => $reader->baseURI ? new LinkStub($reader->baseURI) : $reader->baseURI,\n            $props => [\n                'LOADDTD' => $reader->getParserProperty(\\XMLReader::LOADDTD),\n                'DEFAULTATTRS' => $reader->getParserProperty(\\XMLReader::DEFAULTATTRS),\n                'VALIDATE' => $reader->getParserProperty(\\XMLReader::VALIDATE),\n                'SUBST_ENTITIES' => $reader->getParserProperty(\\XMLReader::SUBST_ENTITIES),\n            ],\n        ];\n\n        if ($info[$props] = Caster::filter($info[$props], Caster::EXCLUDE_EMPTY, [], $count)) {\n            $info[$props] = new EnumStub($info[$props]);\n            $info[$props]->cut = $count;\n        }\n\n        $info = Caster::filter($info, Caster::EXCLUDE_EMPTY, [], $count);\n        // +2 because hasValue and hasAttributes are always filtered\n        $stub->cut += $count + 2;\n\n        return $a + $info;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Caster/XmlResourceCaster.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Caster;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * Casts XML resources to array representation.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass XmlResourceCaster\n{\n    private static $xmlErrors = [\n        \\XML_ERROR_NONE => 'XML_ERROR_NONE',\n        \\XML_ERROR_NO_MEMORY => 'XML_ERROR_NO_MEMORY',\n        \\XML_ERROR_SYNTAX => 'XML_ERROR_SYNTAX',\n        \\XML_ERROR_NO_ELEMENTS => 'XML_ERROR_NO_ELEMENTS',\n        \\XML_ERROR_INVALID_TOKEN => 'XML_ERROR_INVALID_TOKEN',\n        \\XML_ERROR_UNCLOSED_TOKEN => 'XML_ERROR_UNCLOSED_TOKEN',\n        \\XML_ERROR_PARTIAL_CHAR => 'XML_ERROR_PARTIAL_CHAR',\n        \\XML_ERROR_TAG_MISMATCH => 'XML_ERROR_TAG_MISMATCH',\n        \\XML_ERROR_DUPLICATE_ATTRIBUTE => 'XML_ERROR_DUPLICATE_ATTRIBUTE',\n        \\XML_ERROR_JUNK_AFTER_DOC_ELEMENT => 'XML_ERROR_JUNK_AFTER_DOC_ELEMENT',\n        \\XML_ERROR_PARAM_ENTITY_REF => 'XML_ERROR_PARAM_ENTITY_REF',\n        \\XML_ERROR_UNDEFINED_ENTITY => 'XML_ERROR_UNDEFINED_ENTITY',\n        \\XML_ERROR_RECURSIVE_ENTITY_REF => 'XML_ERROR_RECURSIVE_ENTITY_REF',\n        \\XML_ERROR_ASYNC_ENTITY => 'XML_ERROR_ASYNC_ENTITY',\n        \\XML_ERROR_BAD_CHAR_REF => 'XML_ERROR_BAD_CHAR_REF',\n        \\XML_ERROR_BINARY_ENTITY_REF => 'XML_ERROR_BINARY_ENTITY_REF',\n        \\XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF => 'XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF',\n        \\XML_ERROR_MISPLACED_XML_PI => 'XML_ERROR_MISPLACED_XML_PI',\n        \\XML_ERROR_UNKNOWN_ENCODING => 'XML_ERROR_UNKNOWN_ENCODING',\n        \\XML_ERROR_INCORRECT_ENCODING => 'XML_ERROR_INCORRECT_ENCODING',\n        \\XML_ERROR_UNCLOSED_CDATA_SECTION => 'XML_ERROR_UNCLOSED_CDATA_SECTION',\n        \\XML_ERROR_EXTERNAL_ENTITY_HANDLING => 'XML_ERROR_EXTERNAL_ENTITY_HANDLING',\n    ];\n\n    public static function castXml($h, array $a, Stub $stub, $isNested)\n    {\n        $a['current_byte_index'] = xml_get_current_byte_index($h);\n        $a['current_column_number'] = xml_get_current_column_number($h);\n        $a['current_line_number'] = xml_get_current_line_number($h);\n        $a['error_code'] = xml_get_error_code($h);\n\n        if (isset(self::$xmlErrors[$a['error_code']])) {\n            $a['error_code'] = new ConstStub(self::$xmlErrors[$a['error_code']], $a['error_code']);\n        }\n\n        return $a;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/CHANGELOG.md',
    'CHANGELOG\n=========\n\n3.4.0\n-----\n\n * added `AbstractCloner::setMinDepth()` function to ensure minimum tree depth\n * deprecated `MongoCaster`\n\n2.7.0\n-----\n\n * deprecated Cloner\\Data::getLimitedClone(). Use withMaxDepth, withMaxItemsPerDepth or withRefHandles instead.\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Cloner/AbstractCloner.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Cloner;\n\nuse Symfony\\Component\\VarDumper\\Caster\\Caster;\nuse Symfony\\Component\\VarDumper\\Exception\\ThrowingCasterException;\n\n/**\n * AbstractCloner implements a generic caster mechanism for objects and resources.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nabstract class AbstractCloner implements ClonerInterface\n{\n    public static $defaultCasters = [\n        '__PHP_Incomplete_Class' => ['Symfony\\Component\\VarDumper\\Caster\\Caster', 'castPhpIncompleteClass'],\n\n        'Symfony\\Component\\VarDumper\\Caster\\CutStub' => ['Symfony\\Component\\VarDumper\\Caster\\StubCaster', 'castStub'],\n        'Symfony\\Component\\VarDumper\\Caster\\CutArrayStub' => ['Symfony\\Component\\VarDumper\\Caster\\StubCaster', 'castCutArray'],\n        'Symfony\\Component\\VarDumper\\Caster\\ConstStub' => ['Symfony\\Component\\VarDumper\\Caster\\StubCaster', 'castStub'],\n        'Symfony\\Component\\VarDumper\\Caster\\EnumStub' => ['Symfony\\Component\\VarDumper\\Caster\\StubCaster', 'castEnum'],\n\n        'Closure' => ['Symfony\\Component\\VarDumper\\Caster\\ReflectionCaster', 'castClosure'],\n        'Generator' => ['Symfony\\Component\\VarDumper\\Caster\\ReflectionCaster', 'castGenerator'],\n        'ReflectionType' => ['Symfony\\Component\\VarDumper\\Caster\\ReflectionCaster', 'castType'],\n        'ReflectionGenerator' => ['Symfony\\Component\\VarDumper\\Caster\\ReflectionCaster', 'castReflectionGenerator'],\n        'ReflectionClass' => ['Symfony\\Component\\VarDumper\\Caster\\ReflectionCaster', 'castClass'],\n        'ReflectionFunctionAbstract' => ['Symfony\\Component\\VarDumper\\Caster\\ReflectionCaster', 'castFunctionAbstract'],\n        'ReflectionMethod' => ['Symfony\\Component\\VarDumper\\Caster\\ReflectionCaster', 'castMethod'],\n        'ReflectionParameter' => ['Symfony\\Component\\VarDumper\\Caster\\ReflectionCaster', 'castParameter'],\n        'ReflectionProperty' => ['Symfony\\Component\\VarDumper\\Caster\\ReflectionCaster', 'castProperty'],\n        'ReflectionExtension' => ['Symfony\\Component\\VarDumper\\Caster\\ReflectionCaster', 'castExtension'],\n        'ReflectionZendExtension' => ['Symfony\\Component\\VarDumper\\Caster\\ReflectionCaster', 'castZendExtension'],\n\n        'Doctrine\\Common\\Persistence\\ObjectManager' => ['Symfony\\Component\\VarDumper\\Caster\\StubCaster', 'cutInternals'],\n        'Doctrine\\Common\\Proxy\\Proxy' => ['Symfony\\Component\\VarDumper\\Caster\\DoctrineCaster', 'castCommonProxy'],\n        'Doctrine\\ORM\\Proxy\\Proxy' => ['Symfony\\Component\\VarDumper\\Caster\\DoctrineCaster', 'castOrmProxy'],\n        'Doctrine\\ORM\\PersistentCollection' => ['Symfony\\Component\\VarDumper\\Caster\\DoctrineCaster', 'castPersistentCollection'],\n        'Doctrine\\Persistence\\ObjectManager' => ['Symfony\\Component\\VarDumper\\Caster\\StubCaster', 'cutInternals'],\n\n        'DOMException' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castException'],\n        'DOMStringList' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castLength'],\n        'DOMNameList' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castLength'],\n        'DOMImplementation' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castImplementation'],\n        'DOMImplementationList' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castLength'],\n        'DOMNode' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castNode'],\n        'DOMNameSpaceNode' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castNameSpaceNode'],\n        'DOMDocument' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castDocument'],\n        'DOMNodeList' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castLength'],\n        'DOMNamedNodeMap' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castLength'],\n        'DOMCharacterData' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castCharacterData'],\n        'DOMAttr' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castAttr'],\n        'DOMElement' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castElement'],\n        'DOMText' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castText'],\n        'DOMTypeinfo' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castTypeinfo'],\n        'DOMDomError' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castDomError'],\n        'DOMLocator' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castLocator'],\n        'DOMDocumentType' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castDocumentType'],\n        'DOMNotation' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castNotation'],\n        'DOMEntity' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castEntity'],\n        'DOMProcessingInstruction' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castProcessingInstruction'],\n        'DOMXPath' => ['Symfony\\Component\\VarDumper\\Caster\\DOMCaster', 'castXPath'],\n\n        'XmlReader' => ['Symfony\\Component\\VarDumper\\Caster\\XmlReaderCaster', 'castXmlReader'],\n\n        'ErrorException' => ['Symfony\\Component\\VarDumper\\Caster\\ExceptionCaster', 'castErrorException'],\n        'Exception' => ['Symfony\\Component\\VarDumper\\Caster\\ExceptionCaster', 'castException'],\n        'Error' => ['Symfony\\Component\\VarDumper\\Caster\\ExceptionCaster', 'castError'],\n        'Symfony\\Component\\DependencyInjection\\ContainerInterface' => ['Symfony\\Component\\VarDumper\\Caster\\StubCaster', 'cutInternals'],\n        'Symfony\\Component\\HttpFoundation\\Request' => ['Symfony\\Component\\VarDumper\\Caster\\SymfonyCaster', 'castRequest'],\n        'Symfony\\Component\\VarDumper\\Exception\\ThrowingCasterException' => ['Symfony\\Component\\VarDumper\\Caster\\ExceptionCaster', 'castThrowingCasterException'],\n        'Symfony\\Component\\VarDumper\\Caster\\TraceStub' => ['Symfony\\Component\\VarDumper\\Caster\\ExceptionCaster', 'castTraceStub'],\n        'Symfony\\Component\\VarDumper\\Caster\\FrameStub' => ['Symfony\\Component\\VarDumper\\Caster\\ExceptionCaster', 'castFrameStub'],\n        'Symfony\\Component\\Debug\\Exception\\SilencedErrorContext' => ['Symfony\\Component\\VarDumper\\Caster\\ExceptionCaster', 'castSilencedErrorContext'],\n\n        'PHPUnit_Framework_MockObject_MockObject' => ['Symfony\\Component\\VarDumper\\Caster\\StubCaster', 'cutInternals'],\n        'PHPUnit\\Framework\\MockObject\\MockObject' => ['Symfony\\Component\\VarDumper\\Caster\\StubCaster', 'cutInternals'],\n        'PHPUnit\\Framework\\MockObject\\Stub' => ['Symfony\\Component\\VarDumper\\Caster\\StubCaster', 'cutInternals'],\n        'Prophecy\\Prophecy\\ProphecySubjectInterface' => ['Symfony\\Component\\VarDumper\\Caster\\StubCaster', 'cutInternals'],\n        'Mockery\\MockInterface' => ['Symfony\\Component\\VarDumper\\Caster\\StubCaster', 'cutInternals'],\n\n        'PDO' => ['Symfony\\Component\\VarDumper\\Caster\\PdoCaster', 'castPdo'],\n        'PDOStatement' => ['Symfony\\Component\\VarDumper\\Caster\\PdoCaster', 'castPdoStatement'],\n\n        'AMQPConnection' => ['Symfony\\Component\\VarDumper\\Caster\\AmqpCaster', 'castConnection'],\n        'AMQPChannel' => ['Symfony\\Component\\VarDumper\\Caster\\AmqpCaster', 'castChannel'],\n        'AMQPQueue' => ['Symfony\\Component\\VarDumper\\Caster\\AmqpCaster', 'castQueue'],\n        'AMQPExchange' => ['Symfony\\Component\\VarDumper\\Caster\\AmqpCaster', 'castExchange'],\n        'AMQPEnvelope' => ['Symfony\\Component\\VarDumper\\Caster\\AmqpCaster', 'castEnvelope'],\n\n        'ArrayObject' => ['Symfony\\Component\\VarDumper\\Caster\\SplCaster', 'castArrayObject'],\n        'ArrayIterator' => ['Symfony\\Component\\VarDumper\\Caster\\SplCaster', 'castArrayIterator'],\n        'SplDoublyLinkedList' => ['Symfony\\Component\\VarDumper\\Caster\\SplCaster', 'castDoublyLinkedList'],\n        'SplFileInfo' => ['Symfony\\Component\\VarDumper\\Caster\\SplCaster', 'castFileInfo'],\n        'SplFileObject' => ['Symfony\\Component\\VarDumper\\Caster\\SplCaster', 'castFileObject'],\n        'SplHeap' => ['Symfony\\Component\\VarDumper\\Caster\\SplCaster', 'castHeap'],\n        'SplObjectStorage' => ['Symfony\\Component\\VarDumper\\Caster\\SplCaster', 'castObjectStorage'],\n        'SplPriorityQueue' => ['Symfony\\Component\\VarDumper\\Caster\\SplCaster', 'castHeap'],\n        'OuterIterator' => ['Symfony\\Component\\VarDumper\\Caster\\SplCaster', 'castOuterIterator'],\n\n        'MongoCursorInterface' => ['Symfony\\Component\\VarDumper\\Caster\\MongoCaster', 'castCursor'],\n\n        'Redis' => ['Symfony\\Component\\VarDumper\\Caster\\RedisCaster', 'castRedis'],\n        'RedisArray' => ['Symfony\\Component\\VarDumper\\Caster\\RedisCaster', 'castRedisArray'],\n\n        'DateTimeInterface' => ['Symfony\\Component\\VarDumper\\Caster\\DateCaster', 'castDateTime'],\n        'DateInterval' => ['Symfony\\Component\\VarDumper\\Caster\\DateCaster', 'castInterval'],\n        'DateTimeZone' => ['Symfony\\Component\\VarDumper\\Caster\\DateCaster', 'castTimeZone'],\n        'DatePeriod' => ['Symfony\\Component\\VarDumper\\Caster\\DateCaster', 'castPeriod'],\n\n        'CurlHandle' => ['Symfony\\Component\\VarDumper\\Caster\\ResourceCaster', 'castCurl'],\n        ':curl' => ['Symfony\\Component\\VarDumper\\Caster\\ResourceCaster', 'castCurl'],\n\n        ':dba' => ['Symfony\\Component\\VarDumper\\Caster\\ResourceCaster', 'castDba'],\n        ':dba persistent' => ['Symfony\\Component\\VarDumper\\Caster\\ResourceCaster', 'castDba'],\n        ':gd' => ['Symfony\\Component\\VarDumper\\Caster\\ResourceCaster', 'castGd'],\n        ':mysql link' => ['Symfony\\Component\\VarDumper\\Caster\\ResourceCaster', 'castMysqlLink'],\n        ':pgsql large object' => ['Symfony\\Component\\VarDumper\\Caster\\PgSqlCaster', 'castLargeObject'],\n        ':pgsql link' => ['Symfony\\Component\\VarDumper\\Caster\\PgSqlCaster', 'castLink'],\n        ':pgsql link persistent' => ['Symfony\\Component\\VarDumper\\Caster\\PgSqlCaster', 'castLink'],\n        ':pgsql result' => ['Symfony\\Component\\VarDumper\\Caster\\PgSqlCaster', 'castResult'],\n        ':process' => ['Symfony\\Component\\VarDumper\\Caster\\ResourceCaster', 'castProcess'],\n        ':stream' => ['Symfony\\Component\\VarDumper\\Caster\\ResourceCaster', 'castStream'],\n        ':persistent stream' => ['Symfony\\Component\\VarDumper\\Caster\\ResourceCaster', 'castStream'],\n        ':stream-context' => ['Symfony\\Component\\VarDumper\\Caster\\ResourceCaster', 'castStreamContext'],\n        ':xml' => ['Symfony\\Component\\VarDumper\\Caster\\XmlResourceCaster', 'castXml'],\n    ];\n\n    protected $maxItems = 2500;\n    protected $maxString = -1;\n    protected $minDepth = 1;\n    protected $useExt;\n\n    private $casters = [];\n    private $prevErrorHandler;\n    private $classInfo = [];\n    private $filter = 0;\n\n    /**\n     * @param callable[]|null $casters A map of casters\n     *\n     * @see addCasters\n     */\n    public function __construct(array $casters = null)\n    {\n        if (null === $casters) {\n            $casters = static::$defaultCasters;\n        }\n        $this->addCasters($casters);\n        $this->useExt = \\extension_loaded('symfony_debug');\n    }\n\n    /**\n     * Adds casters for resources and objects.\n     *\n     * Maps resources or objects types to a callback.\n     * Types are in the key, with a callable caster for value.\n     * Resource types are to be prefixed with a `:`,\n     * see e.g. static::$defaultCasters.\n     *\n     * @param callable[] $casters A map of casters\n     */\n    public function addCasters(array $casters)\n    {\n        foreach ($casters as $type => $callback) {\n            $this->casters[strtolower($type)][] = \\is_string($callback) && false !== strpos($callback, '::') ? explode('::', $callback, 2) : $callback;\n        }\n    }\n\n    /**\n     * Sets the maximum number of items to clone past the minimum depth in nested structures.\n     *\n     * @param int $maxItems\n     */\n    public function setMaxItems($maxItems)\n    {\n        $this->maxItems = (int) $maxItems;\n    }\n\n    /**\n     * Sets the maximum cloned length for strings.\n     *\n     * @param int $maxString\n     */\n    public function setMaxString($maxString)\n    {\n        $this->maxString = (int) $maxString;\n    }\n\n    /**\n     * Sets the minimum tree depth where we are guaranteed to clone all the items.  After this\n     * depth is reached, only setMaxItems items will be cloned.\n     *\n     * @param int $minDepth\n     */\n    public function setMinDepth($minDepth)\n    {\n        $this->minDepth = (int) $minDepth;\n    }\n\n    /**\n     * Clones a PHP variable.\n     *\n     * @param mixed $var    Any PHP variable\n     * @param int   $filter A bit field of Caster::EXCLUDE_* constants\n     *\n     * @return Data The cloned variable represented by a Data object\n     */\n    public function cloneVar($var, $filter = 0)\n    {\n        $this->prevErrorHandler = set_error_handler(function ($type, $msg, $file, $line, $context = []) {\n            if (\\E_RECOVERABLE_ERROR === $type || \\E_USER_ERROR === $type) {\n                // Cloner never dies\n                throw new \\ErrorException($msg, 0, $type, $file, $line);\n            }\n\n            if ($this->prevErrorHandler) {\n                return \\call_user_func($this->prevErrorHandler, $type, $msg, $file, $line, $context);\n            }\n\n            return false;\n        });\n        $this->filter = $filter;\n\n        if ($gc = gc_enabled()) {\n            gc_disable();\n        }\n        try {\n            return new Data($this->doClone($var));\n        } finally {\n            if ($gc) {\n                gc_enable();\n            }\n            restore_error_handler();\n            $this->prevErrorHandler = null;\n        }\n    }\n\n    /**\n     * Effectively clones the PHP variable.\n     *\n     * @param mixed $var Any PHP variable\n     *\n     * @return array The cloned variable represented in an array\n     */\n    abstract protected function doClone($var);\n\n    /**\n     * Casts an object to an array representation.\n     *\n     * @param Stub $stub     The Stub for the casted object\n     * @param bool $isNested True if the object is nested in the dumped structure\n     *\n     * @return array The object casted as array\n     */\n    protected function castObject(Stub $stub, $isNested)\n    {\n        $obj = $stub->value;\n        $class = $stub->class;\n\n        if ((\\PHP_VERSION_ID >= 80000 || (isset($class[15]) && \"\\0\" === $class[15])) && false !== strpos($class, \"@anonymous\\0\")) {\n            $stub->class = \\PHP_VERSION_ID < 80000 ? (get_parent_class($class) ?: key(class_implements($class)) ?: 'class').'@anonymous' : get_debug_type($obj);\n        }\n        if (isset($this->classInfo[$class])) {\n            list($i, $parents, $hasDebugInfo) = $this->classInfo[$class];\n        } else {\n            $i = 2;\n            $parents = [strtolower($class)];\n            $hasDebugInfo = method_exists($class, '__debugInfo');\n\n            foreach (class_parents($class) as $p) {\n                $parents[] = strtolower($p);\n                ++$i;\n            }\n            foreach (class_implements($class) as $p) {\n                $parents[] = strtolower($p);\n                ++$i;\n            }\n            $parents[] = '*';\n\n            $this->classInfo[$class] = [$i, $parents, $hasDebugInfo];\n        }\n\n        $a = Caster::castObject($obj, $class, $hasDebugInfo, $stub->class);\n\n        try {\n            while ($i--) {\n                if (!empty($this->casters[$p = $parents[$i]])) {\n                    foreach ($this->casters[$p] as $callback) {\n                        $a = $callback($obj, $a, $stub, $isNested, $this->filter);\n                    }\n                }\n            }\n        } catch (\\Exception $e) {\n            $a = [(Stub::TYPE_OBJECT === $stub->type ? Caster::PREFIX_VIRTUAL : '').'⚠' => new ThrowingCasterException($e)] + $a;\n        }\n\n        return $a;\n    }\n\n    /**\n     * Casts a resource to an array representation.\n     *\n     * @param Stub $stub     The Stub for the casted resource\n     * @param bool $isNested True if the object is nested in the dumped structure\n     *\n     * @return array The resource casted as array\n     */\n    protected function castResource(Stub $stub, $isNested)\n    {\n        $a = [];\n        $res = $stub->value;\n        $type = $stub->class;\n\n        try {\n            if (!empty($this->casters[':'.$type])) {\n                foreach ($this->casters[':'.$type] as $callback) {\n                    $a = $callback($res, $a, $stub, $isNested, $this->filter);\n                }\n            }\n        } catch (\\Exception $e) {\n            $a = [(Stub::TYPE_OBJECT === $stub->type ? Caster::PREFIX_VIRTUAL : '').'⚠' => new ThrowingCasterException($e)] + $a;\n        }\n\n        return $a;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Cloner/ClonerInterface.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Cloner;\n\n/**\n * @author Nicolas Grekas <p@tchwork.com>\n */\ninterface ClonerInterface\n{\n    /**\n     * Clones a PHP variable.\n     *\n     * @param mixed $var Any PHP variable\n     *\n     * @return Data The cloned variable represented by a Data object\n     */\n    public function cloneVar($var);\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Cloner/Cursor.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Cloner;\n\n/**\n * Represents the current state of a dumper while dumping.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass Cursor\n{\n    const HASH_INDEXED = Stub::ARRAY_INDEXED;\n    const HASH_ASSOC = Stub::ARRAY_ASSOC;\n    const HASH_OBJECT = Stub::TYPE_OBJECT;\n    const HASH_RESOURCE = Stub::TYPE_RESOURCE;\n\n    public $depth = 0;\n    public $refIndex = 0;\n    public $softRefTo = 0;\n    public $softRefCount = 0;\n    public $softRefHandle = 0;\n    public $hardRefTo = 0;\n    public $hardRefCount = 0;\n    public $hardRefHandle = 0;\n    public $hashType;\n    public $hashKey;\n    public $hashKeyIsBinary;\n    public $hashIndex = 0;\n    public $hashLength = 0;\n    public $hashCut = 0;\n    public $stop = false;\n    public $attr = [];\n    public $skipChildren = false;\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Cloner/Data.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Cloner;\n\nuse Symfony\\Component\\VarDumper\\Caster\\Caster;\n\n/**\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass Data implements \\ArrayAccess, \\Countable, \\IteratorAggregate\n{\n    private $data;\n    private $position = 0;\n    private $key = 0;\n    private $maxDepth = 20;\n    private $maxItemsPerDepth = -1;\n    private $useRefHandles = -1;\n\n    /**\n     * @param array $data An array as returned by ClonerInterface::cloneVar()\n     */\n    public function __construct(array $data)\n    {\n        $this->data = $data;\n    }\n\n    /**\n     * @return string|null The type of the value\n     */\n    public function getType()\n    {\n        $item = $this->data[$this->position][$this->key];\n\n        if ($item instanceof Stub && Stub::TYPE_REF === $item->type && !$item->position) {\n            $item = $item->value;\n        }\n        if (!$item instanceof Stub) {\n            return \\gettype($item);\n        }\n        if (Stub::TYPE_STRING === $item->type) {\n            return 'string';\n        }\n        if (Stub::TYPE_ARRAY === $item->type) {\n            return 'array';\n        }\n        if (Stub::TYPE_OBJECT === $item->type) {\n            return $item->class;\n        }\n        if (Stub::TYPE_RESOURCE === $item->type) {\n            return $item->class.' resource';\n        }\n\n        return null;\n    }\n\n    /**\n     * @param array|bool $recursive Whether values should be resolved recursively or not\n     *\n     * @return string|int|float|bool|array|Data[]|null A native representation of the original value\n     */\n    public function getValue($recursive = false)\n    {\n        $item = $this->data[$this->position][$this->key];\n\n        if ($item instanceof Stub && Stub::TYPE_REF === $item->type && !$item->position) {\n            $item = $item->value;\n        }\n        if (!($item = $this->getStub($item)) instanceof Stub) {\n            return $item;\n        }\n        if (Stub::TYPE_STRING === $item->type) {\n            return $item->value;\n        }\n\n        $children = $item->position ? $this->data[$item->position] : [];\n\n        foreach ($children as $k => $v) {\n            if ($recursive && !($v = $this->getStub($v)) instanceof Stub) {\n                continue;\n            }\n            $children[$k] = clone $this;\n            $children[$k]->key = $k;\n            $children[$k]->position = $item->position;\n\n            if ($recursive) {\n                if (Stub::TYPE_REF === $v->type && ($v = $this->getStub($v->value)) instanceof Stub) {\n                    $recursive = (array) $recursive;\n                    if (isset($recursive[$v->position])) {\n                        continue;\n                    }\n                    $recursive[$v->position] = true;\n                }\n                $children[$k] = $children[$k]->getValue($recursive);\n            }\n        }\n\n        return $children;\n    }\n\n    public function count()\n    {\n        return \\count($this->getValue());\n    }\n\n    public function getIterator()\n    {\n        if (!\\is_array($value = $this->getValue())) {\n            throw new \\LogicException(sprintf('\"%s\" object holds non-iterable type \"%s\".', self::class, \\gettype($value)));\n        }\n\n        foreach ($value as $k => $v) {\n            yield $k => $v;\n        }\n    }\n\n    public function __get($key)\n    {\n        if (null !== $data = $this->seek($key)) {\n            $item = $this->getStub($data->data[$data->position][$data->key]);\n\n            return $item instanceof Stub || [] === $item ? $data : $item;\n        }\n\n        return null;\n    }\n\n    public function __isset($key)\n    {\n        return null !== $this->seek($key);\n    }\n\n    public function offsetExists($key)\n    {\n        return $this->__isset($key);\n    }\n\n    public function offsetGet($key)\n    {\n        return $this->__get($key);\n    }\n\n    public function offsetSet($key, $value)\n    {\n        throw new \\BadMethodCallException(self::class.' objects are immutable.');\n    }\n\n    public function offsetUnset($key)\n    {\n        throw new \\BadMethodCallException(self::class.' objects are immutable.');\n    }\n\n    public function __toString()\n    {\n        $value = $this->getValue();\n\n        if (!\\is_array($value)) {\n            return (string) $value;\n        }\n\n        return sprintf('%s (count=%d)', $this->getType(), \\count($value));\n    }\n\n    /**\n     * @return array The raw data structure\n     *\n     * @deprecated since version 3.3. Use array or object access instead.\n     */\n    public function getRawData()\n    {\n        @trigger_error(sprintf('The \"%s()\" method is deprecated since Symfony 3.3 and will be removed in 4.0. Use the array or object access instead.', __METHOD__));\n\n        return $this->data;\n    }\n\n    /**\n     * Returns a depth limited clone of $this.\n     *\n     * @param int $maxDepth The max dumped depth level\n     *\n     * @return static\n     */\n    public function withMaxDepth($maxDepth)\n    {\n        $data = clone $this;\n        $data->maxDepth = (int) $maxDepth;\n\n        return $data;\n    }\n\n    /**\n     * Limits the number of elements per depth level.\n     *\n     * @param int $maxItemsPerDepth The max number of items dumped per depth level\n     *\n     * @return static\n     */\n    public function withMaxItemsPerDepth($maxItemsPerDepth)\n    {\n        $data = clone $this;\n        $data->maxItemsPerDepth = (int) $maxItemsPerDepth;\n\n        return $data;\n    }\n\n    /**\n     * Enables/disables objects' identifiers tracking.\n     *\n     * @param bool $useRefHandles False to hide global ref. handles\n     *\n     * @return static\n     */\n    public function withRefHandles($useRefHandles)\n    {\n        $data = clone $this;\n        $data->useRefHandles = $useRefHandles ? -1 : 0;\n\n        return $data;\n    }\n\n    /**\n     * Seeks to a specific key in nested data structures.\n     *\n     * @param string|int $key The key to seek to\n     *\n     * @return static|null Null if the key is not set\n     */\n    public function seek($key)\n    {\n        $item = $this->data[$this->position][$this->key];\n\n        if ($item instanceof Stub && Stub::TYPE_REF === $item->type && !$item->position) {\n            $item = $item->value;\n        }\n        if (!($item = $this->getStub($item)) instanceof Stub || !$item->position) {\n            return null;\n        }\n        $keys = [$key];\n\n        switch ($item->type) {\n            case Stub::TYPE_OBJECT:\n                $keys[] = Caster::PREFIX_DYNAMIC.$key;\n                $keys[] = Caster::PREFIX_PROTECTED.$key;\n                $keys[] = Caster::PREFIX_VIRTUAL.$key;\n                $keys[] = \"\\0$item->class\\0$key\";\n                // no break\n            case Stub::TYPE_ARRAY:\n            case Stub::TYPE_RESOURCE:\n                break;\n            default:\n                return null;\n        }\n\n        $data = null;\n        $children = $this->data[$item->position];\n\n        foreach ($keys as $key) {\n            if (isset($children[$key]) || \\array_key_exists($key, $children)) {\n                $data = clone $this;\n                $data->key = $key;\n                $data->position = $item->position;\n                break;\n            }\n        }\n\n        return $data;\n    }\n\n    /**\n     * Dumps data with a DumperInterface dumper.\n     */\n    public function dump(DumperInterface $dumper)\n    {\n        $refs = [0];\n        $this->dumpItem($dumper, new Cursor(), $refs, $this->data[$this->position][$this->key]);\n    }\n\n    /**\n     * Depth-first dumping of items.\n     *\n     * @param DumperInterface $dumper The dumper being used for dumping\n     * @param Cursor          $cursor A cursor used for tracking dumper state position\n     * @param array           &$refs  A map of all references discovered while dumping\n     * @param mixed           $item   A Stub object or the original value being dumped\n     */\n    private function dumpItem($dumper, $cursor, &$refs, $item)\n    {\n        $cursor->refIndex = 0;\n        $cursor->softRefTo = $cursor->softRefHandle = $cursor->softRefCount = 0;\n        $cursor->hardRefTo = $cursor->hardRefHandle = $cursor->hardRefCount = 0;\n        $firstSeen = true;\n\n        if (!$item instanceof Stub) {\n            $cursor->attr = [];\n            $type = \\gettype($item);\n            if ($item && 'array' === $type) {\n                $item = $this->getStub($item);\n            }\n        } elseif (Stub::TYPE_REF === $item->type) {\n            if ($item->handle) {\n                if (!isset($refs[$r = $item->handle - (\\PHP_INT_MAX >> 1)])) {\n                    $cursor->refIndex = $refs[$r] = $cursor->refIndex ?: ++$refs[0];\n                } else {\n                    $firstSeen = false;\n                }\n                $cursor->hardRefTo = $refs[$r];\n                $cursor->hardRefHandle = $this->useRefHandles & $item->handle;\n                $cursor->hardRefCount = $item->refCount;\n            }\n            $cursor->attr = $item->attr;\n            $type = $item->class ?: \\gettype($item->value);\n            $item = $this->getStub($item->value);\n        }\n        if ($item instanceof Stub) {\n            if ($item->refCount) {\n                if (!isset($refs[$r = $item->handle])) {\n                    $cursor->refIndex = $refs[$r] = $cursor->refIndex ?: ++$refs[0];\n                } else {\n                    $firstSeen = false;\n                }\n                $cursor->softRefTo = $refs[$r];\n            }\n            $cursor->softRefHandle = $this->useRefHandles & $item->handle;\n            $cursor->softRefCount = $item->refCount;\n            $cursor->attr = $item->attr;\n            $cut = $item->cut;\n\n            if ($item->position && $firstSeen) {\n                $children = $this->data[$item->position];\n\n                if ($cursor->stop) {\n                    if ($cut >= 0) {\n                        $cut += \\count($children);\n                    }\n                    $children = [];\n                }\n            } else {\n                $children = [];\n            }\n            switch ($item->type) {\n                case Stub::TYPE_STRING:\n                    $dumper->dumpString($cursor, $item->value, Stub::STRING_BINARY === $item->class, $cut);\n                    break;\n\n                case Stub::TYPE_ARRAY:\n                    $item = clone $item;\n                    $item->type = $item->class;\n                    $item->class = $item->value;\n                    // no break\n                case Stub::TYPE_OBJECT:\n                case Stub::TYPE_RESOURCE:\n                    $withChildren = $children && $cursor->depth !== $this->maxDepth && $this->maxItemsPerDepth;\n                    $dumper->enterHash($cursor, $item->type, $item->class, $withChildren);\n                    if ($withChildren) {\n                        if ($cursor->skipChildren) {\n                            $withChildren = false;\n                            $cut = -1;\n                        } else {\n                            $cut = $this->dumpChildren($dumper, $cursor, $refs, $children, $cut, $item->type, null !== $item->class);\n                        }\n                    } elseif ($children && 0 <= $cut) {\n                        $cut += \\count($children);\n                    }\n                    $cursor->skipChildren = false;\n                    $dumper->leaveHash($cursor, $item->type, $item->class, $withChildren, $cut);\n                    break;\n\n                default:\n                    throw new \\RuntimeException(sprintf('Unexpected Stub type: \"%s\".', $item->type));\n            }\n        } elseif ('array' === $type) {\n            $dumper->enterHash($cursor, Cursor::HASH_INDEXED, 0, false);\n            $dumper->leaveHash($cursor, Cursor::HASH_INDEXED, 0, false, 0);\n        } elseif ('string' === $type) {\n            $dumper->dumpString($cursor, $item, false, 0);\n        } else {\n            $dumper->dumpScalar($cursor, $type, $item);\n        }\n    }\n\n    /**\n     * Dumps children of hash structures.\n     *\n     * @param DumperInterface $dumper\n     * @param Cursor          $parentCursor The cursor of the parent hash\n     * @param array           &$refs        A map of all references discovered while dumping\n     * @param array           $children     The children to dump\n     * @param int             $hashCut      The number of items removed from the original hash\n     * @param string          $hashType     A Cursor::HASH_* const\n     * @param bool            $dumpKeys     Whether keys should be dumped or not\n     *\n     * @return int The final number of removed items\n     */\n    private function dumpChildren($dumper, $parentCursor, &$refs, $children, $hashCut, $hashType, $dumpKeys)\n    {\n        $cursor = clone $parentCursor;\n        ++$cursor->depth;\n        $cursor->hashType = $hashType;\n        $cursor->hashIndex = 0;\n        $cursor->hashLength = \\count($children);\n        $cursor->hashCut = $hashCut;\n        foreach ($children as $key => $child) {\n            $cursor->hashKeyIsBinary = isset($key[0]) && !preg_match('//u', $key);\n            $cursor->hashKey = $dumpKeys ? $key : null;\n            $this->dumpItem($dumper, $cursor, $refs, $child);\n            if (++$cursor->hashIndex === $this->maxItemsPerDepth || $cursor->stop) {\n                $parentCursor->stop = true;\n\n                return $hashCut >= 0 ? $hashCut + $cursor->hashLength - $cursor->hashIndex : $hashCut;\n            }\n        }\n\n        return $hashCut;\n    }\n\n    private function getStub($item)\n    {\n        if (!$item || !\\is_array($item)) {\n            return $item;\n        }\n\n        $stub = new Stub();\n        $stub->type = Stub::TYPE_ARRAY;\n        foreach ($item as $stub->class => $stub->position) {\n        }\n        if (isset($item[0])) {\n            $stub->cut = $item[0];\n        }\n        $stub->value = $stub->cut + ($stub->position ? \\count($this->data[$stub->position]) : 0);\n\n        return $stub;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Cloner/DumperInterface.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Cloner;\n\n/**\n * DumperInterface used by Data objects.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\ninterface DumperInterface\n{\n    /**\n     * Dumps a scalar value.\n     *\n     * @param Cursor                $cursor The Cursor position in the dump\n     * @param string                $type   The PHP type of the value being dumped\n     * @param string|int|float|bool $value  The scalar value being dumped\n     */\n    public function dumpScalar(Cursor $cursor, $type, $value);\n\n    /**\n     * Dumps a string.\n     *\n     * @param Cursor $cursor The Cursor position in the dump\n     * @param string $str    The string being dumped\n     * @param bool   $bin    Whether $str is UTF-8 or binary encoded\n     * @param int    $cut    The number of characters $str has been cut by\n     */\n    public function dumpString(Cursor $cursor, $str, $bin, $cut);\n\n    /**\n     * Dumps while entering an hash.\n     *\n     * @param Cursor     $cursor   The Cursor position in the dump\n     * @param int        $type     A Cursor::HASH_* const for the type of hash\n     * @param string|int $class    The object class, resource type or array count\n     * @param bool       $hasChild When the dump of the hash has child item\n     */\n    public function enterHash(Cursor $cursor, $type, $class, $hasChild);\n\n    /**\n     * Dumps while leaving an hash.\n     *\n     * @param Cursor     $cursor   The Cursor position in the dump\n     * @param int        $type     A Cursor::HASH_* const for the type of hash\n     * @param string|int $class    The object class, resource type or array count\n     * @param bool       $hasChild When the dump of the hash has child item\n     * @param int        $cut      The number of items the hash has been cut by\n     */\n    public function leaveHash(Cursor $cursor, $type, $class, $hasChild, $cut);\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Cloner/Stub.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Cloner;\n\n/**\n * Represents the main properties of a PHP variable.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass Stub\n{\n    const TYPE_REF = 1;\n    const TYPE_STRING = 2;\n    const TYPE_ARRAY = 3;\n    const TYPE_OBJECT = 4;\n    const TYPE_RESOURCE = 5;\n\n    const STRING_BINARY = 1;\n    const STRING_UTF8 = 2;\n\n    const ARRAY_ASSOC = 1;\n    const ARRAY_INDEXED = 2;\n\n    public $type = self::TYPE_REF;\n    public $class = '';\n    public $value;\n    public $cut = 0;\n    public $handle = 0;\n    public $refCount = 0;\n    public $position = 0;\n    public $attr = [];\n\n    private static $defaultProperties = [];\n\n    /**\n     * @internal\n     */\n    public function __sleep()\n    {\n        $properties = [];\n\n        if (!isset(self::$defaultProperties[$c = static::class])) {\n            self::$defaultProperties[$c] = get_class_vars($c);\n\n            foreach ((new \\ReflectionClass($c))->getStaticProperties() as $k => $v) {\n                unset(self::$defaultProperties[$c][$k]);\n            }\n        }\n\n        foreach (self::$defaultProperties[$c] as $k => $v) {\n            if ($this->$k !== $v) {\n                $properties[] = $k;\n            }\n        }\n\n        return $properties;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Cloner/VarCloner.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Cloner;\n\n/**\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass VarCloner extends AbstractCloner\n{\n    private static $gid;\n    private static $hashMask = 0;\n    private static $hashOffset = 0;\n    private static $arrayCache = [];\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function doClone($var)\n    {\n        $len = 1;                       // Length of $queue\n        $pos = 0;                       // Number of cloned items past the minimum depth\n        $refsCounter = 0;               // Hard references counter\n        $queue = [[$var]];    // This breadth-first queue is the return value\n        $indexedArrays = [];       // Map of queue indexes that hold numerically indexed arrays\n        $hardRefs = [];            // Map of original zval hashes to stub objects\n        $objRefs = [];             // Map of original object handles to their stub object counterpart\n        $objects = [];             // Keep a ref to objects to ensure their handle cannot be reused while cloning\n        $resRefs = [];             // Map of original resource handles to their stub object counterpart\n        $values = [];              // Map of stub objects' hashes to original values\n        $maxItems = $this->maxItems;\n        $maxString = $this->maxString;\n        $minDepth = $this->minDepth;\n        $currentDepth = 0;              // Current tree depth\n        $currentDepthFinalIndex = 0;    // Final $queue index for current tree depth\n        $minimumDepthReached = 0 === $minDepth; // Becomes true when minimum tree depth has been reached\n        $cookie = (object) [];          // Unique object used to detect hard references\n        $a = null;                      // Array cast for nested structures\n        $stub = null;                   // Stub capturing the main properties of an original item value\n                                        // or null if the original value is used directly\n\n        if (!self::$hashMask) {\n            self::initHashMask();\n            self::$gid = md5(dechex(self::$hashMask)); // Unique string used to detect the special $GLOBALS variable\n        }\n        $gid = self::$gid;\n        $hashMask = self::$hashMask;\n        $hashOffset = self::$hashOffset;\n        $arrayStub = new Stub();\n        $arrayStub->type = Stub::TYPE_ARRAY;\n        $fromObjCast = false;\n\n        for ($i = 0; $i < $len; ++$i) {\n            // Detect when we move on to the next tree depth\n            if ($i > $currentDepthFinalIndex) {\n                ++$currentDepth;\n                $currentDepthFinalIndex = $len - 1;\n                if ($currentDepth >= $minDepth) {\n                    $minimumDepthReached = true;\n                }\n            }\n\n            $refs = $vals = $queue[$i];\n            if (\\PHP_VERSION_ID < 70200 && empty($indexedArrays[$i])) {\n                // see https://wiki.php.net/rfc/convert_numeric_keys_in_object_array_casts\n                foreach ($vals as $k => $v) {\n                    if (\\is_int($k)) {\n                        continue;\n                    }\n                    foreach ([$k => true] as $gk => $gv) {\n                    }\n                    if ($gk !== $k) {\n                        $fromObjCast = true;\n                        $refs = $vals = array_values($queue[$i]);\n                        break;\n                    }\n                }\n            }\n            foreach ($vals as $k => $v) {\n                // $v is the original value or a stub object in case of hard references\n\n                if (\\PHP_VERSION_ID >= 70400) {\n                    $zvalIsRef = null !== \\ReflectionReference::fromArrayElement($vals, $k);\n                } else {\n                    $refs[$k] = $cookie;\n                    $zvalIsRef = $vals[$k] === $cookie;\n                }\n\n                if ($zvalIsRef) {\n                    $vals[$k] = &$stub;         // Break hard references to make $queue completely\n                    unset($stub);               // independent from the original structure\n                    if ($v instanceof Stub && isset($hardRefs[spl_object_hash($v)])) {\n                        $vals[$k] = $refs[$k] = $v;\n                        if ($v->value instanceof Stub && (Stub::TYPE_OBJECT === $v->value->type || Stub::TYPE_RESOURCE === $v->value->type)) {\n                            ++$v->value->refCount;\n                        }\n                        ++$v->refCount;\n                        continue;\n                    }\n                    $refs[$k] = $vals[$k] = new Stub();\n                    $refs[$k]->value = $v;\n                    $h = spl_object_hash($refs[$k]);\n                    $hardRefs[$h] = &$refs[$k];\n                    $values[$h] = $v;\n                    $vals[$k]->handle = ++$refsCounter;\n                }\n                // Create $stub when the original value $v can not be used directly\n                // If $v is a nested structure, put that structure in array $a\n                switch (true) {\n                    case null === $v:\n                    case \\is_bool($v):\n                    case \\is_int($v):\n                    case \\is_float($v):\n                        continue 2;\n                    case \\is_string($v):\n                        if ('' === $v) {\n                            continue 2;\n                        }\n                        if (!preg_match('//u', $v)) {\n                            $stub = new Stub();\n                            $stub->type = Stub::TYPE_STRING;\n                            $stub->class = Stub::STRING_BINARY;\n                            if (0 <= $maxString && 0 < $cut = \\strlen($v) - $maxString) {\n                                $stub->cut = $cut;\n                                $stub->value = substr($v, 0, -$cut);\n                            } else {\n                                $stub->value = $v;\n                            }\n                        } elseif (0 <= $maxString && isset($v[1 + ($maxString >> 2)]) && 0 < $cut = mb_strlen($v, 'UTF-8') - $maxString) {\n                            $stub = new Stub();\n                            $stub->type = Stub::TYPE_STRING;\n                            $stub->class = Stub::STRING_UTF8;\n                            $stub->cut = $cut;\n                            $stub->value = mb_substr($v, 0, $maxString, 'UTF-8');\n                        } else {\n                            continue 2;\n                        }\n                        $a = null;\n                        break;\n\n                    case \\is_array($v):\n                        if (!$v) {\n                            continue 2;\n                        }\n                        $stub = $arrayStub;\n                        $stub->class = Stub::ARRAY_INDEXED;\n\n                        $j = -1;\n                        foreach ($v as $gk => $gv) {\n                            if ($gk !== ++$j) {\n                                $stub->class = Stub::ARRAY_ASSOC;\n                                break;\n                            }\n                        }\n                        $a = $v;\n\n                        if (Stub::ARRAY_ASSOC === $stub->class) {\n                            // Copies of $GLOBALS have very strange behavior,\n                            // let's detect them with some black magic\n                            $a[$gid] = true;\n\n                            // Happens with copies of $GLOBALS\n                            if (isset($v[$gid])) {\n                                unset($v[$gid]);\n                                $a = [];\n                                foreach ($v as $gk => &$gv) {\n                                    $a[$gk] = &$gv;\n                                }\n                                unset($gv);\n                            } else {\n                                $a = $v;\n                            }\n                        } elseif (\\PHP_VERSION_ID < 70200) {\n                            $indexedArrays[$len] = true;\n                        }\n                        break;\n\n                    case \\is_object($v):\n                    case $v instanceof \\__PHP_Incomplete_Class:\n                        if (empty($objRefs[$h = $hashMask ^ hexdec(substr(spl_object_hash($v), $hashOffset, \\PHP_INT_SIZE))])) {\n                            $stub = new Stub();\n                            $stub->type = Stub::TYPE_OBJECT;\n                            $stub->class = \\get_class($v);\n                            $stub->value = $v;\n                            $stub->handle = $h;\n                            $a = $this->castObject($stub, 0 < $i);\n                            if ($v !== $stub->value) {\n                                if (Stub::TYPE_OBJECT !== $stub->type || null === $stub->value) {\n                                    break;\n                                }\n                                $h = $hashMask ^ hexdec(substr(spl_object_hash($stub->value), $hashOffset, \\PHP_INT_SIZE));\n                                $stub->handle = $h;\n                            }\n                            $stub->value = null;\n                            if (0 <= $maxItems && $maxItems <= $pos && $minimumDepthReached) {\n                                $stub->cut = \\count($a);\n                                $a = null;\n                            }\n                        }\n                        if (empty($objRefs[$h])) {\n                            $objRefs[$h] = $stub;\n                            $objects[] = $v;\n                        } else {\n                            $stub = $objRefs[$h];\n                            ++$stub->refCount;\n                            $a = null;\n                        }\n                        break;\n\n                    default: // resource\n                        if (empty($resRefs[$h = (int) $v])) {\n                            $stub = new Stub();\n                            $stub->type = Stub::TYPE_RESOURCE;\n                            if ('Unknown' === $stub->class = @get_resource_type($v)) {\n                                $stub->class = 'Closed';\n                            }\n                            $stub->value = $v;\n                            $stub->handle = $h;\n                            $a = $this->castResource($stub, 0 < $i);\n                            $stub->value = null;\n                            if (0 <= $maxItems && $maxItems <= $pos && $minimumDepthReached) {\n                                $stub->cut = \\count($a);\n                                $a = null;\n                            }\n                        }\n                        if (empty($resRefs[$h])) {\n                            $resRefs[$h] = $stub;\n                        } else {\n                            $stub = $resRefs[$h];\n                            ++$stub->refCount;\n                            $a = null;\n                        }\n                        break;\n                }\n\n                if ($a) {\n                    if (!$minimumDepthReached || 0 > $maxItems) {\n                        $queue[$len] = $a;\n                        $stub->position = $len++;\n                    } elseif ($pos < $maxItems) {\n                        if ($maxItems < $pos += \\count($a)) {\n                            $a = \\array_slice($a, 0, $maxItems - $pos, true);\n                            if ($stub->cut >= 0) {\n                                $stub->cut += $pos - $maxItems;\n                            }\n                        }\n                        $queue[$len] = $a;\n                        $stub->position = $len++;\n                    } elseif ($stub->cut >= 0) {\n                        $stub->cut += \\count($a);\n                        $stub->position = 0;\n                    }\n                }\n\n                if ($arrayStub === $stub) {\n                    if ($arrayStub->cut) {\n                        $stub = [$arrayStub->cut, $arrayStub->class => $arrayStub->position];\n                        $arrayStub->cut = 0;\n                    } elseif (isset(self::$arrayCache[$arrayStub->class][$arrayStub->position])) {\n                        $stub = self::$arrayCache[$arrayStub->class][$arrayStub->position];\n                    } else {\n                        self::$arrayCache[$arrayStub->class][$arrayStub->position] = $stub = [$arrayStub->class => $arrayStub->position];\n                    }\n                }\n\n                if ($zvalIsRef) {\n                    $refs[$k]->value = $stub;\n                } else {\n                    $vals[$k] = $stub;\n                }\n            }\n\n            if ($fromObjCast) {\n                $fromObjCast = false;\n                $refs = $vals;\n                $vals = [];\n                $j = -1;\n                foreach ($queue[$i] as $k => $v) {\n                    foreach ([$k => true] as $gk => $gv) {\n                    }\n                    if ($gk !== $k) {\n                        $vals = (object) $vals;\n                        $vals->{$k} = $refs[++$j];\n                        $vals = (array) $vals;\n                    } else {\n                        $vals[$k] = $refs[++$j];\n                    }\n                }\n            }\n\n            $queue[$i] = $vals;\n        }\n\n        foreach ($values as $h => $v) {\n            $hardRefs[$h] = $v;\n        }\n\n        return $queue;\n    }\n\n    private static function initHashMask()\n    {\n        $obj = (object) [];\n        self::$hashOffset = 16 - \\PHP_INT_SIZE;\n        self::$hashMask = -1;\n\n        if (\\defined('HHVM_VERSION')) {\n            self::$hashOffset += 16;\n        } else {\n            // check if we are nested in an output buffering handler to prevent a fatal error with ob_start() below\n            $obFuncs = ['ob_clean', 'ob_end_clean', 'ob_flush', 'ob_end_flush', 'ob_get_contents', 'ob_get_flush'];\n            foreach (debug_backtrace(\\DEBUG_BACKTRACE_IGNORE_ARGS) as $frame) {\n                if (isset($frame['function'][0]) && !isset($frame['class']) && 'o' === $frame['function'][0] && \\in_array($frame['function'], $obFuncs)) {\n                    $frame['line'] = 0;\n                    break;\n                }\n            }\n            if (!empty($frame['line'])) {\n                ob_start();\n                debug_zval_dump($obj);\n                self::$hashMask = (int) substr(ob_get_clean(), 17);\n            }\n        }\n\n        self::$hashMask ^= hexdec(substr(spl_object_hash($obj), self::$hashOffset, \\PHP_INT_SIZE));\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/composer.json',
    '{\n    "name": "symfony/var-dumper",\n    "type": "library",\n    "description": "Symfony mechanism for exploring and dumping PHP variables",\n    "keywords": ["dump", "debug"],\n    "homepage": "https://symfony.com",\n    "license": "MIT",\n    "authors": [\n        {\n            "name": "Nicolas Grekas",\n            "email": "p@tchwork.com"\n        },\n        {\n            "name": "Symfony Community",\n            "homepage": "https://symfony.com/contributors"\n        }\n    ],\n    "require": {\n        "php": "^5.5.9|>=7.0.8",\n        "symfony/polyfill-mbstring": "~1.0"\n    },\n    "require-dev": {\n        "ext-iconv": "*",\n        "twig/twig": "~1.34|~2.4"\n    },\n    "conflict": {\n        "phpunit/phpunit": "<4.8.35|<5.4.3,>=5.0"\n    },\n    "suggest": {\n        "ext-iconv": "To convert non-UTF-8 strings to UTF-8 (or symfony/polyfill-iconv in case ext-iconv cannot be used).",\n        "ext-intl": "To show region name in time zone dump",\n        "ext-symfony_debug": ""\n    },\n    "autoload": {\n        "files": [ "Resources/functions/dump.php" ],\n        "psr-4": { "Symfony\\\\Component\\\\VarDumper\\\\": "" },\n        "exclude-from-classmap": [\n            "/Tests/"\n        ]\n    },\n    "minimum-stability": "dev"\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Dumper/AbstractDumper.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Dumper;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Data;\nuse Symfony\\Component\\VarDumper\\Cloner\\DumperInterface;\n\n/**\n * Abstract mechanism for dumping a Data object.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nabstract class AbstractDumper implements DataDumperInterface, DumperInterface\n{\n    const DUMP_LIGHT_ARRAY = 1;\n    const DUMP_STRING_LENGTH = 2;\n    const DUMP_COMMA_SEPARATOR = 4;\n    const DUMP_TRAILING_COMMA = 8;\n\n    public static $defaultOutput = 'php://output';\n\n    protected $line = '';\n    protected $lineDumper;\n    protected $outputStream;\n    protected $decimalPoint; // This is locale dependent\n    protected $indentPad = '  ';\n    protected $flags;\n\n    private $charset = '';\n\n    /**\n     * @param callable|resource|string|null $output  A line dumper callable, an opened stream or an output path, defaults to static::$defaultOutput\n     * @param string|null                   $charset The default character encoding to use for non-UTF8 strings\n     * @param int                           $flags   A bit field of static::DUMP_* constants to fine tune dumps representation\n     */\n    public function __construct($output = null, $charset = null, $flags = 0)\n    {\n        $this->flags = (int) $flags;\n        $this->setCharset($charset ?: ini_get('php.output_encoding') ?: ini_get('default_charset') ?: 'UTF-8');\n        $this->decimalPoint = localeconv();\n        $this->decimalPoint = $this->decimalPoint['decimal_point'];\n        $this->setOutput($output ?: static::$defaultOutput);\n        if (!$output && \\is_string(static::$defaultOutput)) {\n            static::$defaultOutput = $this->outputStream;\n        }\n    }\n\n    /**\n     * Sets the output destination of the dumps.\n     *\n     * @param callable|resource|string $output A line dumper callable, an opened stream or an output path\n     *\n     * @return callable|resource|string The previous output destination\n     */\n    public function setOutput($output)\n    {\n        $prev = null !== $this->outputStream ? $this->outputStream : $this->lineDumper;\n\n        if (\\is_callable($output)) {\n            $this->outputStream = null;\n            $this->lineDumper = $output;\n        } else {\n            if (\\is_string($output)) {\n                $output = fopen($output, 'wb');\n            }\n            $this->outputStream = $output;\n            $this->lineDumper = [$this, 'echoLine'];\n        }\n\n        return $prev;\n    }\n\n    /**\n     * Sets the default character encoding to use for non-UTF8 strings.\n     *\n     * @param string $charset The default character encoding to use for non-UTF8 strings\n     *\n     * @return string The previous charset\n     */\n    public function setCharset($charset)\n    {\n        $prev = $this->charset;\n\n        $charset = strtoupper($charset);\n        $charset = null === $charset || 'UTF-8' === $charset || 'UTF8' === $charset ? 'CP1252' : $charset;\n\n        $this->charset = $charset;\n\n        return $prev;\n    }\n\n    /**\n     * Sets the indentation pad string.\n     *\n     * @param string $pad A string that will be prepended to dumped lines, repeated by nesting level\n     *\n     * @return string The previous indent pad\n     */\n    public function setIndentPad($pad)\n    {\n        $prev = $this->indentPad;\n        $this->indentPad = $pad;\n\n        return $prev;\n    }\n\n    /**\n     * Dumps a Data object.\n     *\n     * @param Data                               $data   A Data object\n     * @param callable|resource|string|true|null $output A line dumper callable, an opened stream, an output path or true to return the dump\n     *\n     * @return string|null The dump as string when $output is true\n     */\n    public function dump(Data $data, $output = null)\n    {\n        $this->decimalPoint = localeconv();\n        $this->decimalPoint = $this->decimalPoint['decimal_point'];\n\n        if ($locale = $this->flags & (self::DUMP_COMMA_SEPARATOR | self::DUMP_TRAILING_COMMA) ? setlocale(\\LC_NUMERIC, 0) : null) {\n            setlocale(\\LC_NUMERIC, 'C');\n        }\n\n        if ($returnDump = true === $output) {\n            $output = fopen('php://memory', 'r+b');\n        }\n        if ($output) {\n            $prevOutput = $this->setOutput($output);\n        }\n        try {\n            $data->dump($this);\n            $this->dumpLine(-1);\n\n            if ($returnDump) {\n                $result = stream_get_contents($output, -1, 0);\n                fclose($output);\n\n                return $result;\n            }\n        } finally {\n            if ($output) {\n                $this->setOutput($prevOutput);\n            }\n            if ($locale) {\n                setlocale(\\LC_NUMERIC, $locale);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Dumps the current line.\n     *\n     * @param int $depth The recursive depth in the dumped structure for the line being dumped,\n     *                   or -1 to signal the end-of-dump to the line dumper callable\n     */\n    protected function dumpLine($depth)\n    {\n        \\call_user_func($this->lineDumper, $this->line, $depth, $this->indentPad);\n        $this->line = '';\n    }\n\n    /**\n     * Generic line dumper callback.\n     *\n     * @param string $line      The line to write\n     * @param int    $depth     The recursive depth in the dumped structure\n     * @param string $indentPad The line indent pad\n     */\n    protected function echoLine($line, $depth, $indentPad)\n    {\n        if (-1 !== $depth) {\n            fwrite($this->outputStream, str_repeat($indentPad, $depth).$line.\"\\n\");\n        }\n    }\n\n    /**\n     * Converts a non-UTF-8 string to UTF-8.\n     *\n     * @param string|null $s The non-UTF-8 string to convert\n     *\n     * @return string|null The string converted to UTF-8\n     */\n    protected function utf8Encode($s)\n    {\n        if (null === $s || preg_match('//u', $s)) {\n            return $s;\n        }\n\n        if (!\\function_exists('iconv')) {\n            throw new \\RuntimeException('Unable to convert a non-UTF-8 string to UTF-8: required function iconv() does not exist. You should install ext-iconv or symfony/polyfill-iconv.');\n        }\n\n        if (false !== $c = @iconv($this->charset, 'UTF-8', $s)) {\n            return $c;\n        }\n        if ('CP1252' !== $this->charset && false !== $c = @iconv('CP1252', 'UTF-8', $s)) {\n            return $c;\n        }\n\n        return iconv('CP850', 'UTF-8', $s);\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Dumper/CliDumper.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Dumper;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Cursor;\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\n\n/**\n * CliDumper dumps variables for command line output.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass CliDumper extends AbstractDumper\n{\n    public static $defaultColors;\n    public static $defaultOutput = 'php://stdout';\n\n    protected $colors;\n    protected $maxStringWidth = 0;\n    protected $styles = [\n        // See http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n        'default' => '0;38;5;208',\n        'num' => '1;38;5;38',\n        'const' => '1;38;5;208',\n        'str' => '1;38;5;113',\n        'note' => '38;5;38',\n        'ref' => '38;5;247',\n        'public' => '',\n        'protected' => '',\n        'private' => '',\n        'meta' => '38;5;170',\n        'key' => '38;5;113',\n        'index' => '38;5;38',\n    ];\n\n    protected static $controlCharsRx = '/[\\x00-\\x1F\\x7F]+/';\n    protected static $controlCharsMap = [\n        \"\\t\" => '\\t',\n        \"\\n\" => '\\n',\n        \"\\v\" => '\\v',\n        \"\\f\" => '\\f',\n        \"\\r\" => '\\r',\n        \"\\033\" => '\\e',\n    ];\n\n    protected $collapseNextHash = false;\n    protected $expandNextHash = false;\n\n    /**\n     * {@inheritdoc}\n     */\n    public function __construct($output = null, $charset = null, $flags = 0)\n    {\n        parent::__construct($output, $charset, $flags);\n\n        if ('\\\\' === \\DIRECTORY_SEPARATOR && !$this->isWindowsTrueColor()) {\n            // Use only the base 16 xterm colors when using ANSICON or standard Windows 10 CLI\n            $this->setStyles([\n                'default' => '31',\n                'num' => '1;34',\n                'const' => '1;31',\n                'str' => '1;32',\n                'note' => '34',\n                'ref' => '1;30',\n                'meta' => '35',\n                'key' => '32',\n                'index' => '34',\n            ]);\n        }\n    }\n\n    /**\n     * Enables/disables colored output.\n     *\n     * @param bool $colors\n     */\n    public function setColors($colors)\n    {\n        $this->colors = (bool) $colors;\n    }\n\n    /**\n     * Sets the maximum number of characters per line for dumped strings.\n     *\n     * @param int $maxStringWidth\n     */\n    public function setMaxStringWidth($maxStringWidth)\n    {\n        $this->maxStringWidth = (int) $maxStringWidth;\n    }\n\n    /**\n     * Configures styles.\n     *\n     * @param array $styles A map of style names to style definitions\n     */\n    public function setStyles(array $styles)\n    {\n        $this->styles = $styles + $this->styles;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function dumpScalar(Cursor $cursor, $type, $value)\n    {\n        $this->dumpKey($cursor);\n\n        $style = 'const';\n        $attr = $cursor->attr;\n\n        switch ($type) {\n            case 'default':\n                $style = 'default';\n                break;\n\n            case 'integer':\n                $style = 'num';\n                break;\n\n            case 'double':\n                $style = 'num';\n\n                switch (true) {\n                    case \\INF === $value:  $value = 'INF'; break;\n                    case -\\INF === $value: $value = '-INF'; break;\n                    case is_nan($value):  $value = 'NAN'; break;\n                    default:\n                        $value = (string) $value;\n                        if (false === strpos($value, $this->decimalPoint)) {\n                            $value .= $this->decimalPoint.'0';\n                        }\n                        break;\n                }\n                break;\n\n            case 'NULL':\n                $value = 'null';\n                break;\n\n            case 'boolean':\n                $value = $value ? 'true' : 'false';\n                break;\n\n            default:\n                $attr += ['value' => $this->utf8Encode($value)];\n                $value = $this->utf8Encode($type);\n                break;\n        }\n\n        $this->line .= $this->style($style, $value, $attr);\n\n        $this->endValue($cursor);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function dumpString(Cursor $cursor, $str, $bin, $cut)\n    {\n        $this->dumpKey($cursor);\n        $attr = $cursor->attr;\n\n        if ($bin) {\n            $str = $this->utf8Encode($str);\n        }\n        if ('' === $str) {\n            $this->line .= '\"\"';\n            $this->endValue($cursor);\n        } else {\n            $attr += [\n                'length' => 0 <= $cut ? mb_strlen($str, 'UTF-8') + $cut : 0,\n                'binary' => $bin,\n            ];\n            $str = explode(\"\\n\", $str);\n            if (isset($str[1]) && !isset($str[2]) && !isset($str[1][0])) {\n                unset($str[1]);\n                $str[0] .= \"\\n\";\n            }\n            $m = \\count($str) - 1;\n            $i = $lineCut = 0;\n\n            if (self::DUMP_STRING_LENGTH & $this->flags) {\n                $this->line .= '('.$attr['length'].') ';\n            }\n            if ($bin) {\n                $this->line .= 'b';\n            }\n\n            if ($m) {\n                $this->line .= '\"\"\"';\n                $this->dumpLine($cursor->depth);\n            } else {\n                $this->line .= '\"';\n            }\n\n            foreach ($str as $str) {\n                if ($i < $m) {\n                    $str .= \"\\n\";\n                }\n                if (0 < $this->maxStringWidth && $this->maxStringWidth < $len = mb_strlen($str, 'UTF-8')) {\n                    $str = mb_substr($str, 0, $this->maxStringWidth, 'UTF-8');\n                    $lineCut = $len - $this->maxStringWidth;\n                }\n                if ($m && 0 < $cursor->depth) {\n                    $this->line .= $this->indentPad;\n                }\n                if ('' !== $str) {\n                    $this->line .= $this->style('str', $str, $attr);\n                }\n                if ($i++ == $m) {\n                    if ($m) {\n                        if ('' !== $str) {\n                            $this->dumpLine($cursor->depth);\n                            if (0 < $cursor->depth) {\n                                $this->line .= $this->indentPad;\n                            }\n                        }\n                        $this->line .= '\"\"\"';\n                    } else {\n                        $this->line .= '\"';\n                    }\n                    if ($cut < 0) {\n                        $this->line .= '…';\n                        $lineCut = 0;\n                    } elseif ($cut) {\n                        $lineCut += $cut;\n                    }\n                }\n                if ($lineCut) {\n                    $this->line .= '…'.$lineCut;\n                    $lineCut = 0;\n                }\n\n                if ($i > $m) {\n                    $this->endValue($cursor);\n                } else {\n                    $this->dumpLine($cursor->depth);\n                }\n            }\n        }\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function enterHash(Cursor $cursor, $type, $class, $hasChild)\n    {\n        if (null === $this->colors) {\n            $this->colors = $this->supportsColors();\n        }\n\n        $this->dumpKey($cursor);\n\n        if ($this->collapseNextHash) {\n            $cursor->skipChildren = true;\n            $this->collapseNextHash = $hasChild = false;\n        }\n\n        $class = $this->utf8Encode($class);\n        if (Cursor::HASH_OBJECT === $type) {\n            $prefix = $class && 'stdClass' !== $class ? $this->style('note', $class).' {' : '{';\n        } elseif (Cursor::HASH_RESOURCE === $type) {\n            $prefix = $this->style('note', $class.' resource').($hasChild ? ' {' : ' ');\n        } else {\n            $prefix = $class && !(self::DUMP_LIGHT_ARRAY & $this->flags) ? $this->style('note', 'array:'.$class).' [' : '[';\n        }\n\n        if ($cursor->softRefCount || 0 < $cursor->softRefHandle) {\n            $prefix .= $this->style('ref', (Cursor::HASH_RESOURCE === $type ? '@' : '#').(0 < $cursor->softRefHandle ? $cursor->softRefHandle : $cursor->softRefTo), ['count' => $cursor->softRefCount]);\n        } elseif ($cursor->hardRefTo && !$cursor->refIndex && $class) {\n            $prefix .= $this->style('ref', '&'.$cursor->hardRefTo, ['count' => $cursor->hardRefCount]);\n        } elseif (!$hasChild && Cursor::HASH_RESOURCE === $type) {\n            $prefix = substr($prefix, 0, -1);\n        }\n\n        $this->line .= $prefix;\n\n        if ($hasChild) {\n            $this->dumpLine($cursor->depth);\n        }\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function leaveHash(Cursor $cursor, $type, $class, $hasChild, $cut)\n    {\n        $this->dumpEllipsis($cursor, $hasChild, $cut);\n        $this->line .= Cursor::HASH_OBJECT === $type ? '}' : (Cursor::HASH_RESOURCE !== $type ? ']' : ($hasChild ? '}' : ''));\n        $this->endValue($cursor);\n    }\n\n    /**\n     * Dumps an ellipsis for cut children.\n     *\n     * @param Cursor $cursor   The Cursor position in the dump\n     * @param bool   $hasChild When the dump of the hash has child item\n     * @param int    $cut      The number of items the hash has been cut by\n     */\n    protected function dumpEllipsis(Cursor $cursor, $hasChild, $cut)\n    {\n        if ($cut) {\n            $this->line .= ' …';\n            if (0 < $cut) {\n                $this->line .= $cut;\n            }\n            if ($hasChild) {\n                $this->dumpLine($cursor->depth + 1);\n            }\n        }\n    }\n\n    /**\n     * Dumps a key in a hash structure.\n     *\n     * @param Cursor $cursor The Cursor position in the dump\n     */\n    protected function dumpKey(Cursor $cursor)\n    {\n        if (null !== $key = $cursor->hashKey) {\n            if ($cursor->hashKeyIsBinary) {\n                $key = $this->utf8Encode($key);\n            }\n            $attr = ['binary' => $cursor->hashKeyIsBinary];\n            $bin = $cursor->hashKeyIsBinary ? 'b' : '';\n            $style = 'key';\n            switch ($cursor->hashType) {\n                default:\n                case Cursor::HASH_INDEXED:\n                    if (self::DUMP_LIGHT_ARRAY & $this->flags) {\n                        break;\n                    }\n                    $style = 'index';\n                    // no break\n                case Cursor::HASH_ASSOC:\n                    if (\\is_int($key)) {\n                        $this->line .= $this->style($style, $key).' => ';\n                    } else {\n                        $this->line .= $bin.'\"'.$this->style($style, $key).'\" => ';\n                    }\n                    break;\n\n                case Cursor::HASH_RESOURCE:\n                    $key = \"\\0~\\0\".$key;\n                    // no break\n                case Cursor::HASH_OBJECT:\n                    if (!isset($key[0]) || \"\\0\" !== $key[0]) {\n                        $this->line .= '+'.$bin.$this->style('public', $key).': ';\n                    } elseif (0 < strpos($key, \"\\0\", 1)) {\n                        $key = explode(\"\\0\", substr($key, 1), 2);\n\n                        switch ($key[0][0]) {\n                            case '+': // User inserted keys\n                                $attr['dynamic'] = true;\n                                $this->line .= '+'.$bin.'\"'.$this->style('public', $key[1], $attr).'\": ';\n                                break 2;\n                            case '~':\n                                $style = 'meta';\n                                if (isset($key[0][1])) {\n                                    parse_str(substr($key[0], 1), $attr);\n                                    $attr += ['binary' => $cursor->hashKeyIsBinary];\n                                }\n                                break;\n                            case '*':\n                                $style = 'protected';\n                                $bin = '#'.$bin;\n                                break;\n                            default:\n                                $attr['class'] = $key[0];\n                                $style = 'private';\n                                $bin = '-'.$bin;\n                                break;\n                        }\n\n                        if (isset($attr['collapse'])) {\n                            if ($attr['collapse']) {\n                                $this->collapseNextHash = true;\n                            } else {\n                                $this->expandNextHash = true;\n                            }\n                        }\n\n                        $this->line .= $bin.$this->style($style, $key[1], $attr).(isset($attr['separator']) ? $attr['separator'] : ': ');\n                    } else {\n                        // This case should not happen\n                        $this->line .= '-'.$bin.'\"'.$this->style('private', $key, ['class' => '']).'\": ';\n                    }\n                    break;\n            }\n\n            if ($cursor->hardRefTo) {\n                $this->line .= $this->style('ref', '&'.($cursor->hardRefCount ? $cursor->hardRefTo : ''), ['count' => $cursor->hardRefCount]).' ';\n            }\n        }\n    }\n\n    /**\n     * Decorates a value with some style.\n     *\n     * @param string $style The type of style being applied\n     * @param string $value The value being styled\n     * @param array  $attr  Optional context information\n     *\n     * @return string The value with style decoration\n     */\n    protected function style($style, $value, $attr = [])\n    {\n        if (null === $this->colors) {\n            $this->colors = $this->supportsColors();\n        }\n\n        if (isset($attr['ellipsis'], $attr['ellipsis-type'])) {\n            $prefix = substr($value, 0, -$attr['ellipsis']);\n            if ('cli' === \\PHP_SAPI && 'path' === $attr['ellipsis-type'] && isset($_SERVER[$pwd = '\\\\' === \\DIRECTORY_SEPARATOR ? 'CD' : 'PWD']) && 0 === strpos($prefix, $_SERVER[$pwd])) {\n                $prefix = '.'.substr($prefix, \\strlen($_SERVER[$pwd]));\n            }\n            if (!empty($attr['ellipsis-tail'])) {\n                $prefix .= substr($value, -$attr['ellipsis'], $attr['ellipsis-tail']);\n                $value = substr($value, -$attr['ellipsis'] + $attr['ellipsis-tail']);\n            } else {\n                $value = substr($value, -$attr['ellipsis']);\n            }\n\n            return $this->style('default', $prefix).$this->style($style, $value);\n        }\n\n        $style = $this->styles[$style];\n\n        $map = static::$controlCharsMap;\n        $startCchr = $this->colors ? \"\\033[m\\033[{$this->styles['default']}m\" : '';\n        $endCchr = $this->colors ? \"\\033[m\\033[{$style}m\" : '';\n        $value = preg_replace_callback(static::$controlCharsRx, function ($c) use ($map, $startCchr, $endCchr) {\n            $s = $startCchr;\n            $c = $c[$i = 0];\n            do {\n                $s .= isset($map[$c[$i]]) ? $map[$c[$i]] : sprintf('\\x%02X', \\ord($c[$i]));\n            } while (isset($c[++$i]));\n\n            return $s.$endCchr;\n        }, $value, -1, $cchrCount);\n\n        if ($this->colors) {\n            if ($cchrCount && \"\\033\" === $value[0]) {\n                $value = substr($value, \\strlen($startCchr));\n            } else {\n                $value = \"\\033[{$style}m\".$value;\n            }\n            if ($cchrCount && $endCchr === substr($value, -\\strlen($endCchr))) {\n                $value = substr($value, 0, -\\strlen($endCchr));\n            } else {\n                $value .= \"\\033[{$this->styles['default']}m\";\n            }\n        }\n\n        return $value;\n    }\n\n    /**\n     * @return bool Tells if the current output stream supports ANSI colors or not\n     */\n    protected function supportsColors()\n    {\n        if ($this->outputStream !== static::$defaultOutput) {\n            return $this->hasColorSupport($this->outputStream);\n        }\n        if (null !== static::$defaultColors) {\n            return static::$defaultColors;\n        }\n        if (isset($_SERVER['argv'][1])) {\n            $colors = $_SERVER['argv'];\n            $i = \\count($colors);\n            while (--$i > 0) {\n                if (isset($colors[$i][5])) {\n                    switch ($colors[$i]) {\n                        case '--ansi':\n                        case '--color':\n                        case '--color=yes':\n                        case '--color=force':\n                        case '--color=always':\n                            return static::$defaultColors = true;\n\n                        case '--no-ansi':\n                        case '--color=no':\n                        case '--color=none':\n                        case '--color=never':\n                            return static::$defaultColors = false;\n                    }\n                }\n            }\n        }\n\n        $h = stream_get_meta_data($this->outputStream) + ['wrapper_type' => null];\n        $h = 'Output' === $h['stream_type'] && 'PHP' === $h['wrapper_type'] ? fopen('php://stdout', 'wb') : $this->outputStream;\n\n        return static::$defaultColors = $this->hasColorSupport($h);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function dumpLine($depth, $endOfValue = false)\n    {\n        if ($this->colors) {\n            $this->line = sprintf(\"\\033[%sm%s\\033[m\", $this->styles['default'], $this->line);\n        }\n        parent::dumpLine($depth);\n    }\n\n    protected function endValue(Cursor $cursor)\n    {\n        if (Stub::ARRAY_INDEXED === $cursor->hashType || Stub::ARRAY_ASSOC === $cursor->hashType) {\n            if (self::DUMP_TRAILING_COMMA & $this->flags && 0 < $cursor->depth) {\n                $this->line .= ',';\n            } elseif (self::DUMP_COMMA_SEPARATOR & $this->flags && 1 < $cursor->hashLength - $cursor->hashIndex) {\n                $this->line .= ',';\n            }\n        }\n\n        $this->dumpLine($cursor->depth, true);\n    }\n\n    /**\n     * Returns true if the stream supports colorization.\n     *\n     * Reference: Composer\\XdebugHandler\\Process::supportsColor\n     * https://github.com/composer/xdebug-handler\n     *\n     * @param mixed $stream A CLI output stream\n     *\n     * @return bool\n     */\n    private function hasColorSupport($stream)\n    {\n        if (!\\is_resource($stream) || 'stream' !== get_resource_type($stream)) {\n            return false;\n        }\n\n        if ('Hyper' === getenv('TERM_PROGRAM')) {\n            return true;\n        }\n\n        if (\\DIRECTORY_SEPARATOR === '\\\\') {\n            return (\\function_exists('sapi_windows_vt100_support')\n                && @sapi_windows_vt100_support($stream))\n                || false !== getenv('ANSICON')\n                || 'ON' === getenv('ConEmuANSI')\n                || 'xterm' === getenv('TERM');\n        }\n\n        if (\\function_exists('stream_isatty')) {\n            return @stream_isatty($stream);\n        }\n\n        if (\\function_exists('posix_isatty')) {\n            return @posix_isatty($stream);\n        }\n\n        $stat = @fstat($stream);\n        // Check if formatted mode is S_IFCHR\n        return $stat ? 0020000 === ($stat['mode'] & 0170000) : false;\n    }\n\n    /**\n     * Returns true if the Windows terminal supports true color.\n     *\n     * Note that this does not check an output stream, but relies on environment\n     * variables from known implementations, or a PHP and Windows version that\n     * supports true color.\n     *\n     * @return bool\n     */\n    private function isWindowsTrueColor()\n    {\n        $result = 183 <= getenv('ANSICON_VER')\n            || 'ON' === getenv('ConEmuANSI')\n            || 'xterm' === getenv('TERM')\n            || 'Hyper' === getenv('TERM_PROGRAM');\n\n        if (!$result && \\PHP_VERSION_ID >= 70200) {\n            $version = sprintf(\n                '%s.%s.%s',\n                PHP_WINDOWS_VERSION_MAJOR,\n                PHP_WINDOWS_VERSION_MINOR,\n                PHP_WINDOWS_VERSION_BUILD\n            );\n            $result = $version >= '10.0.15063';\n        }\n\n        return $result;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Dumper/DataDumperInterface.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Dumper;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Data;\n\n/**\n * DataDumperInterface for dumping Data objects.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\ninterface DataDumperInterface\n{\n    public function dump(Data $data);\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Dumper/HtmlDumper.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Dumper;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\Cursor;\nuse Symfony\\Component\\VarDumper\\Cloner\\Data;\n\n/**\n * HtmlDumper dumps variables as HTML.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass HtmlDumper extends CliDumper\n{\n    public static $defaultOutput = 'php://output';\n\n    protected $dumpHeader;\n    protected $dumpPrefix = '<pre class=sf-dump id=%s data-indent-pad=\"%s\">';\n    protected $dumpSuffix = '</pre><script>Sfdump(%s)</script>';\n    protected $dumpId = 'sf-dump';\n    protected $colors = true;\n    protected $headerIsDumped = false;\n    protected $lastDepth = -1;\n    protected $styles = [\n        'default' => 'background-color:#18171B; color:#FF8400; line-height:1.2em; font:12px Menlo, Monaco, Consolas, monospace; word-wrap: break-word; white-space: pre-wrap; position:relative; z-index:99999; word-break: break-all',\n        'num' => 'font-weight:bold; color:#1299DA',\n        'const' => 'font-weight:bold',\n        'str' => 'font-weight:bold; color:#56DB3A',\n        'note' => 'color:#1299DA',\n        'ref' => 'color:#A0A0A0',\n        'public' => 'color:#FFFFFF',\n        'protected' => 'color:#FFFFFF',\n        'private' => 'color:#FFFFFF',\n        'meta' => 'color:#B729D9',\n        'key' => 'color:#56DB3A',\n        'index' => 'color:#1299DA',\n        'ellipsis' => 'color:#FF8400',\n    ];\n\n    private $displayOptions = [\n        'maxDepth' => 1,\n        'maxStringLength' => 160,\n        'fileLinkFormat' => null,\n    ];\n    private $extraDisplayOptions = [];\n\n    /**\n     * {@inheritdoc}\n     */\n    public function __construct($output = null, $charset = null, $flags = 0)\n    {\n        AbstractDumper::__construct($output, $charset, $flags);\n        $this->dumpId = 'sf-dump-'.mt_rand();\n        $this->displayOptions['fileLinkFormat'] = ini_get('xdebug.file_link_format') ?: get_cfg_var('xdebug.file_link_format');\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function setStyles(array $styles)\n    {\n        $this->headerIsDumped = false;\n        $this->styles = $styles + $this->styles;\n    }\n\n    /**\n     * Configures display options.\n     *\n     * @param array $displayOptions A map of display options to customize the behavior\n     */\n    public function setDisplayOptions(array $displayOptions)\n    {\n        $this->headerIsDumped = false;\n        $this->displayOptions = $displayOptions + $this->displayOptions;\n    }\n\n    /**\n     * Sets an HTML header that will be dumped once in the output stream.\n     *\n     * @param string $header An HTML string\n     */\n    public function setDumpHeader($header)\n    {\n        $this->dumpHeader = $header;\n    }\n\n    /**\n     * Sets an HTML prefix and suffix that will encapse every single dump.\n     *\n     * @param string $prefix The prepended HTML string\n     * @param string $suffix The appended HTML string\n     */\n    public function setDumpBoundaries($prefix, $suffix)\n    {\n        $this->dumpPrefix = $prefix;\n        $this->dumpSuffix = $suffix;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function dump(Data $data, $output = null, array $extraDisplayOptions = [])\n    {\n        $this->extraDisplayOptions = $extraDisplayOptions;\n        $result = parent::dump($data, $output);\n        $this->dumpId = 'sf-dump-'.mt_rand();\n\n        return $result;\n    }\n\n    /**\n     * Dumps the HTML header.\n     */\n    protected function getDumpHeader()\n    {\n        $this->headerIsDumped = null !== $this->outputStream ? $this->outputStream : $this->lineDumper;\n\n        if (null !== $this->dumpHeader) {\n            return $this->dumpHeader;\n        }\n\n        $line = str_replace('{$options}', json_encode($this->displayOptions, \\JSON_FORCE_OBJECT), <<<'EOHTML'\n<script>\nSfdump = window.Sfdump || (function (doc) {\n\nvar refStyle = doc.createElement('style'),\n    rxEsc = /([.*+?^${}()|\\[\\]\\/\\\\])/g,\n    idRx = /\\bsf-dump-\\d+-ref[012]\\w+\\b/,\n    keyHint = 0 <= navigator.platform.toUpperCase().indexOf('MAC') ? 'Cmd' : 'Ctrl',\n    addEventListener = function (e, n, cb) {\n        e.addEventListener(n, cb, false);\n    };\n\n(doc.documentElement.firstElementChild || doc.documentElement.children[0]).appendChild(refStyle);\n\nif (!doc.addEventListener) {\n    addEventListener = function (element, eventName, callback) {\n        element.attachEvent('on' + eventName, function (e) {\n            e.preventDefault = function () {e.returnValue = false;};\n            e.target = e.srcElement;\n            callback(e);\n        });\n    };\n}\n\nfunction toggle(a, recursive) {\n    var s = a.nextSibling || {}, oldClass = s.className, arrow, newClass;\n\n    if (/\\bsf-dump-compact\\b/.test(oldClass)) {\n        arrow = '▼';\n        newClass = 'sf-dump-expanded';\n    } else if (/\\bsf-dump-expanded\\b/.test(oldClass)) {\n        arrow = '▶';\n        newClass = 'sf-dump-compact';\n    } else {\n        return false;\n    }\n\n    if (doc.createEvent && s.dispatchEvent) {\n        var event = doc.createEvent('Event');\n        event.initEvent('sf-dump-expanded' === newClass ? 'sfbeforedumpexpand' : 'sfbeforedumpcollapse', true, false);\n\n        s.dispatchEvent(event);\n    }\n\n    a.lastChild.innerHTML = arrow;\n    s.className = s.className.replace(/\\bsf-dump-(compact|expanded)\\b/, newClass);\n\n    if (recursive) {\n        try {\n            a = s.querySelectorAll('.'+oldClass);\n            for (s = 0; s < a.length; ++s) {\n                if (-1 == a[s].className.indexOf(newClass)) {\n                    a[s].className = newClass;\n                    a[s].previousSibling.lastChild.innerHTML = arrow;\n                }\n            }\n        } catch (e) {\n        }\n    }\n\n    return true;\n};\n\nfunction collapse(a, recursive) {\n    var s = a.nextSibling || {}, oldClass = s.className;\n\n    if (/\\bsf-dump-expanded\\b/.test(oldClass)) {\n        toggle(a, recursive);\n\n        return true;\n    }\n\n    return false;\n};\n\nfunction expand(a, recursive) {\n    var s = a.nextSibling || {}, oldClass = s.className;\n\n    if (/\\bsf-dump-compact\\b/.test(oldClass)) {\n        toggle(a, recursive);\n\n        return true;\n    }\n\n    return false;\n};\n\nfunction collapseAll(root) {\n    var a = root.querySelector('a.sf-dump-toggle');\n    if (a) {\n        collapse(a, true);\n        expand(a);\n\n        return true;\n    }\n\n    return false;\n}\n\nfunction reveal(node) {\n    var previous, parents = [];\n\n    while ((node = node.parentNode || {}) && (previous = node.previousSibling) && 'A' === previous.tagName) {\n        parents.push(previous);\n    }\n\n    if (0 !== parents.length) {\n        parents.forEach(function (parent) {\n            expand(parent);\n        });\n\n        return true;\n    }\n\n    return false;\n}\n\nfunction highlight(root, activeNode, nodes) {\n    resetHighlightedNodes(root);\n\n    Array.from(nodes||[]).forEach(function (node) {\n        if (!/\\bsf-dump-highlight\\b/.test(node.className)) {\n            node.className = node.className + ' sf-dump-highlight';\n        }\n    });\n\n    if (!/\\bsf-dump-highlight-active\\b/.test(activeNode.className)) {\n        activeNode.className = activeNode.className + ' sf-dump-highlight-active';\n    }\n}\n\nfunction resetHighlightedNodes(root) {\n    Array.from(root.querySelectorAll('.sf-dump-str, .sf-dump-key, .sf-dump-public, .sf-dump-protected, .sf-dump-private')).forEach(function (strNode) {\n        strNode.className = strNode.className.replace(/\\bsf-dump-highlight\\b/, '');\n        strNode.className = strNode.className.replace(/\\bsf-dump-highlight-active\\b/, '');\n    });\n}\n\nreturn function (root, x) {\n    root = doc.getElementById(root);\n\n    var indentRx = new RegExp('^('+(root.getAttribute('data-indent-pad') || '  ').replace(rxEsc, '\\\\$1')+')+', 'm'),\n        options = {$options},\n        elt = root.getElementsByTagName('A'),\n        len = elt.length,\n        i = 0, s, h,\n        t = [];\n\n    while (i < len) t.push(elt[i++]);\n\n    for (i in x) {\n        options[i] = x[i];\n    }\n\n    function a(e, f) {\n        addEventListener(root, e, function (e) {\n            if ('A' == e.target.tagName) {\n                f(e.target, e);\n            } else if ('A' == e.target.parentNode.tagName) {\n                f(e.target.parentNode, e);\n            } else if (e.target.nextElementSibling && 'A' == e.target.nextElementSibling.tagName) {\n                f(e.target.nextElementSibling, e, true);\n            }\n        });\n    };\n    function isCtrlKey(e) {\n        return e.ctrlKey || e.metaKey;\n    }\n    function xpathString(str) {\n        var parts = str.match(/[^'\"]+|['\"]/g).map(function (part) {\n            if (\"'\" == part)  {\n                return '\"\\'\"';\n            }\n            if ('\"' == part) {\n                return \"'\\\"'\";\n            }\n\n            return \"'\" + part + \"'\";\n        });\n\n        return \"concat(\" + parts.join(\",\") + \", '')\";\n    }\n    function xpathHasClass(className) {\n        return \"contains(concat(' ', normalize-space(@class), ' '), ' \" + className +\" ')\";\n    }\n    addEventListener(root, 'mouseover', function (e) {\n        if ('' != refStyle.innerHTML) {\n            refStyle.innerHTML = '';\n        }\n    });\n    a('mouseover', function (a, e, c) {\n        if (c) {\n            e.target.style.cursor = \"pointer\";\n        } else if (a = idRx.exec(a.className)) {\n            try {\n                refStyle.innerHTML = 'pre.sf-dump .'+a[0]+'{background-color: #B729D9; color: #FFF !important; border-radius: 2px}';\n            } catch (e) {\n            }\n        }\n    });\n    a('click', function (a, e, c) {\n        if (/\\bsf-dump-toggle\\b/.test(a.className)) {\n            e.preventDefault();\n            if (!toggle(a, isCtrlKey(e))) {\n                var r = doc.getElementById(a.getAttribute('href').substr(1)),\n                    s = r.previousSibling,\n                    f = r.parentNode,\n                    t = a.parentNode;\n                t.replaceChild(r, a);\n                f.replaceChild(a, s);\n                t.insertBefore(s, r);\n                f = f.firstChild.nodeValue.match(indentRx);\n                t = t.firstChild.nodeValue.match(indentRx);\n                if (f && t && f[0] !== t[0]) {\n                    r.innerHTML = r.innerHTML.replace(new RegExp('^'+f[0].replace(rxEsc, '\\\\$1'), 'mg'), t[0]);\n                }\n                if (/\\bsf-dump-compact\\b/.test(r.className)) {\n                    toggle(s, isCtrlKey(e));\n                }\n            }\n\n            if (c) {\n            } else if (doc.getSelection) {\n                try {\n                    doc.getSelection().removeAllRanges();\n                } catch (e) {\n                    doc.getSelection().empty();\n                }\n            } else {\n                doc.selection.empty();\n            }\n        } else if (/\\bsf-dump-str-toggle\\b/.test(a.className)) {\n            e.preventDefault();\n            e = a.parentNode.parentNode;\n            e.className = e.className.replace(/\\bsf-dump-str-(expand|collapse)\\b/, a.parentNode.className);\n        }\n    });\n\n    elt = root.getElementsByTagName('SAMP');\n    len = elt.length;\n    i = 0;\n\n    while (i < len) t.push(elt[i++]);\n    len = t.length;\n\n    for (i = 0; i < len; ++i) {\n        elt = t[i];\n        if ('SAMP' == elt.tagName) {\n            a = elt.previousSibling || {};\n            if ('A' != a.tagName) {\n                a = doc.createElement('A');\n                a.className = 'sf-dump-ref';\n                elt.parentNode.insertBefore(a, elt);\n            } else {\n                a.innerHTML += ' ';\n            }\n            a.title = (a.title ? a.title+'\\n[' : '[')+keyHint+'+click] Expand all children';\n            a.innerHTML += '<span>▼</span>';\n            a.className += ' sf-dump-toggle';\n\n            x = 1;\n            if ('sf-dump' != elt.parentNode.className) {\n                x += elt.parentNode.getAttribute('data-depth')/1;\n            }\n            elt.setAttribute('data-depth', x);\n            var className = elt.className;\n            elt.className = 'sf-dump-expanded';\n            if (className ? 'sf-dump-expanded' !== className : (x > options.maxDepth)) {\n                toggle(a);\n            }\n        } else if (/\\bsf-dump-ref\\b/.test(elt.className) && (a = elt.getAttribute('href'))) {\n            a = a.substr(1);\n            elt.className += ' '+a;\n\n            if (/[\\[{]$/.test(elt.previousSibling.nodeValue)) {\n                a = a != elt.nextSibling.id && doc.getElementById(a);\n                try {\n                    s = a.nextSibling;\n                    elt.appendChild(a);\n                    s.parentNode.insertBefore(a, s);\n                    if (/^[@#]/.test(elt.innerHTML)) {\n                        elt.innerHTML += ' <span>▶</span>';\n                    } else {\n                        elt.innerHTML = '<span>▶</span>';\n                        elt.className = 'sf-dump-ref';\n                    }\n                    elt.className += ' sf-dump-toggle';\n                } catch (e) {\n                    if ('&' == elt.innerHTML.charAt(0)) {\n                        elt.innerHTML = '…';\n                        elt.className = 'sf-dump-ref';\n                    }\n                }\n            }\n        }\n    }\n\n    if (doc.evaluate && Array.from && root.children.length > 1) {\n        root.setAttribute('tabindex', 0);\n\n        SearchState = function () {\n            this.nodes = [];\n            this.idx = 0;\n        };\n        SearchState.prototype = {\n            next: function () {\n                if (this.isEmpty()) {\n                    return this.current();\n                }\n                this.idx = this.idx < (this.nodes.length - 1) ? this.idx + 1 : 0;\n\n                return this.current();\n            },\n            previous: function () {\n                if (this.isEmpty()) {\n                    return this.current();\n                }\n                this.idx = this.idx > 0 ? this.idx - 1 : (this.nodes.length - 1);\n\n                return this.current();\n            },\n            isEmpty: function () {\n                return 0 === this.count();\n            },\n            current: function () {\n                if (this.isEmpty()) {\n                    return null;\n                }\n                return this.nodes[this.idx];\n            },\n            reset: function () {\n                this.nodes = [];\n                this.idx = 0;\n            },\n            count: function () {\n                return this.nodes.length;\n            },\n        };\n\n        function showCurrent(state)\n        {\n            var currentNode = state.current();\n            if (currentNode) {\n                reveal(currentNode);\n                highlight(root, currentNode, state.nodes);\n            }\n            counter.textContent = (state.isEmpty() ? 0 : state.idx + 1) + ' of ' + state.count();\n        }\n\n        var search = doc.createElement('div');\n        search.className = 'sf-dump-search-wrapper sf-dump-search-hidden';\n        search.innerHTML = '\n            <input type=\"text\" class=\"sf-dump-search-input\">\n            <span class=\"sf-dump-search-count\">0 of 0<\\/span>\n            <button type=\"button\" class=\"sf-dump-search-input-previous\" tabindex=\"-1\">\n                <svg viewBox=\"0 0 1792 1792\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M1683 1331l-166 165q-19 19-45 19t-45-19L896 965l-531 531q-19 19-45 19t-45-19l-166-165q-19-19-19-45.5t19-45.5l742-741q19-19 45-19t45 19l742 741q19 19 19 45.5t-19 45.5z\"\\/><\\/svg>\n            <\\/button>\n            <button type=\"button\" class=\"sf-dump-search-input-next\" tabindex=\"-1\">\n                <svg viewBox=\"0 0 1792 1792\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M1683 808l-742 741q-19 19-45 19t-45-19L109 808q-19-19-19-45.5t19-45.5l166-165q19-19 45-19t45 19l531 531 531-531q19-19 45-19t45 19l166 165q19 19 19 45.5t-19 45.5z\"\\/><\\/svg>\n            <\\/button>\n        ';\n        root.insertBefore(search, root.firstChild);\n\n        var state = new SearchState();\n        var searchInput = search.querySelector('.sf-dump-search-input');\n        var counter = search.querySelector('.sf-dump-search-count');\n        var searchInputTimer = 0;\n        var previousSearchQuery = '';\n\n        addEventListener(searchInput, 'keyup', function (e) {\n            var searchQuery = e.target.value;\n            /* Don't perform anything if the pressed key didn't change the query */\n            if (searchQuery === previousSearchQuery) {\n                return;\n            }\n            previousSearchQuery = searchQuery;\n            clearTimeout(searchInputTimer);\n            searchInputTimer = setTimeout(function () {\n                state.reset();\n                collapseAll(root);\n                resetHighlightedNodes(root);\n                if ('' === searchQuery) {\n                    counter.textContent = '0 of 0';\n\n                    return;\n                }\n\n                var classMatches = [\n                    \"sf-dump-str\",\n                    \"sf-dump-key\",\n                    \"sf-dump-public\",\n                    \"sf-dump-protected\",\n                    \"sf-dump-private\",\n                ].map(xpathHasClass).join(' or ');\n\n                var xpathResult = doc.evaluate('.//span[' + classMatches + '][contains(translate(child::text(), ' + xpathString(searchQuery.toUpperCase()) + ', ' + xpathString(searchQuery.toLowerCase()) + '), ' + xpathString(searchQuery.toLowerCase()) + ')]', root, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);\n\n                while (node = xpathResult.iterateNext()) state.nodes.push(node);\n\n                showCurrent(state);\n            }, 400);\n        });\n\n        Array.from(search.querySelectorAll('.sf-dump-search-input-next, .sf-dump-search-input-previous')).forEach(function (btn) {\n            addEventListener(btn, 'click', function (e) {\n                e.preventDefault();\n                -1 !== e.target.className.indexOf('next') ? state.next() : state.previous();\n                searchInput.focus();\n                collapseAll(root);\n                showCurrent(state);\n            })\n        });\n\n        addEventListener(root, 'keydown', function (e) {\n            var isSearchActive = !/\\bsf-dump-search-hidden\\b/.test(search.className);\n            if ((114 === e.keyCode && !isSearchActive) || (isCtrlKey(e) && 70 === e.keyCode)) {\n                /* F3 or CMD/CTRL + F */\n                e.preventDefault();\n                search.className = search.className.replace(/\\bsf-dump-search-hidden\\b/, '');\n                searchInput.focus();\n            } else if (isSearchActive) {\n                if (27 === e.keyCode) {\n                    /* ESC key */\n                    search.className += ' sf-dump-search-hidden';\n                    e.preventDefault();\n                    resetHighlightedNodes(root);\n                    searchInput.value = '';\n                } else if (\n                    (isCtrlKey(e) && 71 === e.keyCode) /* CMD/CTRL + G */\n                    || 13 === e.keyCode /* Enter */\n                    || 114 === e.keyCode /* F3 */\n                ) {\n                    e.preventDefault();\n                    e.shiftKey ? state.previous() : state.next();\n                    collapseAll(root);\n                    showCurrent(state);\n                }\n            }\n        });\n    }\n\n    if (0 >= options.maxStringLength) {\n        return;\n    }\n    try {\n        elt = root.querySelectorAll('.sf-dump-str');\n        len = elt.length;\n        i = 0;\n        t = [];\n\n        while (i < len) t.push(elt[i++]);\n        len = t.length;\n\n        for (i = 0; i < len; ++i) {\n            elt = t[i];\n            s = elt.innerText || elt.textContent;\n            x = s.length - options.maxStringLength;\n            if (0 < x) {\n                h = elt.innerHTML;\n                elt[elt.innerText ? 'innerText' : 'textContent'] = s.substring(0, options.maxStringLength);\n                elt.className += ' sf-dump-str-collapse';\n                elt.innerHTML = '<span class=sf-dump-str-collapse>'+h+'<a class=\"sf-dump-ref sf-dump-str-toggle\" title=\"Collapse\"> ◀</a></span>'+\n                    '<span class=sf-dump-str-expand>'+elt.innerHTML+'<a class=\"sf-dump-ref sf-dump-str-toggle\" title=\"'+x+' remaining characters\"> ▶</a></span>';\n            }\n        }\n    } catch (e) {\n    }\n};\n\n})(document);\n</script><style>\npre.sf-dump {\n    display: block;\n    white-space: pre;\n    padding: 5px;\n}\npre.sf-dump:after {\n   content: \"\";\n   visibility: hidden;\n   display: block;\n   height: 0;\n   clear: both;\n}\npre.sf-dump span {\n    display: inline;\n}\npre.sf-dump .sf-dump-compact {\n    display: none;\n}\npre.sf-dump abbr {\n    text-decoration: none;\n    border: none;\n    cursor: help;\n}\npre.sf-dump a {\n    text-decoration: none;\n    cursor: pointer;\n    border: 0;\n    outline: none;\n    color: inherit;\n}\npre.sf-dump .sf-dump-ellipsis {\n    display: inline-block;\n    overflow: visible;\n    text-overflow: ellipsis;\n    max-width: 5em;\n    white-space: nowrap;\n    overflow: hidden;\n    vertical-align: top;\n}\npre.sf-dump .sf-dump-ellipsis+.sf-dump-ellipsis {\n    max-width: none;\n}\npre.sf-dump code {\n    display:inline;\n    padding:0;\n    background:none;\n}\n.sf-dump-str-collapse .sf-dump-str-collapse {\n    display: none;\n}\n.sf-dump-str-expand .sf-dump-str-expand {\n    display: none;\n}\n.sf-dump-public.sf-dump-highlight,\n.sf-dump-protected.sf-dump-highlight,\n.sf-dump-private.sf-dump-highlight,\n.sf-dump-str.sf-dump-highlight,\n.sf-dump-key.sf-dump-highlight {\n    background: rgba(111, 172, 204, 0.3);\n    border: 1px solid #7DA0B1;\n    border-radius: 3px;\n}\n.sf-dump-public.sf-dump-highlight-active,\n.sf-dump-protected.sf-dump-highlight-active,\n.sf-dump-private.sf-dump-highlight-active,\n.sf-dump-str.sf-dump-highlight-active,\n.sf-dump-key.sf-dump-highlight-active {\n    background: rgba(253, 175, 0, 0.4);\n    border: 1px solid #ffa500;\n    border-radius: 3px;\n}\npre.sf-dump .sf-dump-search-hidden {\n    display: none;\n}\npre.sf-dump .sf-dump-search-wrapper {\n    float: right;\n    font-size: 0;\n    white-space: nowrap;\n    max-width: 100%;\n    text-align: right;\n}\npre.sf-dump .sf-dump-search-wrapper > * {\n    vertical-align: top;\n    box-sizing: border-box;\n    height: 21px;\n    font-weight: normal;\n    border-radius: 0;\n    background: #FFF;\n    color: #757575;\n    border: 1px solid #BBB;\n}\npre.sf-dump .sf-dump-search-wrapper > input.sf-dump-search-input {\n    padding: 3px;\n    height: 21px;\n    font-size: 12px;\n    border-right: none;\n    width: 140px;\n    border-top-left-radius: 3px;\n    border-bottom-left-radius: 3px;\n    color: #000;\n}\npre.sf-dump .sf-dump-search-wrapper > .sf-dump-search-input-next,\npre.sf-dump .sf-dump-search-wrapper > .sf-dump-search-input-previous {\n    background: #F2F2F2;\n    outline: none;\n    border-left: none;\n    font-size: 0;\n    line-height: 0;\n}\npre.sf-dump .sf-dump-search-wrapper > .sf-dump-search-input-next {\n    border-top-right-radius: 3px;\n    border-bottom-right-radius: 3px;\n}\npre.sf-dump .sf-dump-search-wrapper > .sf-dump-search-input-next > svg,\npre.sf-dump .sf-dump-search-wrapper > .sf-dump-search-input-previous > svg {\n    pointer-events: none;\n    width: 12px;\n    height: 12px;\n}\npre.sf-dump .sf-dump-search-wrapper > .sf-dump-search-count {\n    display: inline-block;\n    padding: 0 5px;\n    margin: 0;\n    border-left: none;\n    line-height: 21px;\n    font-size: 12px;\n}\nEOHTML\n        );\n\n        foreach ($this->styles as $class => $style) {\n            $line .= 'pre.sf-dump'.('default' === $class ? ', pre.sf-dump' : '').' .sf-dump-'.$class.'{'.$style.'}';\n        }\n\n        return $this->dumpHeader = preg_replace('/\\s+/', ' ', $line).'</style>'.$this->dumpHeader;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function enterHash(Cursor $cursor, $type, $class, $hasChild)\n    {\n        parent::enterHash($cursor, $type, $class, false);\n\n        if ($cursor->skipChildren) {\n            $cursor->skipChildren = false;\n            $eol = ' class=sf-dump-compact>';\n        } elseif ($this->expandNextHash) {\n            $this->expandNextHash = false;\n            $eol = ' class=sf-dump-expanded>';\n        } else {\n            $eol = '>';\n        }\n\n        if ($hasChild) {\n            $this->line .= '<samp';\n            if ($cursor->refIndex) {\n                $r = Cursor::HASH_OBJECT !== $type ? 1 - (Cursor::HASH_RESOURCE !== $type) : 2;\n                $r .= $r && 0 < $cursor->softRefHandle ? $cursor->softRefHandle : $cursor->refIndex;\n\n                $this->line .= sprintf(' id=%s-ref%s', $this->dumpId, $r);\n            }\n            $this->line .= $eol;\n            $this->dumpLine($cursor->depth);\n        }\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function leaveHash(Cursor $cursor, $type, $class, $hasChild, $cut)\n    {\n        $this->dumpEllipsis($cursor, $hasChild, $cut);\n        if ($hasChild) {\n            $this->line .= '</samp>';\n        }\n        parent::leaveHash($cursor, $type, $class, $hasChild, 0);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function style($style, $value, $attr = [])\n    {\n        if ('' === $value) {\n            return '';\n        }\n\n        $v = esc($value);\n\n        if ('ref' === $style) {\n            if (empty($attr['count'])) {\n                return sprintf('<a class=sf-dump-ref>%s</a>', $v);\n            }\n            $r = ('#' !== $v[0] ? 1 - ('@' !== $v[0]) : 2).substr($value, 1);\n\n            return sprintf('<a class=sf-dump-ref href=#%s-ref%s title=\"%d occurrences\">%s</a>', $this->dumpId, $r, 1 + $attr['count'], $v);\n        }\n\n        if ('const' === $style && isset($attr['value'])) {\n            $style .= sprintf(' title=\"%s\"', esc(is_scalar($attr['value']) ? $attr['value'] : json_encode($attr['value'])));\n        } elseif ('public' === $style) {\n            $style .= sprintf(' title=\"%s\"', empty($attr['dynamic']) ? 'Public property' : 'Runtime added dynamic property');\n        } elseif ('str' === $style && 1 < $attr['length']) {\n            $style .= sprintf(' title=\"%d%s characters\"', $attr['length'], $attr['binary'] ? ' binary or non-UTF-8' : '');\n        } elseif ('note' === $style && false !== $c = strrpos($v, '\\\\')) {\n            return sprintf('<abbr title=\"%s\" class=sf-dump-%s>%s</abbr>', $v, $style, substr($v, $c + 1));\n        } elseif ('protected' === $style) {\n            $style .= ' title=\"Protected property\"';\n        } elseif ('meta' === $style && isset($attr['title'])) {\n            $style .= sprintf(' title=\"%s\"', esc($this->utf8Encode($attr['title'])));\n        } elseif ('private' === $style) {\n            $style .= sprintf(' title=\"Private property defined in class:&#10;`%s`\"', esc($this->utf8Encode($attr['class'])));\n        }\n        $map = static::$controlCharsMap;\n\n        if (isset($attr['ellipsis'])) {\n            $class = 'sf-dump-ellipsis';\n            if (isset($attr['ellipsis-type'])) {\n                $class = sprintf('\"%s sf-dump-ellipsis-%s\"', $class, $attr['ellipsis-type']);\n            }\n            $label = esc(substr($value, -$attr['ellipsis']));\n            $style = str_replace(' title=\"', \" title=\\\"$v\\n\", $style);\n            $v = sprintf('<span class=%s>%s</span>', $class, substr($v, 0, -\\strlen($label)));\n\n            if (!empty($attr['ellipsis-tail'])) {\n                $tail = \\strlen(esc(substr($value, -$attr['ellipsis'], $attr['ellipsis-tail'])));\n                $v .= sprintf('<span class=sf-dump-ellipsis>%s</span>%s', substr($label, 0, $tail), substr($label, $tail));\n            } else {\n                $v .= $label;\n            }\n        }\n\n        $v = \"<span class=sf-dump-{$style}>\".preg_replace_callback(static::$controlCharsRx, function ($c) use ($map) {\n            $s = '<span class=sf-dump-default>';\n            $c = $c[$i = 0];\n            do {\n                $s .= isset($map[$c[$i]]) ? $map[$c[$i]] : sprintf('\\x%02X', \\ord($c[$i]));\n            } while (isset($c[++$i]));\n\n            return $s.'</span>';\n        }, $v).'</span>';\n\n        if (isset($attr['file']) && $href = $this->getSourceLink($attr['file'], isset($attr['line']) ? $attr['line'] : 0)) {\n            $attr['href'] = $href;\n        }\n        if (isset($attr['href'])) {\n            $target = isset($attr['file']) ? '' : ' target=\"_blank\"';\n            $v = sprintf('<a href=\"%s\"%s rel=\"noopener noreferrer\">%s</a>', esc($this->utf8Encode($attr['href'])), $target, $v);\n        }\n        if (isset($attr['lang'])) {\n            $v = sprintf('<code class=\"%s\">%s</code>', esc($attr['lang']), $v);\n        }\n\n        return $v;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function dumpLine($depth, $endOfValue = false)\n    {\n        if (-1 === $this->lastDepth) {\n            $this->line = sprintf($this->dumpPrefix, $this->dumpId, $this->indentPad).$this->line;\n        }\n        if ($this->headerIsDumped !== (null !== $this->outputStream ? $this->outputStream : $this->lineDumper)) {\n            $this->line = $this->getDumpHeader().$this->line;\n        }\n\n        if (-1 === $depth) {\n            $args = ['\"'.$this->dumpId.'\"'];\n            if ($this->extraDisplayOptions) {\n                $args[] = json_encode($this->extraDisplayOptions, \\JSON_FORCE_OBJECT);\n            }\n            // Replace is for BC\n            $this->line .= sprintf(str_replace('\"%s\"', '%s', $this->dumpSuffix), implode(', ', $args));\n        }\n        $this->lastDepth = $depth;\n\n        $this->line = mb_convert_encoding($this->line, 'HTML-ENTITIES', 'UTF-8');\n\n        if (-1 === $depth) {\n            AbstractDumper::dumpLine(0);\n        }\n        AbstractDumper::dumpLine($depth);\n    }\n\n    private function getSourceLink($file, $line)\n    {\n        $options = $this->extraDisplayOptions + $this->displayOptions;\n\n        if ($fmt = $options['fileLinkFormat']) {\n            return \\is_string($fmt) ? strtr($fmt, ['%f' => $file, '%l' => $line]) : $fmt->format($file, $line);\n        }\n\n        return false;\n    }\n}\n\nfunction esc($str)\n{\n    return htmlspecialchars($str, \\ENT_QUOTES, 'UTF-8');\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Exception/ThrowingCasterException.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Exception;\n\n/**\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass ThrowingCasterException extends \\Exception\n{\n    /**\n     * @param \\Exception $prev The exception thrown from the caster\n     */\n    public function __construct(\\Exception $prev)\n    {\n        parent::__construct('Unexpected '.\\get_class($prev).' thrown from a caster: '.$prev->getMessage(), 0, $prev);\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/LICENSE',
    'Copyright (c) 2014-2020 Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/phpunit.xml.dist',
    '<?xml version="1.0" encoding="UTF-8"?>\n\n<phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:noNamespaceSchemaLocation="http://schema.phpunit.de/5.2/phpunit.xsd"\n         backupGlobals="false"\n         colors="true"\n         bootstrap="vendor/autoload.php"\n         failOnRisky="true"\n         failOnWarning="true"\n>\n    <php>\n        <ini name="error_reporting" value="-1" />\n        <env name="DUMP_LIGHT_ARRAY" value="" />\n        <env name="DUMP_STRING_LENGTH" value="" />\n    </php>\n\n    <testsuites>\n        <testsuite name="Symfony VarDumper Component Test Suite">\n            <directory>./Tests/</directory>\n        </testsuite>\n    </testsuites>\n\n    <filter>\n        <whitelist>\n            <directory>./</directory>\n            <exclude>\n                <directory>./Resources</directory>\n                <directory>./Tests</directory>\n                <directory>./vendor</directory>\n            </exclude>\n        </whitelist>\n    </filter>\n</phpunit>\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/README.md',
    'VarDumper Component\n===================\n\nThe VarDumper component provides mechanisms for walking through any arbitrary\nPHP variable. It provides a better `dump()` function that you can use instead\nof `var_dump`.\n\nResources\n---------\n\n  * [Documentation](https://symfony.com/doc/current/components/var_dumper/introduction.html)\n  * [Contributing](https://symfony.com/doc/current/contributing/index.html)\n  * [Report issues](https://github.com/symfony/symfony/issues) and\n    [send Pull Requests](https://github.com/symfony/symfony/pulls)\n    in the [main Symfony repository](https://github.com/symfony/symfony)\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Resources/functions/dump.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nuse Symfony\\Component\\VarDumper\\VarDumper;\n\nif (!function_exists('dump')) {\n    /**\n     * @author Nicolas Grekas <p@tchwork.com>\n     */\n    function dump($var)\n    {\n        foreach (func_get_args() as $v) {\n            VarDumper::dump($v);\n        }\n\n        if (1 < func_num_args()) {\n            return func_get_args();\n        }\n\n        return $var;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Test/VarDumperTestTrait.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Test;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\VarCloner;\nuse Symfony\\Component\\VarDumper\\Dumper\\CliDumper;\n\n/**\n * @author Nicolas Grekas <p@tchwork.com>\n */\ntrait VarDumperTestTrait\n{\n    public function assertDumpEquals($dump, $data, $filter = 0, $message = '')\n    {\n        if (\\is_string($filter)) {\n            @trigger_error(sprintf('The $message argument of the \"%s()\" method at the 3rd position is deprecated since Symfony 3.4 and will be moved at the 4th position in 4.0.', __METHOD__), \\E_USER_DEPRECATED);\n            $message = $filter;\n            $filter = 0;\n        }\n\n        $this->assertSame(rtrim($dump), $this->getDump($data, null, $filter), $message);\n    }\n\n    public function assertDumpMatchesFormat($dump, $data, $filter = 0, $message = '')\n    {\n        if (\\is_string($filter)) {\n            @trigger_error(sprintf('The $message argument of the \"%s()\" method at the 3rd position is deprecated since Symfony 3.4 and will be moved at the 4th position in 4.0.', __METHOD__), \\E_USER_DEPRECATED);\n            $message = $filter;\n            $filter = 0;\n        }\n\n        $this->assertStringMatchesFormat(rtrim($dump), $this->getDump($data, null, $filter), $message);\n    }\n\n    /**\n     * @return string|null\n     */\n    protected function getDump($data, $key = null, $filter = 0)\n    {\n        $flags = getenv('DUMP_LIGHT_ARRAY') ? CliDumper::DUMP_LIGHT_ARRAY : 0;\n        $flags |= getenv('DUMP_STRING_LENGTH') ? CliDumper::DUMP_STRING_LENGTH : 0;\n\n        $cloner = new VarCloner();\n        $cloner->setMaxItems(-1);\n        $dumper = new CliDumper(null, null, $flags);\n        $dumper->setColors(false);\n        $data = $cloner->cloneVar($data, $filter)->withRefHandles(false);\n        if (null !== $key && null === $data = $data->seek($key)) {\n            return null;\n        }\n\n        return rtrim($dumper->dump($data, true));\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Tests/Caster/CasterTest.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Tests\\Caster;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Symfony\\Component\\VarDumper\\Caster\\Caster;\nuse Symfony\\Component\\VarDumper\\Test\\VarDumperTestTrait;\n\n/**\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass CasterTest extends TestCase\n{\n    use VarDumperTestTrait;\n\n    private $referenceArray = [\n        'null' => null,\n        'empty' => false,\n        'public' => 'pub',\n        \"\\0~\\0virtual\" => 'virt',\n        \"\\0+\\0dynamic\" => 'dyn',\n        \"\\0*\\0protected\" => 'prot',\n        \"\\0Foo\\0private\" => 'priv',\n    ];\n\n    /**\n     * @dataProvider provideFilter\n     */\n    public function testFilter($filter, $expectedDiff, $listedProperties = null)\n    {\n        if (null === $listedProperties) {\n            $filteredArray = Caster::filter($this->referenceArray, $filter);\n        } else {\n            $filteredArray = Caster::filter($this->referenceArray, $filter, $listedProperties);\n        }\n\n        $this->assertSame($expectedDiff, array_diff_assoc($this->referenceArray, $filteredArray));\n    }\n\n    public function provideFilter()\n    {\n        return [\n            [\n                0,\n                [],\n            ],\n            [\n                Caster::EXCLUDE_PUBLIC,\n                [\n                    'null' => null,\n                    'empty' => false,\n                    'public' => 'pub',\n                ],\n            ],\n            [\n                Caster::EXCLUDE_NULL,\n                [\n                    'null' => null,\n                ],\n            ],\n            [\n                Caster::EXCLUDE_EMPTY,\n                [\n                    'null' => null,\n                    'empty' => false,\n                ],\n            ],\n            [\n                Caster::EXCLUDE_VIRTUAL,\n                [\n                    \"\\0~\\0virtual\" => 'virt',\n                ],\n            ],\n            [\n                Caster::EXCLUDE_DYNAMIC,\n                [\n                    \"\\0+\\0dynamic\" => 'dyn',\n                ],\n            ],\n            [\n                Caster::EXCLUDE_PROTECTED,\n                [\n                    \"\\0*\\0protected\" => 'prot',\n                ],\n            ],\n            [\n                Caster::EXCLUDE_PRIVATE,\n                [\n                    \"\\0Foo\\0private\" => 'priv',\n                ],\n            ],\n            [\n                Caster::EXCLUDE_VERBOSE,\n                [\n                    'public' => 'pub',\n                    \"\\0*\\0protected\" => 'prot',\n                ],\n                ['public', \"\\0*\\0protected\"],\n            ],\n            [\n                Caster::EXCLUDE_NOT_IMPORTANT,\n                [\n                    'null' => null,\n                    'empty' => false,\n                    \"\\0~\\0virtual\" => 'virt',\n                    \"\\0+\\0dynamic\" => 'dyn',\n                    \"\\0Foo\\0private\" => 'priv',\n                ],\n                ['public', \"\\0*\\0protected\"],\n            ],\n            [\n                Caster::EXCLUDE_VIRTUAL | Caster::EXCLUDE_DYNAMIC,\n                [\n                    \"\\0~\\0virtual\" => 'virt',\n                    \"\\0+\\0dynamic\" => 'dyn',\n                ],\n            ],\n            [\n                Caster::EXCLUDE_NOT_IMPORTANT | Caster::EXCLUDE_VERBOSE,\n                $this->referenceArray,\n                ['public', \"\\0*\\0protected\"],\n            ],\n            [\n                Caster::EXCLUDE_NOT_IMPORTANT | Caster::EXCLUDE_EMPTY,\n                [\n                    'null' => null,\n                    'empty' => false,\n                    \"\\0~\\0virtual\" => 'virt',\n                    \"\\0+\\0dynamic\" => 'dyn',\n                    \"\\0*\\0protected\" => 'prot',\n                    \"\\0Foo\\0private\" => 'priv',\n                ],\n                ['public', 'empty'],\n            ],\n            [\n                Caster::EXCLUDE_VERBOSE | Caster::EXCLUDE_EMPTY | Caster::EXCLUDE_STRICT,\n                [\n                    'empty' => false,\n                ],\n                ['public', 'empty'],\n            ],\n        ];\n    }\n\n    /**\n     * @requires PHP 7.0\n     */\n    public function testAnonymousClass()\n    {\n        $c = eval('return new class extends stdClass { private $foo = \"foo\"; };');\n\n        $this->assertDumpMatchesFormat(\n            <<<'EOTXT'\nstdClass@anonymous {\n  -foo: \"foo\"\n}\nEOTXT\n            , $c\n        );\n\n        $c = eval('return new class { private $foo = \"foo\"; };');\n\n        $this->assertDumpMatchesFormat(\n            <<<'EOTXT'\nclass@anonymous {\n  -foo: \"foo\"\n}\nEOTXT\n            , $c\n        );\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Tests/Caster/DateCasterTest.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Tests\\Caster;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Symfony\\Component\\VarDumper\\Caster\\Caster;\nuse Symfony\\Component\\VarDumper\\Caster\\DateCaster;\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\nuse Symfony\\Component\\VarDumper\\Test\\VarDumperTestTrait;\nuse Symfony\\Component\\VarDumper\\Tests\\Fixtures\\DateTimeChild;\n\n/**\n * @author Dany Maillard <danymaillard93b@gmail.com>\n */\nclass DateCasterTest extends TestCase\n{\n    use VarDumperTestTrait;\n\n    /**\n     * @dataProvider provideDateTimes\n     */\n    public function testDumpDateTime($time, $timezone, $xDate, $xTimestamp)\n    {\n        if ((\\defined('HHVM_VERSION_ID') || \\PHP_VERSION_ID <= 50509) && preg_match('/[-+]\\d{2}:\\d{2}/', $timezone)) {\n            $this->markTestSkipped('DateTimeZone GMT offsets are supported since 5.5.10. See https://github.com/facebook/hhvm/issues/5875 for HHVM.');\n        }\n\n        $date = new \\DateTime($time, new \\DateTimeZone($timezone));\n\n        $xDump = <<<EODUMP\nDateTime @$xTimestamp {\n  date: $xDate\n}\nEODUMP;\n\n        $this->assertDumpEquals($xDump, $date);\n    }\n\n    /**\n     * @dataProvider provideDateTimes\n     */\n    public function testCastDateTime($time, $timezone, $xDate, $xTimestamp, $xInfos)\n    {\n        if ((\\defined('HHVM_VERSION_ID') || \\PHP_VERSION_ID <= 50509) && preg_match('/[-+]\\d{2}:\\d{2}/', $timezone)) {\n            $this->markTestSkipped('DateTimeZone GMT offsets are supported since 5.5.10. See https://github.com/facebook/hhvm/issues/5875 for HHVM.');\n        }\n\n        $stub = new Stub();\n        $date = new \\DateTime($time, new \\DateTimeZone($timezone));\n        $cast = DateCaster::castDateTime($date, Caster::castObject($date, \\DateTime::class), $stub, false, 0);\n\n        $xDump = <<<EODUMP\narray:1 [\n  \"\\\\x00~\\\\x00date\" => $xDate\n]\nEODUMP;\n\n        $this->assertDumpEquals($xDump, $cast);\n\n        $xDump = <<<EODUMP\nSymfony\\Component\\VarDumper\\Caster\\ConstStub {\n  +type: 1\n  +class: \"$xDate\"\n  +value: \"%A$xInfos%A\"\n  +cut: 0\n  +handle: 0\n  +refCount: 0\n  +position: 0\n  +attr: []\n}\nEODUMP;\n\n        $this->assertDumpMatchesFormat($xDump, $cast[\"\\0~\\0date\"]);\n    }\n\n    public function provideDateTimes()\n    {\n        return [\n            ['2017-04-30 00:00:00.000000', 'Europe/Zurich', '2017-04-30 00:00:00.0 Europe/Zurich (+02:00)', 1493503200, 'Sunday, April 30, 2017%Afrom now%ADST On'],\n            ['2017-12-31 00:00:00.000000', 'Europe/Zurich', '2017-12-31 00:00:00.0 Europe/Zurich (+01:00)', 1514674800, 'Sunday, December 31, 2017%Afrom now%ADST Off'],\n            ['2017-04-30 00:00:00.000000', '+02:00', '2017-04-30 00:00:00.0 +02:00', 1493503200, 'Sunday, April 30, 2017%Afrom now'],\n\n            ['2017-04-30 00:00:00.100000', '+00:00', '2017-04-30 00:00:00.100 +00:00', 1493510400, 'Sunday, April 30, 2017%Afrom now'],\n            ['2017-04-30 00:00:00.120000', '+00:00', '2017-04-30 00:00:00.120 +00:00', 1493510400, 'Sunday, April 30, 2017%Afrom now'],\n            ['2017-04-30 00:00:00.123000', '+00:00', '2017-04-30 00:00:00.123 +00:00', 1493510400, 'Sunday, April 30, 2017%Afrom now'],\n            ['2017-04-30 00:00:00.123400', '+00:00', '2017-04-30 00:00:00.123400 +00:00', 1493510400, 'Sunday, April 30, 2017%Afrom now'],\n            ['2017-04-30 00:00:00.123450', '+00:00', '2017-04-30 00:00:00.123450 +00:00', 1493510400, 'Sunday, April 30, 2017%Afrom now'],\n            ['2017-04-30 00:00:00.123456', '+00:00', '2017-04-30 00:00:00.123456 +00:00', 1493510400, 'Sunday, April 30, 2017%Afrom now'],\n        ];\n    }\n\n    public function testCastDateTimeWithAdditionalChildProperty()\n    {\n        $stub = new Stub();\n        $date = new DateTimeChild('2020-02-13 00:00:00.123456', new \\DateTimeZone('Europe/Paris'));\n        $objectCast = Caster::castObject($date, DateTimeChild::class);\n        $dateCast = DateCaster::castDateTime($date, $objectCast, $stub, false, 0);\n\n        $xDate = '2020-02-13 00:00:00.123456 Europe/Paris (+01:00)';\n        $xInfo = 'Thursday, February 13, 2020%Afrom now';\n        $xDump = <<<EODUMP\narray:2 [\n  \"\\\\x00Symfony\\Component\\VarDumper\\Tests\\Fixtures\\DateTimeChild\\\\x00addedProperty\" => \"foo\"\n  \"\\\\x00~\\\\x00date\" => $xDate\n]\nEODUMP;\n\n        $this->assertDumpEquals($xDump, $dateCast);\n\n        $xDump = <<<EODUMP\nSymfony\\Component\\VarDumper\\Caster\\ConstStub {\n  +type: 1\n  +class: \"$xDate\"\n  +value: \"%A$xInfo%A\"\n  +cut: 0\n  +handle: 0\n  +refCount: 0\n  +position: 0\n  +attr: []\n}\nEODUMP;\n\n        $this->assertDumpMatchesFormat($xDump, $dateCast[\"\\0~\\0date\"]);\n    }\n\n    /**\n     * @dataProvider provideIntervals\n     */\n    public function testDumpInterval($intervalSpec, $ms, $invert, $expected)\n    {\n        if ($ms && \\PHP_VERSION_ID >= 70200 && version_compare(\\PHP_VERSION, '7.2.0rc3', '<=')) {\n            $this->markTestSkipped('Skipped on 7.2 before rc4 because of php bug #75354.');\n        }\n\n        $interval = $this->createInterval($intervalSpec, $ms, $invert);\n\n        $xDump = <<<EODUMP\nDateInterval {\n  interval: $expected\n%A}\nEODUMP;\n\n        $this->assertDumpMatchesFormat($xDump, $interval);\n    }\n\n    /**\n     * @dataProvider provideIntervals\n     */\n    public function testDumpIntervalExcludingVerbosity($intervalSpec, $ms, $invert, $expected)\n    {\n        if ($ms && \\PHP_VERSION_ID >= 70200 && version_compare(\\PHP_VERSION, '7.2.0rc3', '<=')) {\n            $this->markTestSkipped('Skipped on 7.2 before rc4 because of php bug #75354.');\n        }\n\n        $interval = $this->createInterval($intervalSpec, $ms, $invert);\n\n        $xDump = <<<EODUMP\nDateInterval {\n  interval: $expected\n}\nEODUMP;\n\n        $this->assertDumpEquals($xDump, $interval, Caster::EXCLUDE_VERBOSE);\n    }\n\n    /**\n     * @dataProvider provideIntervals\n     */\n    public function testCastInterval($intervalSpec, $ms, $invert, $xInterval, $xSeconds)\n    {\n        if ($ms && \\PHP_VERSION_ID >= 70200 && version_compare(\\PHP_VERSION, '7.2.0rc3', '<=')) {\n            $this->markTestSkipped('Skipped on 7.2 before rc4 because of php bug #75354.');\n        }\n\n        $interval = $this->createInterval($intervalSpec, $ms, $invert);\n        $stub = new Stub();\n\n        $cast = DateCaster::castInterval($interval, ['foo' => 'bar'], $stub, false, Caster::EXCLUDE_VERBOSE);\n\n        $xDump = <<<EODUMP\narray:1 [\n  \"\\\\x00~\\\\x00interval\" => $xInterval\n]\nEODUMP;\n\n        $this->assertDumpEquals($xDump, $cast);\n\n        if (null === $xSeconds) {\n            return;\n        }\n\n        $xDump = <<<EODUMP\nSymfony\\Component\\VarDumper\\Caster\\ConstStub {\n  +type: 1\n  +class: \"$xInterval\"\n  +value: \"$xSeconds\"\n  +cut: 0\n  +handle: 0\n  +refCount: 0\n  +position: 0\n  +attr: []\n}\nEODUMP;\n\n        $this->assertDumpMatchesFormat($xDump, $cast[\"\\0~\\0interval\"]);\n    }\n\n    public function provideIntervals()\n    {\n        $i = new \\DateInterval('PT0S');\n        $ms = ($withMs = \\PHP_VERSION_ID >= 70100 && isset($i->f)) ? '.0' : '';\n\n        return [\n            ['PT0S', 0, 0, '0s', '0s'],\n            ['PT0S', 0.1, 0, $withMs ? '+ 00:00:00.100' : '0s', '%is'],\n            ['PT1S', 0, 0, '+ 00:00:01'.$ms, '%is'],\n            ['PT2M', 0, 0, '+ 00:02:00'.$ms, '%is'],\n            ['PT3H', 0, 0, '+ 03:00:00'.$ms, '%ss'],\n            ['P4D', 0, 0, '+ 4d', '%ss'],\n            ['P5M', 0, 0, '+ 5m', null],\n            ['P6Y', 0, 0, '+ 6y', null],\n            ['P1Y2M3DT4H5M6S', 0, 0, '+ 1y 2m 3d 04:05:06'.$ms, null],\n            ['PT1M60S', 0, 0, '+ 00:02:00'.$ms, null],\n            ['PT1H60M', 0, 0, '+ 02:00:00'.$ms, null],\n            ['P1DT24H', 0, 0, '+ 2d', null],\n            ['P1M32D', 0, 0, '+ 1m 32d', null],\n\n            ['PT0S', 0, 1, '0s', '0s'],\n            ['PT0S', 0.1, 1, $withMs ? '- 00:00:00.100' : '0s', '%is'],\n            ['PT1S', 0, 1, '- 00:00:01'.$ms, '%is'],\n            ['PT2M', 0, 1, '- 00:02:00'.$ms, '%is'],\n            ['PT3H', 0, 1, '- 03:00:00'.$ms, '%ss'],\n            ['P4D', 0, 1, '- 4d', '%ss'],\n            ['P5M', 0, 1, '- 5m', null],\n            ['P6Y', 0, 1, '- 6y', null],\n            ['P1Y2M3DT4H5M6S', 0, 1, '- 1y 2m 3d 04:05:06'.$ms, null],\n            ['PT1M60S', 0, 1, '- 00:02:00'.$ms, null],\n            ['PT1H60M', 0, 1, '- 02:00:00'.$ms, null],\n            ['P1DT24H', 0, 1, '- 2d', null],\n            ['P1M32D', 0, 1, '- 1m 32d', null],\n        ];\n    }\n\n    /**\n     * @dataProvider provideTimeZones\n     */\n    public function testDumpTimeZone($timezone, $expected)\n    {\n        if ((\\defined('HHVM_VERSION_ID') || \\PHP_VERSION_ID <= 50509) && !preg_match('/\\w+\\/\\w+/', $timezone)) {\n            $this->markTestSkipped('DateTimeZone GMT offsets are supported since 5.5.10. See https://github.com/facebook/hhvm/issues/5875 for HHVM.');\n        }\n\n        $timezone = new \\DateTimeZone($timezone);\n\n        $xDump = <<<EODUMP\nDateTimeZone {\n  timezone: $expected\n%A}\nEODUMP;\n\n        $this->assertDumpMatchesFormat($xDump, $timezone);\n    }\n\n    /**\n     * @dataProvider provideTimeZones\n     */\n    public function testDumpTimeZoneExcludingVerbosity($timezone, $expected)\n    {\n        if ((\\defined('HHVM_VERSION_ID') || \\PHP_VERSION_ID <= 50509) && !preg_match('/\\w+\\/\\w+/', $timezone)) {\n            $this->markTestSkipped('DateTimeZone GMT offsets are supported since 5.5.10. See https://github.com/facebook/hhvm/issues/5875 for HHVM.');\n        }\n\n        $timezone = new \\DateTimeZone($timezone);\n\n        $xDump = <<<EODUMP\nDateTimeZone {\n  timezone: $expected\n}\nEODUMP;\n\n        $this->assertDumpMatchesFormat($xDump, $timezone, Caster::EXCLUDE_VERBOSE);\n    }\n\n    /**\n     * @dataProvider provideTimeZones\n     */\n    public function testCastTimeZone($timezone, $xTimezone, $xRegion)\n    {\n        if ((\\defined('HHVM_VERSION_ID') || \\PHP_VERSION_ID <= 50509) && !preg_match('/\\w+\\/\\w+/', $timezone)) {\n            $this->markTestSkipped('DateTimeZone GMT offsets are supported since 5.5.10. See https://github.com/facebook/hhvm/issues/5875 for HHVM.');\n        }\n\n        $timezone = new \\DateTimeZone($timezone);\n        $stub = new Stub();\n\n        $cast = DateCaster::castTimeZone($timezone, ['foo' => 'bar'], $stub, false, Caster::EXCLUDE_VERBOSE);\n\n        $xDump = <<<EODUMP\narray:1 [\n  \"\\\\x00~\\\\x00timezone\" => $xTimezone\n]\nEODUMP;\n\n        $this->assertDumpMatchesFormat($xDump, $cast);\n\n        $xDump = <<<EODUMP\nSymfony\\Component\\VarDumper\\Caster\\ConstStub {\n  +type: 1\n  +class: \"$xTimezone\"\n  +value: \"$xRegion\"\n  +cut: 0\n  +handle: 0\n  +refCount: 0\n  +position: 0\n  +attr: []\n}\nEODUMP;\n\n        $this->assertDumpMatchesFormat($xDump, $cast[\"\\0~\\0timezone\"]);\n    }\n\n    public function provideTimeZones()\n    {\n        $xRegion = \\extension_loaded('intl') ? '%s' : '';\n\n        return [\n            // type 1 (UTC offset)\n            ['-12:00', '-12:00', ''],\n            ['+00:00', '+00:00', ''],\n            ['+14:00', '+14:00', ''],\n\n            // type 2 (timezone abbreviation)\n            ['GMT', '+00:00', ''],\n            ['a', '+01:00', ''],\n            ['b', '+02:00', ''],\n            ['z', '+00:00', ''],\n\n            // type 3 (timezone identifier)\n            ['Africa/Tunis', 'Africa/Tunis (%s:00)', $xRegion],\n            ['America/Panama', 'America/Panama (%s:00)', $xRegion],\n            ['Asia/Jerusalem', 'Asia/Jerusalem (%s:00)', $xRegion],\n            ['Atlantic/Canary', 'Atlantic/Canary (%s:00)', $xRegion],\n            ['Australia/Perth', 'Australia/Perth (%s:00)', $xRegion],\n            ['Europe/Zurich', 'Europe/Zurich (%s:00)', $xRegion],\n            ['Pacific/Tahiti', 'Pacific/Tahiti (%s:00)', $xRegion],\n        ];\n    }\n\n    /**\n     * @dataProvider providePeriods\n     */\n    public function testDumpPeriod($start, $interval, $end, $options, $expected)\n    {\n        if (\\defined('HHVM_VERSION_ID') || \\PHP_VERSION_ID < 50620 || (\\PHP_VERSION_ID >= 70000 && \\PHP_VERSION_ID < 70005)) {\n            $this->markTestSkipped();\n        }\n\n        $p = new \\DatePeriod(new \\DateTime($start), new \\DateInterval($interval), \\is_int($end) ? $end : new \\DateTime($end), $options);\n\n        $xDump = <<<EODUMP\nDatePeriod {\n  period: $expected\n%A}\nEODUMP;\n\n        $this->assertDumpMatchesFormat($xDump, $p);\n    }\n\n    /**\n     * @dataProvider providePeriods\n     */\n    public function testCastPeriod($start, $interval, $end, $options, $xPeriod, $xDates)\n    {\n        if (\\defined('HHVM_VERSION_ID') || \\PHP_VERSION_ID < 50620 || (\\PHP_VERSION_ID >= 70000 && \\PHP_VERSION_ID < 70005)) {\n            $this->markTestSkipped();\n        }\n\n        $p = new \\DatePeriod(new \\DateTime($start), new \\DateInterval($interval), \\is_int($end) ? $end : new \\DateTime($end), $options);\n        $stub = new Stub();\n\n        $cast = DateCaster::castPeriod($p, [], $stub, false, 0);\n\n        $xDump = <<<EODUMP\narray:1 [\n  \"\\\\x00~\\\\x00period\" => $xPeriod\n]\nEODUMP;\n\n        $this->assertDumpEquals($xDump, $cast);\n\n        $xDump = <<<EODUMP\nSymfony\\Component\\VarDumper\\Caster\\ConstStub {\n  +type: 1\n  +class: \"$xPeriod\"\n  +value: \"%A$xDates%A\"\n  +cut: 0\n  +handle: 0\n  +refCount: 0\n  +position: 0\n  +attr: []\n}\nEODUMP;\n\n        $this->assertDumpMatchesFormat($xDump, $cast[\"\\0~\\0period\"]);\n    }\n\n    public function providePeriods()\n    {\n        $i = new \\DateInterval('PT0S');\n        $ms = \\PHP_VERSION_ID >= 70100 && isset($i->f) ? '.0' : '';\n\n        $periods = [\n            ['2017-01-01', 'P1D', '2017-01-03', 0, 'every + 1d, from 2017-01-01 00:00:00.0 (included) to 2017-01-03 00:00:00.0', '1) 2017-01-01%a2) 2017-01-02'],\n            ['2017-01-01', 'P1D', 1, 0, 'every + 1d, from 2017-01-01 00:00:00.0 (included) recurring 2 time/s', '1) 2017-01-01%a2) 2017-01-02'],\n\n            ['2017-01-01', 'P1D', '2017-01-04', 0, 'every + 1d, from 2017-01-01 00:00:00.0 (included) to 2017-01-04 00:00:00.0', '1) 2017-01-01%a2) 2017-01-02%a3) 2017-01-03'],\n            ['2017-01-01', 'P1D', 2, 0, 'every + 1d, from 2017-01-01 00:00:00.0 (included) recurring 3 time/s', '1) 2017-01-01%a2) 2017-01-02%a3) 2017-01-03'],\n\n            ['2017-01-01', 'P1D', '2017-01-05', 0, 'every + 1d, from 2017-01-01 00:00:00.0 (included) to 2017-01-05 00:00:00.0', '1) 2017-01-01%a2) 2017-01-02%a1 more'],\n            ['2017-01-01', 'P1D', 3, 0, 'every + 1d, from 2017-01-01 00:00:00.0 (included) recurring 4 time/s', '1) 2017-01-01%a2) 2017-01-02%a3) 2017-01-03%a1 more'],\n\n            ['2017-01-01', 'P1D', '2017-01-21', 0, 'every + 1d, from 2017-01-01 00:00:00.0 (included) to 2017-01-21 00:00:00.0', '1) 2017-01-01%a17 more'],\n            ['2017-01-01', 'P1D', 19, 0, 'every + 1d, from 2017-01-01 00:00:00.0 (included) recurring 20 time/s', '1) 2017-01-01%a17 more'],\n\n            ['2017-01-01 01:00:00', 'P1D', '2017-01-03 01:00:00', 0, 'every + 1d, from 2017-01-01 01:00:00.0 (included) to 2017-01-03 01:00:00.0', '1) 2017-01-01 01:00:00.0%a2) 2017-01-02 01:00:00.0'],\n            ['2017-01-01 01:00:00', 'P1D', 1, 0, 'every + 1d, from 2017-01-01 01:00:00.0 (included) recurring 2 time/s', '1) 2017-01-01 01:00:00.0%a2) 2017-01-02 01:00:00.0'],\n\n            ['2017-01-01', 'P1DT1H', '2017-01-03', 0, \"every + 1d 01:00:00$ms, from 2017-01-01 00:00:00.0 (included) to 2017-01-03 00:00:00.0\", '1) 2017-01-01 00:00:00.0%a2) 2017-01-02 01:00:00.0'],\n            ['2017-01-01', 'P1DT1H', 1, 0, \"every + 1d 01:00:00$ms, from 2017-01-01 00:00:00.0 (included) recurring 2 time/s\", '1) 2017-01-01 00:00:00.0%a2) 2017-01-02 01:00:00.0'],\n\n            ['2017-01-01', 'P1D', '2017-01-04', \\DatePeriod::EXCLUDE_START_DATE, 'every + 1d, from 2017-01-01 00:00:00.0 (excluded) to 2017-01-04 00:00:00.0', '1) 2017-01-02%a2) 2017-01-03'],\n            ['2017-01-01', 'P1D', 2, \\DatePeriod::EXCLUDE_START_DATE, 'every + 1d, from 2017-01-01 00:00:00.0 (excluded) recurring 2 time/s', '1) 2017-01-02%a2) 2017-01-03'],\n        ];\n\n        if (\\PHP_VERSION_ID < 70107) {\n            array_walk($periods, function (&$i) { $i[5] = ''; });\n        }\n\n        return $periods;\n    }\n\n    private function createInterval($intervalSpec, $ms, $invert)\n    {\n        $interval = new \\DateInterval($intervalSpec);\n        if (\\PHP_VERSION_ID >= 70100 && isset($interval->f)) {\n            $interval->f = $ms;\n        }\n        $interval->invert = $invert;\n\n        return $interval;\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Tests/Caster/ExceptionCasterTest.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Tests\\Caster;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Symfony\\Component\\VarDumper\\Caster\\Caster;\nuse Symfony\\Component\\VarDumper\\Caster\\ExceptionCaster;\nuse Symfony\\Component\\VarDumper\\Caster\\FrameStub;\nuse Symfony\\Component\\VarDumper\\Cloner\\VarCloner;\nuse Symfony\\Component\\VarDumper\\Dumper\\HtmlDumper;\nuse Symfony\\Component\\VarDumper\\Test\\VarDumperTestTrait;\n\nclass ExceptionCasterTest extends TestCase\n{\n    use VarDumperTestTrait;\n\n    private function getTestException($msg, &$ref = null)\n    {\n        return new \\Exception(''.$msg);\n    }\n\n    protected function tearDown()\n    {\n        ExceptionCaster::$srcContext = 1;\n        ExceptionCaster::$traceArgs = true;\n    }\n\n    public function testDefaultSettings()\n    {\n        $ref = ['foo'];\n        $e = $this->getTestException('foo', $ref);\n\n        $expectedDump = <<<'EODUMP'\nException {\n  #message: \"foo\"\n  #code: 0\n  #file: \"%sExceptionCasterTest.php\"\n  #line: 28\n  trace: {\n    %s%eTests%eCaster%eExceptionCasterTest.php:28 {\n      › {\n      ›     return new \\Exception(''.$msg);\n      › }\n    }\n    %s%eTests%eCaster%eExceptionCasterTest.php:40 { …}\n%A\nEODUMP;\n\n        $this->assertDumpMatchesFormat($expectedDump, $e);\n        $this->assertSame(['foo'], $ref);\n    }\n\n    public function testSeek()\n    {\n        $e = $this->getTestException(2);\n\n        $expectedDump = <<<'EODUMP'\n{\n  %s%eTests%eCaster%eExceptionCasterTest.php:28 {\n    › {\n    ›     return new \\Exception(''.$msg);\n    › }\n  }\n  %s%eTests%eCaster%eExceptionCasterTest.php:64 { …}\n%A\nEODUMP;\n\n        $this->assertStringMatchesFormat($expectedDump, $this->getDump($e, 'trace'));\n    }\n\n    public function testNoArgs()\n    {\n        $e = $this->getTestException(1);\n        ExceptionCaster::$traceArgs = false;\n\n        $expectedDump = <<<'EODUMP'\nException {\n  #message: \"1\"\n  #code: 0\n  #file: \"%sExceptionCasterTest.php\"\n  #line: 28\n  trace: {\n    %sExceptionCasterTest.php:28 {\n      › {\n      ›     return new \\Exception(''.$msg);\n      › }\n    }\n    %s%eTests%eCaster%eExceptionCasterTest.php:82 { …}\n%A\nEODUMP;\n\n        $this->assertDumpMatchesFormat($expectedDump, $e);\n    }\n\n    public function testNoSrcContext()\n    {\n        $e = $this->getTestException(1);\n        ExceptionCaster::$srcContext = -1;\n\n        $expectedDump = <<<'EODUMP'\nException {\n  #message: \"1\"\n  #code: 0\n  #file: \"%sExceptionCasterTest.php\"\n  #line: 28\n  trace: {\n    %s%eTests%eCaster%eExceptionCasterTest.php:28\n    %s%eTests%eCaster%eExceptionCasterTest.php:%d\n%A\nEODUMP;\n\n        $this->assertDumpMatchesFormat($expectedDump, $e);\n    }\n\n    public function testHtmlDump()\n    {\n        if (ini_get('xdebug.file_link_format') || get_cfg_var('xdebug.file_link_format')) {\n            $this->markTestSkipped('A custom file_link_format is defined.');\n        }\n\n        $e = $this->getTestException(1);\n        ExceptionCaster::$srcContext = -1;\n\n        $cloner = new VarCloner();\n        $cloner->setMaxItems(1);\n        $dumper = new HtmlDumper();\n        $dumper->setDumpHeader('<foo></foo>');\n        $dumper->setDumpBoundaries('<bar>', '</bar>');\n        $dump = $dumper->dump($cloner->cloneVar($e)->withRefHandles(false), true);\n\n        $expectedDump = <<<'EODUMP'\n<foo></foo><bar><span class=sf-dump-note>Exception</span> {<samp>\n  #<span class=sf-dump-protected title=\"Protected property\">message</span>: \"<span class=sf-dump-str>1</span>\"\n  #<span class=sf-dump-protected title=\"Protected property\">code</span>: <span class=sf-dump-num>0</span>\n  #<span class=sf-dump-protected title=\"Protected property\">file</span>: \"<span class=sf-dump-str title=\"%sExceptionCasterTest.php\n%d characters\"><span class=\"sf-dump-ellipsis sf-dump-ellipsis-path\">%s%eVarDumper</span><span class=sf-dump-ellipsis>%e</span>Tests%eCaster%eExceptionCasterTest.php</span>\"\n  #<span class=sf-dump-protected title=\"Protected property\">line</span>: <span class=sf-dump-num>28</span>\n  <span class=sf-dump-meta>trace</span>: {<samp>\n    <span class=sf-dump-meta title=\"%sExceptionCasterTest.php\nStack level %d.\"><span class=\"sf-dump-ellipsis sf-dump-ellipsis-path\">%s%eVarDumper</span><span class=sf-dump-ellipsis>%e</span>Tests%eCaster%eExceptionCasterTest.php</span>:<span class=sf-dump-num>28</span>\n     &hellip;%d\n  </samp>}\n</samp>}\n</bar>\nEODUMP;\n\n        $this->assertStringMatchesFormat($expectedDump, $dump);\n    }\n\n    /**\n     * @requires function Twig\\Template::getSourceContext\n     */\n    public function testFrameWithTwig()\n    {\n        require_once \\dirname(__DIR__).'/Fixtures/Twig.php';\n\n        $f = [\n            new FrameStub([\n                'file' => \\dirname(__DIR__).'/Fixtures/Twig.php',\n                'line' => 20,\n                'class' => '__TwigTemplate_VarDumperFixture_u75a09',\n            ]),\n            new FrameStub([\n                'file' => \\dirname(__DIR__).'/Fixtures/Twig.php',\n                'line' => 21,\n                'class' => '__TwigTemplate_VarDumperFixture_u75a09',\n                'object' => new \\__TwigTemplate_VarDumperFixture_u75a09(null, __FILE__),\n            ]),\n        ];\n\n        $expectedDump = <<<'EODUMP'\narray:2 [\n  0 => {\n    class: \"__TwigTemplate_VarDumperFixture_u75a09\"\n    src: {\n      %sTwig.php:1 {\n        › \n        › foo bar\n        ›   twig source\n      }\n    }\n  }\n  1 => {\n    class: \"__TwigTemplate_VarDumperFixture_u75a09\"\n    object: __TwigTemplate_VarDumperFixture_u75a09 {\n    %A\n    }\n    src: {\n      %sExceptionCasterTest.php:2 {\n        › foo bar\n        ›   twig source\n        › \n      }\n    }\n  }\n]\n\nEODUMP;\n\n        $this->assertDumpMatchesFormat($expectedDump, $f);\n    }\n\n    public function testExcludeVerbosity()\n    {\n        $e = $this->getTestException('foo');\n\n        $expectedDump = <<<'EODUMP'\nException {\n  #message: \"foo\"\n  #code: 0\n  #file: \"%sExceptionCasterTest.php\"\n  #line: 28\n}\nEODUMP;\n\n        $this->assertDumpMatchesFormat($expectedDump, $e, Caster::EXCLUDE_VERBOSE);\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Tests/Caster/PdoCasterTest.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Tests\\Caster;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Symfony\\Component\\VarDumper\\Caster\\PdoCaster;\nuse Symfony\\Component\\VarDumper\\Cloner\\Stub;\nuse Symfony\\Component\\VarDumper\\Test\\VarDumperTestTrait;\n\n/**\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass PdoCasterTest extends TestCase\n{\n    use VarDumperTestTrait;\n\n    /**\n     * @requires extension pdo_sqlite\n     */\n    public function testCastPdo()\n    {\n        $pdo = new \\PDO(\'sqlite::memory:\');\n        $pdo->setAttribute(\\PDO::ATTR_STATEMENT_CLASS, [\'PDOStatement\', [$pdo]]);\n        $pdo->setAttribute(\\PDO::ATTR_ERRMODE, \\PDO::ERRMODE_EXCEPTION);\n\n        $cast = PdoCaster::castPdo($pdo, [], new Stub(), false);\n\n        $this->assertInstanceOf(\'Symfony\\Component\\VarDumper\\Caster\\EnumStub\', $cast["\\0~\\0attributes"]);\n\n        $attr = $cast["\\0~\\0attributes"] = $cast["\\0~\\0attributes"]->value;\n        $this->assertInstanceOf(\'Symfony\\Component\\VarDumper\\Caster\\ConstStub\', $attr[\'CASE\']);\n        $this->assertSame(\'NATURAL\', $attr[\'CASE\']->class);\n        $this->assertSame(\'BOTH\', $attr[\'DEFAULT_FETCH_MODE\']->class);\n\n        $xDump = <<<\'EODUMP\'\narray:2 [\n  "\\x00~\\x00inTransaction" => false\n  "\\x00~\\x00attributes" => array:9 [\n    "CASE" => NATURAL\n    "ERRMODE" => EXCEPTION\n    "PERSISTENT" => false\n    "DRIVER_NAME" => "sqlite"\n    "ORACLE_NULLS" => NATURAL\n    "CLIENT_VERSION" => "%s"\n    "SERVER_VERSION" => "%s"\n    "STATEMENT_CLASS" => array:%d [\n      0 => "PDOStatement"%A\n    ]\n    "DEFAULT_FETCH_MODE" => BOTH\n  ]\n]\nEODUMP;\n\n        $this->assertDumpMatchesFormat($xDump, $cast);\n    }\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Tests/Caster/RedisCasterTest.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Tests\\Caster;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Symfony\\Component\\VarDumper\\Test\\VarDumperTestTrait;\n\n/**\n * @author Nicolas Grekas <p@tchwork.com>\n * @requires extension redis\n */\nclass RedisCasterTest extends TestCase\n{\n    use VarDumperTestTrait;\n\n    public function testNotConnected()\n    {\n        $redis = new \\Redis();\n\n        if (\\defined('HHVM_VERSION_ID')) {\n            $xCast = <<<'EODUMP'\nRedis {\n  #host: \"\"\n%A\n}\nEODUMP;\n        } else {\n            $xCast = <<<'EODUMP'\nRedis {\n  isConnected: false\n}\nEODUMP;\n        }\n\n        $this->assertDumpMatchesFormat($xCast, $redis);\n    }\n\n    public function testConnected()\n    {\n        $redis = new \\Redis();\n        if (!@$redis->connect('127.0.0.1')) {\n            $e = error_get_last();\n            self::markTestSkipped($e['message']);\n        }\n\n        if (\\defined('HHVM_VERSION_ID')) {\n            $xCast = <<<'EODUMP'\nRedis {\n  #host: \"127.0.0.1\"\n%A\n}\nEODUMP;\n        } else {\n            $xCast = <<<'EODUMP'\nRedis {%A\n  isConnected: true\n  host: \"127.0.0.1\"\n  port: 6379\n  auth: null\n  dbNum: 0\n  timeout: 0.0\n  persistentId: null\n  options: {\n    READ_TIMEOUT: 0.0\n    SERIALIZER: NONE\n    PREFIX: null\n    SCAN: NORETRY\n  }\n}\nEODUMP;\n        }\n\n        $this->assertDumpMatchesFormat($xCast, $redis);\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Tests/Caster/ReflectionCasterTest.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Tests\\Caster;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Symfony\\Component\\VarDumper\\Caster\\Caster;\nuse Symfony\\Component\\VarDumper\\Test\\VarDumperTestTrait;\nuse Symfony\\Component\\VarDumper\\Tests\\Fixtures\\GeneratorDemo;\nuse Symfony\\Component\\VarDumper\\Tests\\Fixtures\\NotLoadableClass;\n\n/**\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass ReflectionCasterTest extends TestCase\n{\n    use VarDumperTestTrait;\n\n    public function testReflectionCaster()\n    {\n        $var = new \\ReflectionClass(\'ReflectionClass\');\n\n        $this->assertDumpMatchesFormat(\n            <<<\'EOTXT\'\nReflectionClass {\n  +name: "ReflectionClass"\n%Aimplements: array:%d [\n    0 => "Reflector"\n%A]\n  constants: array:3 [\n    "IS_IMPLICIT_ABSTRACT" => 16\n    "IS_EXPLICIT_ABSTRACT" => %d\n    "IS_FINAL" => %d\n  ]\n  properties: array:%d [\n    "name" => ReflectionProperty {\n%A    +name: "name"\n      +class: "ReflectionClass"\n%A    modifiers: "public"\n    }\n%A]\n  methods: array:%d [\n%A\n    "__construct" => ReflectionMethod {\n      +name: "__construct"\n      +class: "ReflectionClass"\n%A    parameters: {\n        $%s: ReflectionParameter {\n%A         position: 0\n%A\n}\nEOTXT\n            , $var\n        );\n    }\n\n    public function testClosureCaster()\n    {\n        $a = $b = 123;\n        $var = function ($x) use ($a, &$b) {};\n\n        $this->assertDumpMatchesFormat(\n            <<<EOTXT\nClosure {\n%Aparameters: {\n    \\$x: {}\n  }\n  use: {\n    \\$a: 123\n    \\$b: & 123\n  }\n  file: "%sReflectionCasterTest.php"\n  line: "68 to 68"\n}\nEOTXT\n            , $var\n        );\n    }\n\n    public function testFromCallableClosureCaster()\n    {\n        if (\\defined(\'HHVM_VERSION_ID\')) {\n            $this->markTestSkipped(\'Not for HHVM.\');\n        }\n        $var = [\n            (new \\ReflectionMethod($this, __FUNCTION__))->getClosure($this),\n            (new \\ReflectionMethod(__CLASS__, \'tearDownAfterClass\'))->getClosure(),\n        ];\n\n        $this->assertDumpMatchesFormat(\n            <<<EOTXT\narray:2 [\n  0 => Symfony\\Component\\VarDumper\\Tests\\Caster\\ReflectionCasterTest::testFromCallableClosureCaster {\n    this: Symfony\\Component\\VarDumper\\Tests\\Caster\\ReflectionCasterTest { …}\n    file: "%sReflectionCasterTest.php"\n    line: "%d to %d"\n  }\n  1 => %sTestCase::tearDownAfterClass {\n    file: "%sTestCase.php"\n    line: "%d to %d"\n  }\n]\nEOTXT\n            , $var\n        );\n    }\n\n    public function testClosureCasterExcludingVerbosity()\n    {\n        $var = function () {};\n\n        $expectedDump = <<<EOTXT\nClosure {\n  class: "Symfony\\Component\\VarDumper\\Tests\\Caster\\ReflectionCasterTest"\n  this: Symfony\\Component\\VarDumper\\Tests\\Caster\\ReflectionCasterTest { …}\n}\nEOTXT;\n\n        $this->assertDumpEquals($expectedDump, $var, Caster::EXCLUDE_VERBOSE);\n    }\n\n    public function testReflectionParameter()\n    {\n        $var = new \\ReflectionParameter(reflectionParameterFixture::class, 0);\n\n        $this->assertDumpMatchesFormat(\n            <<<\'EOTXT\'\nReflectionParameter {\n  +name: "arg1"\n  position: 0\n  typeHint: "Symfony\\Component\\VarDumper\\Tests\\Fixtures\\NotLoadableClass"\n  default: null\n}\nEOTXT\n            , $var\n        );\n    }\n\n    /**\n     * @requires PHP 7.0\n     */\n    public function testReflectionParameterScalar()\n    {\n        $f = eval(\'return function (int $a) {};\');\n        $var = new \\ReflectionParameter($f, 0);\n\n        $this->assertDumpMatchesFormat(\n            <<<\'EOTXT\'\nReflectionParameter {\n  +name: "a"\n  position: 0\n  typeHint: "int"\n}\nEOTXT\n            , $var\n        );\n    }\n\n    /**\n     * @requires PHP 7.0\n     */\n    public function testReturnType()\n    {\n        $f = eval(\'return function ():int {};\');\n        $line = __LINE__ - 1;\n\n        $this->assertDumpMatchesFormat(\n            <<<EOTXT\nClosure {\n  returnType: "int"\n  class: "Symfony\\Component\\VarDumper\\Tests\\Caster\\ReflectionCasterTest"\n  this: Symfony\\Component\\VarDumper\\Tests\\Caster\\ReflectionCasterTest { …}\n  file: "%sReflectionCasterTest.php($line) : eval()\'d code"\n  line: "1 to 1"\n}\nEOTXT\n            , $f\n        );\n    }\n\n    /**\n     * @requires PHP 7.0\n     */\n    public function testGenerator()\n    {\n        if (\\extension_loaded(\'xdebug\')) {\n            $this->markTestSkipped(\'xdebug is active\');\n        }\n\n        $generator = new GeneratorDemo();\n        $generator = $generator->baz();\n\n        $expectedDump = <<<\'EODUMP\'\nGenerator {\n  this: Symfony\\Component\\VarDumper\\Tests\\Fixtures\\GeneratorDemo { …}\n  executing: {\n    Symfony\\Component\\VarDumper\\Tests\\Fixtures\\GeneratorDemo->baz() {\n      %sGeneratorDemo.php:14 {\n        › {\n        ›     yield from bar();\n        › }\n      }\n    }\n  }\n  closed: false\n}\nEODUMP;\n\n        $this->assertDumpMatchesFormat($expectedDump, $generator);\n\n        foreach ($generator as $v) {\n            break;\n        }\n\n        $expectedDump = <<<\'EODUMP\'\narray:2 [\n  0 => ReflectionGenerator {\n    this: Symfony\\Component\\VarDumper\\Tests\\Fixtures\\GeneratorDemo { …}\n    trace: {\n      %s%eTests%eFixtures%eGeneratorDemo.php:9 {\n        › {\n        ›     yield 1;\n        › }\n      }\n      %s%eTests%eFixtures%eGeneratorDemo.php:20 { …}\n      %s%eTests%eFixtures%eGeneratorDemo.php:14 { …}\n    }\n    closed: false\n  }\n  1 => Generator {\n    executing: {\n      Symfony\\Component\\VarDumper\\Tests\\Fixtures\\GeneratorDemo::foo() {\n        %sGeneratorDemo.php:10 {\n          ›     yield 1;\n          › }\n          › \n        }\n      }\n    }\n    closed: false\n  }\n]\nEODUMP;\n\n        $r = new \\ReflectionGenerator($generator);\n        $this->assertDumpMatchesFormat($expectedDump, [$r, $r->getExecutingGenerator()]);\n\n        foreach ($generator as $v) {\n        }\n\n        $expectedDump = <<<\'EODUMP\'\nGenerator {\n  closed: true\n}\nEODUMP;\n        $this->assertDumpMatchesFormat($expectedDump, $generator);\n    }\n}\n\nfunction reflectionParameterFixture(NotLoadableClass $arg1 = null, $arg2)\n{\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Tests/Caster/SplCasterTest.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Tests\\Caster;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Symfony\\Component\\VarDumper\\Test\\VarDumperTestTrait;\n\n/**\n * @author Grégoire Pineau <lyrixx@lyrixx.info>\n */\nclass SplCasterTest extends TestCase\n{\n    use VarDumperTestTrait;\n\n    public function getCastFileInfoTests()\n    {\n        return [\n            [__FILE__, <<<\'EOTXT\'\nSplFileInfo {\n%Apath: "%sCaster"\n  filename: "SplCasterTest.php"\n  basename: "SplCasterTest.php"\n  pathname: "%sSplCasterTest.php"\n  extension: "php"\n  realPath: "%sSplCasterTest.php"\n  aTime: %s-%s-%d %d:%d:%d\n  mTime: %s-%s-%d %d:%d:%d\n  cTime: %s-%s-%d %d:%d:%d\n  inode: %i\n  size: %d\n  perms: 0%d\n  owner: %d\n  group: %d\n  type: "file"\n  writable: true\n  readable: true\n  executable: false\n  file: true\n  dir: false\n  link: false\n%A}\nEOTXT\n            ],\n            [\'https://example.com/about\', <<<\'EOTXT\'\nSplFileInfo {\n%Apath: "https://example.com"\n  filename: "about"\n  basename: "about"\n  pathname: "https://example.com/about"\n  extension: ""\n  realPath: false\n%A}\nEOTXT\n            ],\n        ];\n    }\n\n    /** @dataProvider getCastFileInfoTests */\n    public function testCastFileInfo($file, $dump)\n    {\n        $this->assertDumpMatchesFormat($dump, new \\SplFileInfo($file));\n    }\n\n    public function testCastFileObject()\n    {\n        $var = new \\SplFileObject(__FILE__);\n        $var->setFlags(\\SplFileObject::DROP_NEW_LINE | \\SplFileObject::SKIP_EMPTY);\n        $dump = <<<\'EOTXT\'\nSplFileObject {\n%Apath: "%sCaster"\n  filename: "SplCasterTest.php"\n  basename: "SplCasterTest.php"\n  pathname: "%sSplCasterTest.php"\n  extension: "php"\n  realPath: "%sSplCasterTest.php"\n  aTime: %s-%s-%d %d:%d:%d\n  mTime: %s-%s-%d %d:%d:%d\n  cTime: %s-%s-%d %d:%d:%d\n  inode: %i\n  size: %d\n  perms: 0%d\n  owner: %d\n  group: %d\n  type: "file"\n  writable: true\n  readable: true\n  executable: false\n  file: true\n  dir: false\n  link: false\n%AcsvControl: array:%d [\n    0 => ","\n    1 => """\n%A]\n  flags: DROP_NEW_LINE|SKIP_EMPTY\n  maxLineLen: 0\n  fstat: array:26 [\n    "dev" => %d\n    "ino" => %i\n    "nlink" => %d\n    "rdev" => 0\n    "blksize" => %i\n    "blocks" => %i\n     …20\n  ]\n  eof: false\n  key: 0\n}\nEOTXT;\n        $this->assertDumpMatchesFormat($dump, $var);\n    }\n\n    /**\n     * @dataProvider provideCastSplDoublyLinkedList\n     */\n    public function testCastSplDoublyLinkedList($modeValue, $modeDump)\n    {\n        $var = new \\SplDoublyLinkedList();\n        $var->setIteratorMode($modeValue);\n        $dump = <<<EOTXT\nSplDoublyLinkedList {\n%Amode: $modeDump\n  dllist: []\n}\nEOTXT;\n        $this->assertDumpMatchesFormat($dump, $var);\n    }\n\n    public function provideCastSplDoublyLinkedList()\n    {\n        return [\n            [\\SplDoublyLinkedList::IT_MODE_FIFO, \'IT_MODE_FIFO | IT_MODE_KEEP\'],\n            [\\SplDoublyLinkedList::IT_MODE_LIFO, \'IT_MODE_LIFO | IT_MODE_KEEP\'],\n            [\\SplDoublyLinkedList::IT_MODE_FIFO | \\SplDoublyLinkedList::IT_MODE_DELETE, \'IT_MODE_FIFO | IT_MODE_DELETE\'],\n            [\\SplDoublyLinkedList::IT_MODE_LIFO | \\SplDoublyLinkedList::IT_MODE_DELETE, \'IT_MODE_LIFO | IT_MODE_DELETE\'],\n        ];\n    }\n\n    public function testCastObjectStorageIsntModified()\n    {\n        $var = new \\SplObjectStorage();\n        $var->attach(new \\stdClass());\n        $var->rewind();\n        $current = $var->current();\n\n        $this->assertDumpMatchesFormat(\'%A\', $var);\n        $this->assertSame($current, $var->current());\n    }\n\n    public function testCastObjectStorageDumpsInfo()\n    {\n        $var = new \\SplObjectStorage();\n        $var->attach(new \\stdClass(), new \\DateTime());\n\n        $this->assertDumpMatchesFormat(\'%ADateTime%A\', $var);\n    }\n\n    public function testCastArrayObject()\n    {\n        if (\\defined(\'HHVM_VERSION\')) {\n            $this->markTestSkipped(\'HHVM as different internal details.\');\n        }\n        $var = new \\ArrayObject([123]);\n        $var->foo = 234;\n\n        $expected = <<<EOTXT\nArrayObject {\n  +"foo": 234\n  -storage: array:1 [\n    0 => 123\n  ]\n  flag::STD_PROP_LIST: false\n  flag::ARRAY_AS_PROPS: false\n  iteratorClass: "ArrayIterator"\n}\nEOTXT;\n        if (\\PHP_VERSION_ID < 70400) {\n            $expected = str_replace(\'-storage:\', \'storage:\', $expected);\n        }\n        $this->assertDumpEquals($expected, $var);\n    }\n\n    public function testArrayIterator()\n    {\n        if (\\defined(\'HHVM_VERSION\')) {\n            $this->markTestSkipped(\'HHVM as different internal details.\');\n        }\n        $var = new MyArrayIterator([234]);\n\n        $expected = <<<EOTXT\nSymfony\\Component\\VarDumper\\Tests\\Caster\\MyArrayIterator {\n  -foo: 123\n  -storage: array:1 [\n    0 => 234\n  ]\n  flag::STD_PROP_LIST: false\n  flag::ARRAY_AS_PROPS: false\n}\nEOTXT;\n        if (\\PHP_VERSION_ID < 70400) {\n            $expected = str_replace(\'-storage:\', \'storage:\', $expected);\n        }\n        $this->assertDumpEquals($expected, $var);\n    }\n\n    public function testBadSplFileInfo()\n    {\n        $var = new BadSplFileInfo();\n\n        $expected = <<<EOTXT\nSymfony\\Component\\VarDumper\\Tests\\Caster\\BadSplFileInfo {\n  ⚠: "The parent constructor was not called: the object is in an invalid state"\n}\nEOTXT;\n        $this->assertDumpEquals($expected, $var);\n    }\n}\n\nclass MyArrayIterator extends \\ArrayIterator\n{\n    private $foo = 123;\n}\n\nclass BadSplFileInfo extends \\SplFileInfo\n{\n    public function __construct()\n    {\n    }\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Tests/Caster/StubCasterTest.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Tests\\Caster;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Symfony\\Component\\VarDumper\\Caster\\ArgsStub;\nuse Symfony\\Component\\VarDumper\\Caster\\ClassStub;\nuse Symfony\\Component\\VarDumper\\Caster\\LinkStub;\nuse Symfony\\Component\\VarDumper\\Cloner\\VarCloner;\nuse Symfony\\Component\\VarDumper\\Dumper\\HtmlDumper;\nuse Symfony\\Component\\VarDumper\\Test\\VarDumperTestTrait;\nuse Symfony\\Component\\VarDumper\\Tests\\Fixtures\\FooInterface;\n\nclass StubCasterTest extends TestCase\n{\n    use VarDumperTestTrait;\n\n    public function testArgsStubWithDefaults($foo = 234, $bar = 456)\n    {\n        $args = [new ArgsStub([123], __FUNCTION__, __CLASS__)];\n\n        $expectedDump = <<<'EODUMP'\narray:1 [\n  0 => {\n    $foo: 123\n  }\n]\nEODUMP;\n\n        $this->assertDumpMatchesFormat($expectedDump, $args);\n    }\n\n    public function testArgsStubWithExtraArgs($foo = 234)\n    {\n        $args = [new ArgsStub([123, 456], __FUNCTION__, __CLASS__)];\n\n        $expectedDump = <<<'EODUMP'\narray:1 [\n  0 => {\n    $foo: 123\n    ...: {\n      456\n    }\n  }\n]\nEODUMP;\n\n        $this->assertDumpMatchesFormat($expectedDump, $args);\n    }\n\n    public function testArgsStubNoParamWithExtraArgs()\n    {\n        $args = [new ArgsStub([123], __FUNCTION__, __CLASS__)];\n\n        $expectedDump = <<<'EODUMP'\narray:1 [\n  0 => {\n    123\n  }\n]\nEODUMP;\n\n        $this->assertDumpMatchesFormat($expectedDump, $args);\n    }\n\n    public function testArgsStubWithClosure()\n    {\n        $args = [new ArgsStub([123], '{closure}', null)];\n\n        $expectedDump = <<<'EODUMP'\narray:1 [\n  0 => {\n    123\n  }\n]\nEODUMP;\n\n        $this->assertDumpMatchesFormat($expectedDump, $args);\n    }\n\n    public function testLinkStub()\n    {\n        $var = [new LinkStub(__CLASS__, 0, __FILE__)];\n\n        $cloner = new VarCloner();\n        $dumper = new HtmlDumper();\n        $dumper->setDumpHeader('<foo></foo>');\n        $dumper->setDumpBoundaries('<bar>', '</bar>');\n        $dumper->setDisplayOptions(['fileLinkFormat' => '%f:%l']);\n        $dump = $dumper->dump($cloner->cloneVar($var), true);\n\n        $expectedDump = <<<'EODUMP'\n<foo></foo><bar><span class=sf-dump-note>array:1</span> [<samp>\n  <span class=sf-dump-index>0</span> => \"<a href=\"%sStubCasterTest.php:0\" rel=\"noopener noreferrer\"><span class=sf-dump-str title=\"55 characters\">Symfony\\Component\\VarDumper\\Tests\\Caster\\StubCasterTest</span></a>\"\n</samp>]\n</bar>\nEODUMP;\n\n        $this->assertStringMatchesFormat($expectedDump, $dump);\n    }\n\n    public function testLinkStubWithNoFileLink()\n    {\n        $var = [new LinkStub('example.com', 0, 'http://example.com')];\n\n        $cloner = new VarCloner();\n        $dumper = new HtmlDumper();\n        $dumper->setDumpHeader('<foo></foo>');\n        $dumper->setDumpBoundaries('<bar>', '</bar>');\n        $dumper->setDisplayOptions(['fileLinkFormat' => '%f:%l']);\n        $dump = $dumper->dump($cloner->cloneVar($var), true);\n\n        $expectedDump = <<<'EODUMP'\n<foo></foo><bar><span class=sf-dump-note>array:1</span> [<samp>\n  <span class=sf-dump-index>0</span> => \"<a href=\"http://example.com\" target=\"_blank\" rel=\"noopener noreferrer\"><span class=sf-dump-str title=\"11 characters\">example.com</span></a>\"\n</samp>]\n</bar>\nEODUMP;\n\n        $this->assertStringMatchesFormat($expectedDump, $dump);\n    }\n\n    public function testClassStub()\n    {\n        $var = [new ClassStub('hello', [FooInterface::class, 'foo'])];\n\n        $cloner = new VarCloner();\n        $dumper = new HtmlDumper();\n        $dumper->setDumpHeader('<foo></foo>');\n        $dumper->setDumpBoundaries('<bar>', '</bar>');\n        $dump = $dumper->dump($cloner->cloneVar($var), true, ['fileLinkFormat' => '%f:%l']);\n\n        $expectedDump = <<<'EODUMP'\n<foo></foo><bar><span class=sf-dump-note>array:1</span> [<samp>\n  <span class=sf-dump-index>0</span> => \"<a href=\"%sFooInterface.php:10\" rel=\"noopener noreferrer\"><span class=sf-dump-str title=\"5 characters\">hello</span></a>\"\n</samp>]\n</bar>\nEODUMP;\n\n        $this->assertStringMatchesFormat($expectedDump, $dump);\n    }\n\n    public function testClassStubWithNotExistingClass()\n    {\n        $var = [new ClassStub(NotExisting::class)];\n\n        $cloner = new VarCloner();\n        $dumper = new HtmlDumper();\n        $dumper->setDumpHeader('<foo></foo>');\n        $dumper->setDumpBoundaries('<bar>', '</bar>');\n        $dump = $dumper->dump($cloner->cloneVar($var), true);\n\n        $expectedDump = <<<'EODUMP'\n<foo></foo><bar><span class=sf-dump-note>array:1</span> [<samp>\n  <span class=sf-dump-index>0</span> => \"<span class=sf-dump-str title=\"Symfony\\Component\\VarDumper\\Tests\\Caster\\NotExisting\n52 characters\"><span class=\"sf-dump-ellipsis sf-dump-ellipsis-class\">Symfony\\Component\\VarDumper\\Tests\\Caster</span><span class=sf-dump-ellipsis>\\</span>NotExisting</span>\"\n</samp>]\n</bar>\nEODUMP;\n\n        $this->assertStringMatchesFormat($expectedDump, $dump);\n    }\n\n    public function testClassStubWithNotExistingMethod()\n    {\n        $var = [new ClassStub('hello', [FooInterface::class, 'missing'])];\n\n        $cloner = new VarCloner();\n        $dumper = new HtmlDumper();\n        $dumper->setDumpHeader('<foo></foo>');\n        $dumper->setDumpBoundaries('<bar>', '</bar>');\n        $dump = $dumper->dump($cloner->cloneVar($var), true, ['fileLinkFormat' => '%f:%l']);\n\n        $expectedDump = <<<'EODUMP'\n<foo></foo><bar><span class=sf-dump-note>array:1</span> [<samp>\n  <span class=sf-dump-index>0</span> => \"<a href=\"%sFooInterface.php:5\" rel=\"noopener noreferrer\"><span class=sf-dump-str title=\"5 characters\">hello</span></a>\"\n</samp>]\n</bar>\nEODUMP;\n\n        $this->assertStringMatchesFormat($expectedDump, $dump);\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Tests/Caster/XmlReaderCasterTest.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Tests\\Caster;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Symfony\\Component\\VarDumper\\Test\\VarDumperTestTrait;\n\n/**\n * @author Baptiste Clavié <clavie.b@gmail.com>\n */\nclass XmlReaderCasterTest extends TestCase\n{\n    use VarDumperTestTrait;\n\n    /** @var \\XmlReader */\n    private $reader;\n\n    protected function setUp()\n    {\n        $this->reader = new \\XmlReader();\n        $this->reader->open(__DIR__.\'/../Fixtures/xml_reader.xml\');\n    }\n\n    protected function tearDown()\n    {\n        $this->reader->close();\n    }\n\n    public function testParserProperty()\n    {\n        $this->reader->setParserProperty(\\XMLReader::SUBST_ENTITIES, true);\n\n        $expectedDump = <<<\'EODUMP\'\nXMLReader {\n  +nodeType: NONE\n  parserProperties: {\n    SUBST_ENTITIES: true\n     …3\n  }\n   …12\n}\nEODUMP;\n\n        $this->assertDumpMatchesFormat($expectedDump, $this->reader);\n    }\n\n    /**\n     * @dataProvider provideNodes\n     */\n    public function testNodes($seek, $expectedDump)\n    {\n        while ($seek--) {\n            $this->reader->read();\n        }\n        $this->assertDumpMatchesFormat($expectedDump, $this->reader);\n    }\n\n    public function provideNodes()\n    {\n        return [\n            [0, <<<\'EODUMP\'\nXMLReader {\n  +nodeType: NONE\n   …13\n}\nEODUMP\n            ],\n            [1, <<<\'EODUMP\'\nXMLReader {\n  +localName: "foo"\n  +nodeType: ELEMENT\n  +baseURI: "%sxml_reader.xml"\n   …11\n}\nEODUMP\n            ],\n            [2, <<<\'EODUMP\'\nXMLReader {\n  +localName: "#text"\n  +nodeType: SIGNIFICANT_WHITESPACE\n  +depth: 1\n  +value: """\n    \\n\n        \n    """\n  +baseURI: "%sxml_reader.xml"\n   …9\n}\nEODUMP\n            ],\n            [3, <<<\'EODUMP\'\nXMLReader {\n  +localName: "bar"\n  +nodeType: ELEMENT\n  +depth: 1\n  +baseURI: "%sxml_reader.xml"\n   …10\n}\nEODUMP\n            ],\n            [4, <<<\'EODUMP\'\nXMLReader {\n  +localName: "bar"\n  +nodeType: END_ELEMENT\n  +depth: 1\n  +baseURI: "%sxml_reader.xml"\n   …10\n}\nEODUMP\n            ],\n            [6, <<<\'EODUMP\'\nXMLReader {\n  +localName: "bar"\n  +nodeType: ELEMENT\n  +depth: 1\n  +isEmptyElement: true\n  +baseURI: "%sxml_reader.xml"\n   …9\n}\nEODUMP\n            ],\n            [9, <<<\'EODUMP\'\nXMLReader {\n  +localName: "#text"\n  +nodeType: TEXT\n  +depth: 2\n  +value: "With text"\n  +baseURI: "%sxml_reader.xml"\n   …9\n}\nEODUMP\n            ],\n            [12, <<<\'EODUMP\'\nXMLReader {\n  +localName: "bar"\n  +nodeType: ELEMENT\n  +depth: 1\n  +attributeCount: 2\n  +baseURI: "%sxml_reader.xml"\n   …9\n}\nEODUMP\n            ],\n            [13, <<<\'EODUMP\'\nXMLReader {\n  +localName: "bar"\n  +nodeType: END_ELEMENT\n  +depth: 1\n  +baseURI: "%sxml_reader.xml"\n   …10\n}\nEODUMP\n            ],\n            [15, <<<\'EODUMP\'\nXMLReader {\n  +localName: "bar"\n  +nodeType: ELEMENT\n  +depth: 1\n  +attributeCount: 1\n  +baseURI: "%sxml_reader.xml"\n   …9\n}\nEODUMP\n            ],\n            [16, <<<\'EODUMP\'\nXMLReader {\n  +localName: "#text"\n  +nodeType: SIGNIFICANT_WHITESPACE\n  +depth: 2\n  +value: """\n    \\n\n            \n    """\n  +baseURI: "%sxml_reader.xml"\n   …9\n}\nEODUMP\n            ],\n            [17, <<<\'EODUMP\'\nXMLReader {\n  +localName: "baz"\n  +prefix: "baz"\n  +nodeType: ELEMENT\n  +depth: 2\n  +namespaceURI: "http://symfony.com"\n  +baseURI: "%sxml_reader.xml"\n   …8\n}\nEODUMP\n            ],\n            [18, <<<\'EODUMP\'\nXMLReader {\n  +localName: "baz"\n  +prefix: "baz"\n  +nodeType: END_ELEMENT\n  +depth: 2\n  +namespaceURI: "http://symfony.com"\n  +baseURI: "%sxml_reader.xml"\n   …8\n}\nEODUMP\n            ],\n            [19, <<<\'EODUMP\'\nXMLReader {\n  +localName: "#text"\n  +nodeType: SIGNIFICANT_WHITESPACE\n  +depth: 2\n  +value: """\n    \\n\n        \n    """\n  +baseURI: "%sxml_reader.xml"\n   …9\n}\nEODUMP\n            ],\n            [21, <<<\'EODUMP\'\nXMLReader {\n  +localName: "#text"\n  +nodeType: SIGNIFICANT_WHITESPACE\n  +depth: 1\n  +value: "\\n"\n  +baseURI: "%sxml_reader.xml"\n   …9\n}\nEODUMP\n            ],\n            [22, <<<\'EODUMP\'\nXMLReader {\n  +localName: "foo"\n  +nodeType: END_ELEMENT\n  +baseURI: "%sxml_reader.xml"\n   …11\n}\nEODUMP\n            ],\n        ];\n    }\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Tests/Cloner/DataTest.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Tests\\Cloner;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Symfony\\Component\\VarDumper\\Caster\\Caster;\nuse Symfony\\Component\\VarDumper\\Caster\\ClassStub;\nuse Symfony\\Component\\VarDumper\\Cloner\\Data;\nuse Symfony\\Component\\VarDumper\\Cloner\\VarCloner;\n\nclass DataTest extends TestCase\n{\n    public function testBasicData()\n    {\n        $values = [1 => 123, 4.5, 'abc', null, false];\n        $data = $this->cloneVar($values);\n        $clonedValues = [];\n\n        $this->assertInstanceOf(Data::class, $data);\n        $this->assertCount(\\count($values), $data);\n        $this->assertFalse(isset($data->{0}));\n        $this->assertFalse(isset($data[0]));\n\n        foreach ($data as $k => $v) {\n            $this->assertTrue(isset($data->{$k}));\n            $this->assertTrue(isset($data[$k]));\n            $this->assertSame(\\gettype($values[$k]), $data->seek($k)->getType());\n            $this->assertSame($values[$k], $data->seek($k)->getValue());\n            $this->assertSame($values[$k], $data->{$k});\n            $this->assertSame($values[$k], $data[$k]);\n            $this->assertSame((string) $values[$k], (string) $data->seek($k));\n\n            $clonedValues[$k] = $v->getValue();\n        }\n\n        $this->assertSame($values, $clonedValues);\n    }\n\n    public function testObject()\n    {\n        $data = $this->cloneVar(new \\Exception('foo'));\n\n        $this->assertSame('Exception', $data->getType());\n\n        $this->assertSame('foo', $data->message);\n        $this->assertSame('foo', $data->{Caster::PREFIX_PROTECTED.'message'});\n\n        $this->assertSame('foo', $data['message']);\n        $this->assertSame('foo', $data[Caster::PREFIX_PROTECTED.'message']);\n\n        $this->assertStringMatchesFormat('Exception (count=%d)', (string) $data);\n    }\n\n    public function testArray()\n    {\n        $values = [[], [123]];\n        $data = $this->cloneVar($values);\n\n        $this->assertSame($values, $data->getValue(true));\n\n        $children = $data->getValue();\n\n        $this->assertIsArray($children);\n\n        $this->assertInstanceOf(Data::class, $children[0]);\n        $this->assertInstanceOf(Data::class, $children[1]);\n\n        $this->assertEquals($children[0], $data[0]);\n        $this->assertEquals($children[1], $data[1]);\n\n        $this->assertSame($values[0], $children[0]->getValue(true));\n        $this->assertSame($values[1], $children[1]->getValue(true));\n    }\n\n    public function testStub()\n    {\n        $data = $this->cloneVar([new ClassStub('stdClass')]);\n        $data = $data[0];\n\n        $this->assertSame('string', $data->getType());\n        $this->assertSame('stdClass', $data->getValue());\n        $this->assertSame('stdClass', (string) $data);\n    }\n\n    public function testHardRefs()\n    {\n        $values = [[]];\n        $values[1] = &$values[0];\n        $values[2][0] = &$values[2];\n\n        $data = $this->cloneVar($values);\n\n        $this->assertSame([], $data[0]->getValue());\n        $this->assertSame([], $data[1]->getValue());\n        $this->assertEquals([$data[2]->getValue()], $data[2]->getValue(true));\n\n        $this->assertSame('array (count=3)', (string) $data);\n    }\n\n    private function cloneVar($value)\n    {\n        $cloner = new VarCloner();\n\n        return $cloner->cloneVar($value);\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Tests/Cloner/VarClonerTest.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Tests\\Cloner;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Symfony\\Component\\VarDumper\\Cloner\\VarCloner;\nuse Symfony\\Component\\VarDumper\\Tests\\Fixtures\\Php74;\n\n/**\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass VarClonerTest extends TestCase\n{\n    public function testMaxIntBoundary()\n    {\n        $data = [\\PHP_INT_MAX => 123];\n\n        $cloner = new VarCloner();\n        $clone = $cloner->cloneVar($data);\n\n        $expected = <<<EOTXT\nSymfony\\Component\\VarDumper\\Cloner\\Data Object\n(\n    [data:Symfony\\Component\\VarDumper\\Cloner\\Data:private] => Array\n        (\n            [0] => Array\n                (\n                    [0] => Array\n                        (\n                            [1] => 1\n                        )\n\n                )\n\n            [1] => Array\n                (\n                    [%s] => 123\n                )\n\n        )\n\n    [position:Symfony\\Component\\VarDumper\\Cloner\\Data:private] => 0\n    [key:Symfony\\Component\\VarDumper\\Cloner\\Data:private] => 0\n    [maxDepth:Symfony\\Component\\VarDumper\\Cloner\\Data:private] => 20\n    [maxItemsPerDepth:Symfony\\Component\\VarDumper\\Cloner\\Data:private] => -1\n    [useRefHandles:Symfony\\Component\\VarDumper\\Cloner\\Data:private] => -1\n)\n\nEOTXT;\n        $this->assertSame(sprintf($expected, \\PHP_INT_MAX), print_r($clone, true));\n    }\n\n    public function testClone()\n    {\n        $json = json_decode(\'{"1":{"var":"val"},"2":{"var":"val"}}\');\n\n        $cloner = new VarCloner();\n        $clone = $cloner->cloneVar($json);\n\n        $expected = <<<EOTXT\nSymfony\\Component\\VarDumper\\Cloner\\Data Object\n(\n    [data:Symfony\\Component\\VarDumper\\Cloner\\Data:private] => Array\n        (\n            [0] => Array\n                (\n                    [0] => Symfony\\Component\\VarDumper\\Cloner\\Stub Object\n                        (\n                            [type] => 4\n                            [class] => stdClass\n                            [value] => \n                            [cut] => 0\n                            [handle] => %i\n                            [refCount] => 0\n                            [position] => 1\n                            [attr] => Array\n                                (\n                                )\n\n                        )\n\n                )\n\n            [1] => Array\n                (\n                    [\\000+\\0001] => Symfony\\Component\\VarDumper\\Cloner\\Stub Object\n                        (\n                            [type] => 4\n                            [class] => stdClass\n                            [value] => \n                            [cut] => 0\n                            [handle] => %i\n                            [refCount] => 0\n                            [position] => 2\n                            [attr] => Array\n                                (\n                                )\n\n                        )\n\n                    [\\000+\\0002] => Symfony\\Component\\VarDumper\\Cloner\\Stub Object\n                        (\n                            [type] => 4\n                            [class] => stdClass\n                            [value] => \n                            [cut] => 0\n                            [handle] => %i\n                            [refCount] => 0\n                            [position] => 3\n                            [attr] => Array\n                                (\n                                )\n\n                        )\n\n                )\n\n            [2] => Array\n                (\n                    [\\000+\\000var] => val\n                )\n\n            [3] => Array\n                (\n                    [\\000+\\000var] => val\n                )\n\n        )\n\n    [position:Symfony\\Component\\VarDumper\\Cloner\\Data:private] => 0\n    [key:Symfony\\Component\\VarDumper\\Cloner\\Data:private] => 0\n    [maxDepth:Symfony\\Component\\VarDumper\\Cloner\\Data:private] => 20\n    [maxItemsPerDepth:Symfony\\Component\\VarDumper\\Cloner\\Data:private] => -1\n    [useRefHandles:Symfony\\Component\\VarDumper\\Cloner\\Data:private] => -1\n)\n\nEOTXT;\n        $this->assertStringMatchesFormat($expected, print_r($clone, true));\n    }\n\n    public function testLimits()\n    {\n        // Level 0:\n        $data = [\n            // Level 1:\n            [\n                // Level 2:\n                [\n                    // Level 3:\n                    \'Level 3 Item 0\',\n                    \'Level 3 Item 1\',\n                    \'Level 3 Item 2\',\n                    \'Level 3 Item 3\',\n                ],\n                [\n                    999 => \'Level 3 Item 4\',\n                    \'Level 3 Item 5\',\n                    \'Level 3 Item 6\',\n                ],\n                [\n                    \'Level 3 Item 7\',\n                ],\n            ],\n            [\n                [\n                    \'Level 3 Item 8\',\n                ],\n                \'Level 2 Item 0\',\n            ],\n            [\n                \'Level 2 Item 1\',\n            ],\n            \'Level 1 Item 0\',\n            [\n                // Test setMaxString:\n                \'ABCDEFGHIJKLMNOPQRSTUVWXYZ\',\n                \'SHORT\',\n            ],\n        ];\n\n        $cloner = new VarCloner();\n        $cloner->setMinDepth(2);\n        $cloner->setMaxItems(5);\n        $cloner->setMaxString(20);\n        $clone = $cloner->cloneVar($data);\n\n        $expected = <<<EOTXT\nSymfony\\Component\\VarDumper\\Cloner\\Data Object\n(\n    [data:Symfony\\Component\\VarDumper\\Cloner\\Data:private] => Array\n        (\n            [0] => Array\n                (\n                    [0] => Array\n                        (\n                            [2] => 1\n                        )\n\n                )\n\n            [1] => Array\n                (\n                    [0] => Array\n                        (\n                            [2] => 2\n                        )\n\n                    [1] => Array\n                        (\n                            [2] => 3\n                        )\n\n                    [2] => Array\n                        (\n                            [2] => 4\n                        )\n\n                    [3] => Level 1 Item 0\n                    [4] => Array\n                        (\n                            [2] => 5\n                        )\n\n                )\n\n            [2] => Array\n                (\n                    [0] => Array\n                        (\n                            [2] => 6\n                        )\n\n                    [1] => Array\n                        (\n                            [0] => 2\n                            [1] => 7\n                        )\n\n                    [2] => Array\n                        (\n                            [0] => 1\n                            [2] => 0\n                        )\n\n                )\n\n            [3] => Array\n                (\n                    [0] => Array\n                        (\n                            [0] => 1\n                            [2] => 0\n                        )\n\n                    [1] => Level 2 Item 0\n                )\n\n            [4] => Array\n                (\n                    [0] => Level 2 Item 1\n                )\n\n            [5] => Array\n                (\n                    [0] => Symfony\\Component\\VarDumper\\Cloner\\Stub Object\n                        (\n                            [type] => 2\n                            [class] => 2\n                            [value] => ABCDEFGHIJKLMNOPQRST\n                            [cut] => 6\n                            [handle] => 0\n                            [refCount] => 0\n                            [position] => 0\n                            [attr] => Array\n                                (\n                                )\n\n                        )\n\n                    [1] => SHORT\n                )\n\n            [6] => Array\n                (\n                    [0] => Level 3 Item 0\n                    [1] => Level 3 Item 1\n                    [2] => Level 3 Item 2\n                    [3] => Level 3 Item 3\n                )\n\n            [7] => Array\n                (\n                    [999] => Level 3 Item 4\n                )\n\n        )\n\n    [position:Symfony\\Component\\VarDumper\\Cloner\\Data:private] => 0\n    [key:Symfony\\Component\\VarDumper\\Cloner\\Data:private] => 0\n    [maxDepth:Symfony\\Component\\VarDumper\\Cloner\\Data:private] => 20\n    [maxItemsPerDepth:Symfony\\Component\\VarDumper\\Cloner\\Data:private] => -1\n    [useRefHandles:Symfony\\Component\\VarDumper\\Cloner\\Data:private] => -1\n)\n\nEOTXT;\n        $this->assertStringMatchesFormat($expected, print_r($clone, true));\n    }\n\n    public function testJsonCast()\n    {\n        if (2 == ini_get(\'xdebug.overload_var_dump\')) {\n            $this->markTestSkipped(\'xdebug is active\');\n        }\n\n        $data = (array) json_decode(\'{"1":{}}\');\n\n        $cloner = new VarCloner();\n        $clone = $cloner->cloneVar($data);\n\n        $expected = <<<\'EOTXT\'\nobject(Symfony\\Component\\VarDumper\\Cloner\\Data)#%i (6) {\n  ["data":"Symfony\\Component\\VarDumper\\Cloner\\Data":private]=>\n  array(2) {\n    [0]=>\n    array(1) {\n      [0]=>\n      array(1) {\n        [1]=>\n        int(1)\n      }\n    }\n    [1]=>\n    array(1) {\n      ["1"]=>\n      object(Symfony\\Component\\VarDumper\\Cloner\\Stub)#%i (8) {\n        ["type"]=>\n        int(4)\n        ["class"]=>\n        string(8) "stdClass"\n        ["value"]=>\n        NULL\n        ["cut"]=>\n        int(0)\n        ["handle"]=>\n        int(%i)\n        ["refCount"]=>\n        int(0)\n        ["position"]=>\n        int(0)\n        ["attr"]=>\n        array(0) {\n        }\n      }\n    }\n  }\n  ["position":"Symfony\\Component\\VarDumper\\Cloner\\Data":private]=>\n  int(0)\n  ["key":"Symfony\\Component\\VarDumper\\Cloner\\Data":private]=>\n  int(0)\n  ["maxDepth":"Symfony\\Component\\VarDumper\\Cloner\\Data":private]=>\n  int(20)\n  ["maxItemsPerDepth":"Symfony\\Component\\VarDumper\\Cloner\\Data":private]=>\n  int(-1)\n  ["useRefHandles":"Symfony\\Component\\VarDumper\\Cloner\\Data":private]=>\n  int(-1)\n}\n\nEOTXT;\n        ob_start();\n        var_dump($clone);\n        $this->assertStringMatchesFormat(\\PHP_VERSION_ID >= 70200 ? str_replace(\'"1"\', \'1\', $expected) : $expected, ob_get_clean());\n    }\n\n    public function testCaster()\n    {\n        $cloner = new VarCloner([\n            \'*\' => function ($obj, $array) {\n                return [\'foo\' => 123];\n            },\n            __CLASS__ => function ($obj, $array) {\n                ++$array[\'foo\'];\n\n                return $array;\n            },\n        ]);\n        $clone = $cloner->cloneVar($this);\n\n        $expected = <<<EOTXT\nSymfony\\Component\\VarDumper\\Cloner\\Data Object\n(\n    [data:Symfony\\Component\\VarDumper\\Cloner\\Data:private] => Array\n        (\n            [0] => Array\n                (\n                    [0] => Symfony\\Component\\VarDumper\\Cloner\\Stub Object\n                        (\n                            [type] => 4\n                            [class] => %s\n                            [value] => \n                            [cut] => 0\n                            [handle] => %i\n                            [refCount] => 0\n                            [position] => 1\n                            [attr] => Array\n                                (\n                                )\n\n                        )\n\n                )\n\n            [1] => Array\n                (\n                    [foo] => 124\n                )\n\n        )\n\n    [position:Symfony\\Component\\VarDumper\\Cloner\\Data:private] => 0\n    [key:Symfony\\Component\\VarDumper\\Cloner\\Data:private] => 0\n    [maxDepth:Symfony\\Component\\VarDumper\\Cloner\\Data:private] => 20\n    [maxItemsPerDepth:Symfony\\Component\\VarDumper\\Cloner\\Data:private] => -1\n    [useRefHandles:Symfony\\Component\\VarDumper\\Cloner\\Data:private] => -1\n)\n\nEOTXT;\n        $this->assertStringMatchesFormat($expected, print_r($clone, true));\n    }\n\n    /**\n     * @requires PHP 7.4\n     */\n    public function testPhp74()\n    {\n        $data = new Php74();\n\n        $cloner = new VarCloner();\n        $clone = $cloner->cloneVar($data);\n\n        $expected = <<<\'EOTXT\'\nSymfony\\Component\\VarDumper\\Cloner\\Data Object\n(\n    [data:Symfony\\Component\\VarDumper\\Cloner\\Data:private] => Array\n        (\n            [0] => Array\n                (\n                    [0] => Symfony\\Component\\VarDumper\\Cloner\\Stub Object\n                        (\n                            [type] => 4\n                            [class] => Symfony\\Component\\VarDumper\\Tests\\Fixtures\\Php74\n                            [value] => \n                            [cut] => 0\n                            [handle] => %i\n                            [refCount] => 0\n                            [position] => 1\n                            [attr] => Array\n                                (\n                                )\n\n                        )\n\n                )\n\n            [1] => Array\n                (\n                    [p1] => 123\n                    [p2] => Symfony\\Component\\VarDumper\\Cloner\\Stub Object\n                        (\n                            [type] => 4\n                            [class] => stdClass\n                            [value] => \n                            [cut] => 0\n                            [handle] => %i\n                            [refCount] => 0\n                            [position] => 0\n                            [attr] => Array\n                                (\n                                )\n\n                        )\n\n                )\n\n        )\n\n    [position:Symfony\\Component\\VarDumper\\Cloner\\Data:private] => 0\n    [key:Symfony\\Component\\VarDumper\\Cloner\\Data:private] => 0\n    [maxDepth:Symfony\\Component\\VarDumper\\Cloner\\Data:private] => 20\n    [maxItemsPerDepth:Symfony\\Component\\VarDumper\\Cloner\\Data:private] => -1\n    [useRefHandles:Symfony\\Component\\VarDumper\\Cloner\\Data:private] => -1\n)\n\nEOTXT;\n        $this->assertStringMatchesFormat($expected, print_r($clone, true));\n    }\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Tests/Dumper/CliDumperTest.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Tests\\Dumper;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Symfony\\Component\\VarDumper\\Cloner\\VarCloner;\nuse Symfony\\Component\\VarDumper\\Dumper\\AbstractDumper;\nuse Symfony\\Component\\VarDumper\\Dumper\\CliDumper;\nuse Symfony\\Component\\VarDumper\\Test\\VarDumperTestTrait;\nuse Twig\\Environment;\nuse Twig\\Loader\\FilesystemLoader;\n\n/**\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass CliDumperTest extends TestCase\n{\n    use VarDumperTestTrait;\n\n    public function testGet()\n    {\n        require __DIR__.\'/../Fixtures/dumb-var.php\';\n\n        $dumper = new CliDumper(\'php://output\');\n        $dumper->setColors(false);\n        $cloner = new VarCloner();\n        $cloner->addCasters([\n            \':stream\' => function ($res, $a) {\n                unset($a[\'uri\'], $a[\'wrapper_data\']);\n\n                return $a;\n            },\n        ]);\n        $data = $cloner->cloneVar($var);\n\n        ob_start();\n        $dumper->dump($data);\n        $out = ob_get_clean();\n        $out = preg_replace(\'/[ \\t]+$/m\', \'\', $out);\n        $intMax = \\PHP_INT_MAX;\n        $res = (int) $var[\'res\'];\n\n        $r = \\defined(\'HHVM_VERSION\') ? \'\' : \'#%d\';\n        $this->assertStringMatchesFormat(\n            <<<EOTXT\narray:24 [\n  "number" => 1\n  0 => &1 null\n  "const" => 1.1\n  1 => true\n  2 => false\n  3 => NAN\n  4 => INF\n  5 => -INF\n  6 => {$intMax}\n  "str" => "déjà\\\\n"\n  7 => b"é\\\\x00"\n  "[]" => []\n  "res" => stream resource {@{$res}\n%A  wrapper_type: "plainfile"\n    stream_type: "STDIO"\n    mode: "r"\n    unread_bytes: 0\n    seekable: true\n%A  options: []\n  }\n  "obj" => Symfony\\Component\\VarDumper\\Tests\\Fixture\\DumbFoo {#%d\n    +foo: "foo"\n    +"bar": "bar"\n  }\n  "closure" => Closure {{$r}\n    class: "Symfony\\Component\\VarDumper\\Tests\\Dumper\\CliDumperTest"\n    this: Symfony\\Component\\VarDumper\\Tests\\Dumper\\CliDumperTest {{$r} …}\n    parameters: {\n      \\$a: {}\n      &\\$b: {\n        typeHint: "PDO"\n        default: null\n      }\n    }\n    file: "%s%eTests%eFixtures%edumb-var.php"\n    line: "{$var[\'line\']} to {$var[\'line\']}"\n  }\n  "line" => {$var[\'line\']}\n  "nobj" => array:1 [\n    0 => &3 {#%d}\n  ]\n  "recurs" => &4 array:1 [\n    0 => &4 array:1 [&4]\n  ]\n  8 => &1 null\n  "sobj" => Symfony\\Component\\VarDumper\\Tests\\Fixture\\DumbFoo {#%d}\n  "snobj" => &3 {#%d}\n  "snobj2" => {#%d}\n  "file" => "{$var[\'file\']}"\n  b"bin-key-é" => ""\n]\n\nEOTXT\n            ,\n            $out\n        );\n    }\n\n    /**\n     * @dataProvider provideDumpWithCommaFlagTests\n     */\n    public function testDumpWithCommaFlag($expected, $flags)\n    {\n        $dumper = new CliDumper(null, null, $flags);\n        $dumper->setColors(false);\n        $cloner = new VarCloner();\n\n        $var = [\n            \'array\' => [\'a\', \'b\'],\n            \'string\' => \'hello\',\n            \'multiline string\' => "this\\nis\\na\\multiline\\nstring",\n        ];\n\n        $dump = $dumper->dump($cloner->cloneVar($var), true);\n\n        $this->assertSame($expected, $dump);\n    }\n\n    public function testDumpWithCommaFlagsAndExceptionCodeExcerpt()\n    {\n        $dumper = new CliDumper(null, null, CliDumper::DUMP_TRAILING_COMMA);\n        $dumper->setColors(false);\n        $cloner = new VarCloner();\n\n        $ex = new \\RuntimeException(\'foo\');\n\n        $dump = $dumper->dump($cloner->cloneVar($ex)->withRefHandles(false), true);\n\n        $this->assertStringMatchesFormat(<<<\'EOTXT\'\nRuntimeException {\n  #message: "foo"\n  #code: 0\n  #file: "%ACliDumperTest.php"\n  #line: %d\n  trace: {\n    %ACliDumperTest.php:%d {\n      › \n      › $ex = new \\RuntimeException(\'foo\');\n      › \n    }\n    %A\n  }\n}\n\nEOTXT\n            , $dump);\n    }\n\n    public function provideDumpWithCommaFlagTests()\n    {\n        $expected = <<<\'EOTXT\'\narray:3 [\n  "array" => array:2 [\n    0 => "a",\n    1 => "b"\n  ],\n  "string" => "hello",\n  "multiline string" => """\n    this\\n\n    is\\n\n    a\\multiline\\n\n    string\n    """\n]\n\nEOTXT;\n\n        yield [$expected, CliDumper::DUMP_COMMA_SEPARATOR];\n\n        $expected = <<<\'EOTXT\'\narray:3 [\n  "array" => array:2 [\n    0 => "a",\n    1 => "b",\n  ],\n  "string" => "hello",\n  "multiline string" => """\n    this\\n\n    is\\n\n    a\\multiline\\n\n    string\n    """,\n]\n\nEOTXT;\n\n        yield [$expected, CliDumper::DUMP_TRAILING_COMMA];\n    }\n\n    /**\n     * @requires extension xml\n     * @requires PHP < 8.0\n     */\n    public function testXmlResource()\n    {\n        $var = xml_parser_create();\n\n        $this->assertDumpMatchesFormat(\n            <<<\'EOTXT\'\nxml resource {\n  current_byte_index: %i\n  current_column_number: %i\n  current_line_number: 1\n  error_code: XML_ERROR_NONE\n}\nEOTXT\n            ,\n            $var\n        );\n    }\n\n    public function testJsonCast()\n    {\n        $var = (array) json_decode(\'{"0":{},"1":null}\');\n        foreach ($var as &$v) {\n        }\n        $var[] = &$v;\n        $var[\'\'] = 2;\n\n        if (\\PHP_VERSION_ID >= 70200) {\n            $this->assertDumpMatchesFormat(\n                <<<\'EOTXT\'\narray:4 [\n  0 => {}\n  1 => &1 null\n  2 => &1 null\n  "" => 2\n]\nEOTXT\n                ,\n                $var\n            );\n        } else {\n            $this->assertDumpMatchesFormat(\n                <<<\'EOTXT\'\narray:4 [\n  "0" => {}\n  "1" => &1 null\n  0 => &1 null\n  "" => 2\n]\nEOTXT\n                ,\n                $var\n            );\n        }\n    }\n\n    public function testObjectCast()\n    {\n        $var = (object) [1 => 1];\n        $var->{1} = 2;\n\n        if (\\PHP_VERSION_ID >= 70200) {\n            $this->assertDumpMatchesFormat(\n                <<<\'EOTXT\'\n{\n  +"1": 2\n}\nEOTXT\n                ,\n                $var\n            );\n        } else {\n            $this->assertDumpMatchesFormat(\n                <<<\'EOTXT\'\n{\n  +1: 1\n  +"1": 2\n}\nEOTXT\n                ,\n                $var\n            );\n        }\n    }\n\n    public function testClosedResource()\n    {\n        if (\\defined(\'HHVM_VERSION\') && HHVM_VERSION_ID < 30600) {\n            $this->markTestSkipped();\n        }\n\n        $var = fopen(__FILE__, \'r\');\n        fclose($var);\n\n        $dumper = new CliDumper(\'php://output\');\n        $dumper->setColors(false);\n        $cloner = new VarCloner();\n        $data = $cloner->cloneVar($var);\n\n        ob_start();\n        $dumper->dump($data);\n        $out = ob_get_clean();\n        $res = (int) $var;\n\n        $this->assertStringMatchesFormat(\n            <<<EOTXT\nClosed resource @{$res}\n\nEOTXT\n            ,\n            $out\n        );\n    }\n\n    public function testFlags()\n    {\n        putenv(\'DUMP_LIGHT_ARRAY=1\');\n        putenv(\'DUMP_STRING_LENGTH=1\');\n\n        $var = [\n            range(1, 3),\n            [\'foo\', 2 => \'bar\'],\n        ];\n\n        $this->assertDumpEquals(\n            <<<EOTXT\n[\n  [\n    1\n    2\n    3\n  ]\n  [\n    0 => (3) "foo"\n    2 => (3) "bar"\n  ]\n]\nEOTXT\n            ,\n            $var\n        );\n\n        putenv(\'DUMP_LIGHT_ARRAY=\');\n        putenv(\'DUMP_STRING_LENGTH=\');\n    }\n\n    /**\n     * @requires function Twig\\Template::getSourceContext\n     */\n    public function testThrowingCaster()\n    {\n        $out = fopen(\'php://memory\', \'r+b\');\n\n        require_once __DIR__.\'/../Fixtures/Twig.php\';\n        $twig = new \\__TwigTemplate_VarDumperFixture_u75a09(new Environment(new FilesystemLoader()));\n\n        $dumper = new CliDumper();\n        $dumper->setColors(false);\n        $cloner = new VarCloner();\n        $cloner->addCasters([\n            \':stream\' => function ($res, $a) {\n                unset($a[\'wrapper_data\']);\n\n                return $a;\n            },\n        ]);\n        $cloner->addCasters([\n            \':stream\' => eval(\'return function () use ($twig) {\n                try {\n                    $twig->render([]);\n                } catch (\\Twig\\Error\\RuntimeError $e) {\n                    throw $e->getPrevious();\n                }\n            };\'),\n        ]);\n        $ref = (int) $out;\n\n        $data = $cloner->cloneVar($out);\n        $dumper->dump($data, $out);\n        $out = stream_get_contents($out, -1, 0);\n\n        $r = \\defined(\'HHVM_VERSION\') ? \'\' : \'#%d\';\n        $this->assertStringMatchesFormat(\n            <<<EOTXT\nstream resource {@{$ref}\n  ⚠: Symfony\\Component\\VarDumper\\Exception\\ThrowingCasterException {{$r}\n    #message: "Unexpected Exception thrown from a caster: Foobar"\n    trace: {\n      %sTwig.php:2 {\n        › foo bar\n        ›   twig source\n        › \n      }\n      %s%eTemplate.php:%d { …}\n      %s%eTemplate.php:%d { …}\n      %s%eTemplate.php:%d { …}\n      %s%eTests%eDumper%eCliDumperTest.php:%d { …}\n%A  }\n  }\n%Awrapper_type: "PHP"\n  stream_type: "MEMORY"\n  mode: "%s+b"\n  unread_bytes: 0\n  seekable: true\n  uri: "php://memory"\n%Aoptions: []\n}\n\nEOTXT\n            ,\n            $out\n        );\n    }\n\n    public function testRefsInProperties()\n    {\n        $var = (object) [\'foo\' => \'foo\'];\n        $var->bar = &$var->foo;\n\n        $dumper = new CliDumper();\n        $dumper->setColors(false);\n        $cloner = new VarCloner();\n\n        $data = $cloner->cloneVar($var);\n        $out = $dumper->dump($data, true);\n\n        $r = \\defined(\'HHVM_VERSION\') ? \'\' : \'#%d\';\n        $this->assertStringMatchesFormat(\n            <<<EOTXT\n{{$r}\n  +"foo": &1 "foo"\n  +"bar": &1 "foo"\n}\n\nEOTXT\n            ,\n            $out\n        );\n    }\n\n    /**\n     * @runInSeparateProcess\n     * @preserveGlobalState disabled\n     * @requires PHP 5.6\n     */\n    public function testSpecialVars56()\n    {\n        $var = $this->getSpecialVars();\n\n        $this->assertDumpEquals(\n            <<<\'EOTXT\'\narray:3 [\n  0 => array:1 [\n    0 => &1 array:1 [\n      0 => &1 array:1 [&1]\n    ]\n  ]\n  1 => array:1 [\n    "GLOBALS" => &2 array:1 [\n      "GLOBALS" => &2 array:1 [&2]\n    ]\n  ]\n  2 => &2 array:1 [&2]\n]\nEOTXT\n            ,\n            $var\n        );\n    }\n\n    /**\n     * @runInSeparateProcess\n     * @preserveGlobalState disabled\n     */\n    public function testGlobalsNoExt()\n    {\n        $var = $this->getSpecialVars();\n        unset($var[0]);\n        $out = \'\';\n\n        $dumper = new CliDumper(function ($line, $depth) use (&$out) {\n            if ($depth >= 0) {\n                $out .= str_repeat(\'  \', $depth).$line."\\n";\n            }\n        });\n        $dumper->setColors(false);\n        $cloner = new VarCloner();\n\n        $refl = new \\ReflectionProperty($cloner, \'useExt\');\n        $refl->setAccessible(true);\n        $refl->setValue($cloner, false);\n\n        $data = $cloner->cloneVar($var);\n        $dumper->dump($data);\n\n        $this->assertSame(\n            <<<\'EOTXT\'\narray:2 [\n  1 => array:1 [\n    "GLOBALS" => &1 array:1 [\n      "GLOBALS" => &1 array:1 [&1]\n    ]\n  ]\n  2 => &1 array:1 [&1]\n]\n\nEOTXT\n            ,\n            $out\n        );\n    }\n\n    /**\n     * @runInSeparateProcess\n     * @preserveGlobalState disabled\n     */\n    public function testBuggyRefs()\n    {\n        if (\\PHP_VERSION_ID >= 50600) {\n            $this->markTestSkipped(\'PHP 5.6 fixed refs counting\');\n        }\n\n        $var = $this->getSpecialVars();\n        $var = $var[0];\n\n        $dumper = new CliDumper();\n        $dumper->setColors(false);\n        $cloner = new VarCloner();\n\n        $data = $cloner->cloneVar($var)->withMaxDepth(3);\n        $out = \'\';\n        $dumper->dump($data, function ($line, $depth) use (&$out) {\n            if ($depth >= 0) {\n                $out .= str_repeat(\'  \', $depth).$line."\\n";\n            }\n        });\n\n        $this->assertSame(\n            <<<\'EOTXT\'\narray:1 [\n  0 => array:1 [\n    0 => array:1 [\n      0 => array:1 [ …1]\n    ]\n  ]\n]\n\nEOTXT\n            ,\n            $out\n        );\n    }\n\n    public function testIncompleteClass()\n    {\n        $unserializeCallbackHandler = ini_set(\'unserialize_callback_func\', null);\n        $var = unserialize(\'O:8:"Foo\\Buzz":0:{}\');\n        ini_set(\'unserialize_callback_func\', $unserializeCallbackHandler);\n\n        $this->assertDumpMatchesFormat(\n            <<<EOTXT\n__PHP_Incomplete_Class(Foo\\Buzz) {}\nEOTXT\n            ,\n            $var\n        );\n    }\n\n    public function provideDumpArrayWithColor()\n    {\n        yield [\n            [\'foo\' => \'bar\'],\n            0,\n            <<<EOTXT\n\\e[0;38;5;208m\\e[38;5;38marray:1\\e[0;38;5;208m [\\e[m\n  \\e[0;38;5;208m"\\e[38;5;113mfoo\\e[0;38;5;208m" => "\\e[1;38;5;113mbar\\e[0;38;5;208m"\\e[m\n\\e[0;38;5;208m]\\e[m\n\nEOTXT\n        ];\n\n        yield [[], AbstractDumper::DUMP_LIGHT_ARRAY, "\\e[0;38;5;208m[]\\e[m\\n"];\n\n        yield [\n            [\'foo\' => \'bar\'],\n            AbstractDumper::DUMP_LIGHT_ARRAY,\n            <<<EOTXT\n\\e[0;38;5;208m[\\e[m\n  \\e[0;38;5;208m"\\e[38;5;113mfoo\\e[0;38;5;208m" => "\\e[1;38;5;113mbar\\e[0;38;5;208m"\\e[m\n\\e[0;38;5;208m]\\e[m\n\nEOTXT\n        ];\n\n        yield [[], 0, "\\e[0;38;5;208m[]\\e[m\\n"];\n    }\n\n    /**\n     * @dataProvider provideDumpArrayWithColor\n     */\n    public function testDumpArrayWithColor($value, $flags, $expectedOut)\n    {\n        if (\'\\\\\' === \\DIRECTORY_SEPARATOR) {\n            $this->markTestSkipped(\'Windows console does not support coloration\');\n        }\n\n        $out = \'\';\n        $dumper = new CliDumper(function ($line, $depth) use (&$out) {\n            if ($depth >= 0) {\n                $out .= str_repeat(\'  \', $depth).$line."\\n";\n            }\n        }, null, $flags);\n        $dumper->setColors(true);\n        $cloner = new VarCloner();\n        $dumper->dump($cloner->cloneVar($value));\n\n        $this->assertSame($expectedOut, $out);\n    }\n\n    private function getSpecialVars()\n    {\n        foreach (array_keys($GLOBALS) as $var) {\n            if (\'GLOBALS\' !== $var) {\n                unset($GLOBALS[$var]);\n            }\n        }\n\n        $var = function &() {\n            $var = [];\n            $var[] = &$var;\n\n            return $var;\n        };\n\n        return [$var(), $GLOBALS, &$GLOBALS];\n    }\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Tests/Dumper/FunctionsTest.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Tests\\Dumper;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Symfony\\Component\\VarDumper\\Cloner\\VarCloner;\nuse Symfony\\Component\\VarDumper\\Dumper\\CliDumper;\nuse Symfony\\Component\\VarDumper\\VarDumper;\n\nclass FunctionsTest extends TestCase\n{\n    public function testDumpReturnsFirstArg()\n    {\n        $this->setupVarDumper();\n\n        $var1 = 'a';\n\n        ob_start();\n        $return = dump($var1);\n        ob_end_clean();\n\n        $this->assertEquals($var1, $return);\n    }\n\n    public function testDumpReturnsAllArgsInArray()\n    {\n        $this->setupVarDumper();\n\n        $var1 = 'a';\n        $var2 = 'b';\n        $var3 = 'c';\n\n        ob_start();\n        $return = dump($var1, $var2, $var3);\n        ob_end_clean();\n\n        $this->assertEquals([$var1, $var2, $var3], $return);\n    }\n\n    protected function setupVarDumper()\n    {\n        $cloner = new VarCloner();\n        $dumper = new CliDumper('php://output');\n        VarDumper::setHandler(function ($var) use ($cloner, $dumper) {\n            $dumper->dump($cloner->cloneVar($var));\n        });\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Tests/Dumper/HtmlDumperTest.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Tests\\Dumper;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Symfony\\Component\\VarDumper\\Cloner\\VarCloner;\nuse Symfony\\Component\\VarDumper\\Dumper\\HtmlDumper;\n\n/**\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass HtmlDumperTest extends TestCase\n{\n    public function testGet()\n    {\n        if (ini_get(\'xdebug.file_link_format\') || get_cfg_var(\'xdebug.file_link_format\')) {\n            $this->markTestSkipped(\'A custom file_link_format is defined.\');\n        }\n\n        require __DIR__.\'/../Fixtures/dumb-var.php\';\n\n        $dumper = new HtmlDumper(\'php://output\');\n        $dumper->setDumpHeader(\'<foo></foo>\');\n        $dumper->setDumpBoundaries(\'<bar>\', \'</bar>\');\n        $cloner = new VarCloner();\n        $cloner->addCasters([\n            \':stream\' => function ($res, $a) {\n                unset($a[\'uri\'], $a[\'wrapper_data\']);\n\n                return $a;\n            },\n        ]);\n        $data = $cloner->cloneVar($var);\n\n        ob_start();\n        $dumper->dump($data);\n        $out = ob_get_clean();\n        $out = preg_replace(\'/[ \\t]+$/m\', \'\', $out);\n        $var[\'file\'] = htmlspecialchars($var[\'file\'], \\ENT_QUOTES, \'UTF-8\');\n        $intMax = \\PHP_INT_MAX;\n        preg_match(\'/sf-dump-\\d+/\', $out, $dumpId);\n        $dumpId = $dumpId[0];\n        $res = (int) $var[\'res\'];\n\n        $r = \\defined(\'HHVM_VERSION\') ? \'\' : \'<a class=sf-dump-ref>#%d</a>\';\n        $this->assertStringMatchesFormat(\n            <<<EOTXT\n<foo></foo><bar><span class=sf-dump-note>array:24</span> [<samp>\n  "<span class=sf-dump-key>number</span>" => <span class=sf-dump-num>1</span>\n  <span class=sf-dump-key>0</span> => <a class=sf-dump-ref href=#{$dumpId}-ref01 title="2 occurrences">&amp;1</a> <span class=sf-dump-const>null</span>\n  "<span class=sf-dump-key>const</span>" => <span class=sf-dump-num>1.1</span>\n  <span class=sf-dump-key>1</span> => <span class=sf-dump-const>true</span>\n  <span class=sf-dump-key>2</span> => <span class=sf-dump-const>false</span>\n  <span class=sf-dump-key>3</span> => <span class=sf-dump-num>NAN</span>\n  <span class=sf-dump-key>4</span> => <span class=sf-dump-num>INF</span>\n  <span class=sf-dump-key>5</span> => <span class=sf-dump-num>-INF</span>\n  <span class=sf-dump-key>6</span> => <span class=sf-dump-num>{$intMax}</span>\n  "<span class=sf-dump-key>str</span>" => "<span class=sf-dump-str title="5 characters">d&%s;j&%s;<span class=sf-dump-default>\\\\n</span></span>"\n  <span class=sf-dump-key>7</span> => b"<span class=sf-dump-str title="2 binary or non-UTF-8 characters">&%s;<span class=sf-dump-default>\\\\x00</span></span>"\n  "<span class=sf-dump-key>[]</span>" => []\n  "<span class=sf-dump-key>res</span>" => <span class=sf-dump-note>stream resource</span> <a class=sf-dump-ref>@{$res}</a><samp>\n%A  <span class=sf-dump-meta>wrapper_type</span>: "<span class=sf-dump-str title="9 characters">plainfile</span>"\n    <span class=sf-dump-meta>stream_type</span>: "<span class=sf-dump-str title="5 characters">STDIO</span>"\n    <span class=sf-dump-meta>mode</span>: "<span class=sf-dump-str>r</span>"\n    <span class=sf-dump-meta>unread_bytes</span>: <span class=sf-dump-num>0</span>\n    <span class=sf-dump-meta>seekable</span>: <span class=sf-dump-const>true</span>\n%A  <span class=sf-dump-meta>options</span>: []\n  </samp>}\n  "<span class=sf-dump-key>obj</span>" => <abbr title="Symfony\\Component\\VarDumper\\Tests\\Fixture\\DumbFoo" class=sf-dump-note>DumbFoo</abbr> {<a class=sf-dump-ref href=#{$dumpId}-ref2%d title="2 occurrences">#%d</a><samp id={$dumpId}-ref2%d>\n    +<span class=sf-dump-public title="Public property">foo</span>: "<span class=sf-dump-str title="3 characters">foo</span>"\n    +"<span class=sf-dump-public title="Runtime added dynamic property">bar</span>": "<span class=sf-dump-str title="3 characters">bar</span>"\n  </samp>}\n  "<span class=sf-dump-key>closure</span>" => <span class=sf-dump-note>Closure</span> {{$r}<samp>\n    <span class=sf-dump-meta>class</span>: "<span class=sf-dump-str title="Symfony\\Component\\VarDumper\\Tests\\Dumper\\HtmlDumperTest\n55 characters"><span class="sf-dump-ellipsis sf-dump-ellipsis-class">Symfony\\Component\\VarDumper\\Tests\\Dumper</span><span class=sf-dump-ellipsis>\\</span>HtmlDumperTest</span>"\n    <span class=sf-dump-meta>this</span>: <abbr title="Symfony\\Component\\VarDumper\\Tests\\Dumper\\HtmlDumperTest" class=sf-dump-note>HtmlDumperTest</abbr> {{$r} &%s;}\n    <span class=sf-dump-meta>parameters</span>: {<samp>\n      <span class=sf-dump-meta>\\$a</span>: {}\n      <span class=sf-dump-meta>&amp;\\$b</span>: {<samp>\n        <span class=sf-dump-meta>typeHint</span>: "<span class=sf-dump-str title="3 characters">PDO</span>"\n        <span class=sf-dump-meta>default</span>: <span class=sf-dump-const>null</span>\n      </samp>}\n    </samp>}\n    <span class=sf-dump-meta>file</span>: "<span class=sf-dump-str title="{$var[\'file\']}\n%d characters"><span class="sf-dump-ellipsis sf-dump-ellipsis-path">%s%eVarDumper</span><span class=sf-dump-ellipsis>%e</span>Tests%eFixtures%edumb-var.php</span>"\n    <span class=sf-dump-meta>line</span>: "<span class=sf-dump-str title="%d characters">{$var[\'line\']} to {$var[\'line\']}</span>"\n  </samp>}\n  "<span class=sf-dump-key>line</span>" => <span class=sf-dump-num>{$var[\'line\']}</span>\n  "<span class=sf-dump-key>nobj</span>" => <span class=sf-dump-note>array:1</span> [<samp>\n    <span class=sf-dump-index>0</span> => <a class=sf-dump-ref href=#{$dumpId}-ref03 title="2 occurrences">&amp;3</a> {<a class=sf-dump-ref href=#{$dumpId}-ref2%d title="3 occurrences">#%d</a>}\n  </samp>]\n  "<span class=sf-dump-key>recurs</span>" => <a class=sf-dump-ref href=#{$dumpId}-ref04 title="2 occurrences">&amp;4</a> <span class=sf-dump-note>array:1</span> [<samp id={$dumpId}-ref04>\n    <span class=sf-dump-index>0</span> => <a class=sf-dump-ref href=#{$dumpId}-ref04 title="2 occurrences">&amp;4</a> <span class=sf-dump-note>array:1</span> [<a class=sf-dump-ref href=#{$dumpId}-ref04 title="2 occurrences">&amp;4</a>]\n  </samp>]\n  <span class=sf-dump-key>8</span> => <a class=sf-dump-ref href=#{$dumpId}-ref01 title="2 occurrences">&amp;1</a> <span class=sf-dump-const>null</span>\n  "<span class=sf-dump-key>sobj</span>" => <abbr title="Symfony\\Component\\VarDumper\\Tests\\Fixture\\DumbFoo" class=sf-dump-note>DumbFoo</abbr> {<a class=sf-dump-ref href=#{$dumpId}-ref2%d title="2 occurrences">#%d</a>}\n  "<span class=sf-dump-key>snobj</span>" => <a class=sf-dump-ref href=#{$dumpId}-ref03 title="2 occurrences">&amp;3</a> {<a class=sf-dump-ref href=#{$dumpId}-ref2%d title="3 occurrences">#%d</a>}\n  "<span class=sf-dump-key>snobj2</span>" => {<a class=sf-dump-ref href=#{$dumpId}-ref2%d title="3 occurrences">#%d</a>}\n  "<span class=sf-dump-key>file</span>" => "<span class=sf-dump-str title="%d characters">{$var[\'file\']}</span>"\n  b"<span class=sf-dump-key>bin-key-&%s;</span>" => ""\n</samp>]\n</bar>\n\nEOTXT\n            ,\n\n            $out\n        );\n    }\n\n    public function testCharset()\n    {\n        $var = mb_convert_encoding(\'Словарь\', \'CP1251\', \'UTF-8\');\n\n        $dumper = new HtmlDumper(\'php://output\', \'CP1251\');\n        $dumper->setDumpHeader(\'<foo></foo>\');\n        $dumper->setDumpBoundaries(\'<bar>\', \'</bar>\');\n        $cloner = new VarCloner();\n\n        $data = $cloner->cloneVar($var);\n        $out = $dumper->dump($data, true);\n\n        $this->assertStringMatchesFormat(\n            <<<\'EOTXT\'\n<foo></foo><bar>b"<span class=sf-dump-str title="7 binary or non-UTF-8 characters">&#1057;&#1083;&#1086;&#1074;&#1072;&#1088;&#1100;</span>"\n</bar>\n\nEOTXT\n            ,\n            $out\n        );\n    }\n\n    public function testAppend()\n    {\n        $out = fopen(\'php://memory\', \'r+b\');\n\n        $dumper = new HtmlDumper();\n        $dumper->setDumpHeader(\'<foo></foo>\');\n        $dumper->setDumpBoundaries(\'<bar>\', \'</bar>\');\n        $cloner = new VarCloner();\n\n        $dumper->dump($cloner->cloneVar(123), $out);\n        $dumper->dump($cloner->cloneVar(456), $out);\n\n        $out = stream_get_contents($out, -1, 0);\n\n        $this->assertSame(<<<\'EOTXT\'\n<foo></foo><bar><span class=sf-dump-num>123</span>\n</bar>\n<bar><span class=sf-dump-num>456</span>\n</bar>\n\nEOTXT\n            ,\n            $out\n        );\n    }\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Tests/Fixtures/DateTimeChild.php',
    "<?php\n\nnamespace Symfony\\Component\\VarDumper\\Tests\\Fixtures;\n\nclass DateTimeChild extends \\DateTime\n{\n    private $addedProperty = 'foo';\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Tests/Fixtures/dumb-var.php',
    "<?php\n\nnamespace Symfony\\Component\\VarDumper\\Tests\\Fixture;\n\nif (!class_exists('Symfony\\Component\\VarDumper\\Tests\\Fixture\\DumbFoo')) {\n    class DumbFoo\n    {\n        public $foo = 'foo';\n    }\n}\n\n$foo = new DumbFoo();\n$foo->bar = 'bar';\n\n$g = fopen(__FILE__, 'r');\n\n$var = [\n    'number' => 1, null,\n    'const' => 1.1, true, false, NAN, INF, -INF, PHP_INT_MAX,\n    'str' => \"déjà\\n\", \"\\xE9\\x00\",\n    '[]' => [],\n    'res' => $g,\n    'obj' => $foo,\n    'closure' => function ($a, \\PDO &$b = null) {},\n    'line' => __LINE__ - 1,\n    'nobj' => [(object) []],\n];\n\n$r = [];\n$r[] = &$r;\n\n$var['recurs'] = &$r;\n$var[] = &$var[0];\n$var['sobj'] = $var['obj'];\n$var['snobj'] = &$var['nobj'][0];\n$var['snobj2'] = $var['nobj'][0];\n$var['file'] = __FILE__;\n$var[\"bin-key-\\xE9\"] = '';\n\nunset($g, $r);\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Tests/Fixtures/FooInterface.php',
    '<?php\n\nnamespace Symfony\\Component\\VarDumper\\Tests\\Fixtures;\n\ninterface FooInterface\n{\n    /**\n     * Hello.\n     */\n    public function foo();\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Tests/Fixtures/GeneratorDemo.php',
    '<?php\n\nnamespace Symfony\\Component\\VarDumper\\Tests\\Fixtures;\n\nclass GeneratorDemo\n{\n    public static function foo()\n    {\n        yield 1;\n    }\n\n    public function baz()\n    {\n        yield from bar();\n    }\n}\n\nfunction bar()\n{\n    yield from GeneratorDemo::foo();\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Tests/Fixtures/NotLoadableClass.php',
    '<?php\n\nnamespace Symfony\\Component\\VarDumper\\Tests\\Fixtures;\n\nclass NotLoadableClass extends NotLoadableClass\n{\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Tests/Fixtures/Php74.php',
    '<?php\n\nnamespace Symfony\\Component\\VarDumper\\Tests\\Fixtures;\n\nclass Php74\n{\n    public $p1 = 123;\n    public \\stdClass $p2;\n\n    public function __construct()\n    {\n        $this->p2 = new \\stdClass();\n    }\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Tests/Fixtures/Twig.php',
    "<?php\n\n/* foo.twig */\nclass __TwigTemplate_VarDumperFixture_u75a09 extends Twig\\Template\n{\n    private $path;\n\n    public function __construct(Twig\\Environment $env = null, $path = null)\n    {\n        if (null !== $env) {\n            parent::__construct($env);\n        }\n        $this->parent = false;\n        $this->blocks = [];\n        $this->path = $path;\n    }\n\n    protected function doDisplay(array $context, array $blocks = [])\n    {\n        // line 2\n        throw new \\Exception('Foobar');\n    }\n\n    public function getTemplateName()\n    {\n        return 'foo.twig';\n    }\n\n    public function getDebugInfo()\n    {\n        return [20 => 1, 21 => 2];\n    }\n\n    public function getSourceContext()\n    {\n        return new Twig\\Source(\"   foo bar\\n     twig source\\n\\n\", 'foo.twig', $this->path ?: __FILE__);\n    }\n}\n",
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Tests/Fixtures/xml_reader.xml',
    '<?xml version="1.0" encoding="UTF-8"?>\n<foo>\n    <bar></bar>\n    <bar />\n    <bar>With text</bar>\n    <bar foo="bar" baz="fubar"></bar>\n    <bar xmlns:baz="http://symfony.com">\n        <baz:baz></baz:baz>\n    </bar>\n</foo>\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/Tests/Test/VarDumperTestTraitTest.php',
    '<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper\\Tests\\Test;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Symfony\\Component\\VarDumper\\Test\\VarDumperTestTrait;\n\nclass VarDumperTestTraitTest extends TestCase\n{\n    use VarDumperTestTrait;\n\n    public function testItComparesLargeData()\n    {\n        $howMany = 700;\n        $data = array_fill_keys(range(0, $howMany), [\'a\', \'b\', \'c\', \'d\']);\n\n        $expected = sprintf("array:%d [\\n", $howMany + 1);\n        for ($i = 0; $i <= $howMany; ++$i) {\n            $expected .= <<<EODUMP\n  $i => array:4 [\n    0 => "a"\n    1 => "b"\n    2 => "c"\n    3 => "d"\n  ]\\n\nEODUMP;\n        }\n        $expected .= "]\\n";\n\n        $this->assertDumpEquals($expected, $data);\n    }\n}\n',
  )
  php.writeFile(
    '/arena/vendor/symfony/var-dumper/VarDumper.php',
    "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\VarDumper;\n\nuse Symfony\\Component\\VarDumper\\Cloner\\VarCloner;\nuse Symfony\\Component\\VarDumper\\Dumper\\CliDumper;\nuse Symfony\\Component\\VarDumper\\Dumper\\HtmlDumper;\n\n// Load the global dump() function\nrequire_once __DIR__.'/Resources/functions/dump.php';\n\n/**\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass VarDumper\n{\n    private static $handler;\n\n    public static function dump($var)\n    {\n        if (null === self::$handler) {\n            $cloner = new VarCloner();\n            $dumper = \\in_array(\\PHP_SAPI, ['cli', 'phpdbg'], true) ? new CliDumper() : new HtmlDumper();\n            self::$handler = function ($var) use ($cloner, $dumper) {\n                $dumper->dump($cloner->cloneVar($var));\n            };\n        }\n\n        return \\call_user_func(self::$handler, $var);\n    }\n\n    public static function setHandler(callable $callable = null)\n    {\n        $prevHandler = self::$handler;\n        self::$handler = $callable;\n\n        return $prevHandler;\n    }\n}\n",
  )
}
